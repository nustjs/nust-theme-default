<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nust.js - A modern static site engine</title>
    <link>https://aotu.io</link>
    <atom:link href="https://aotu.io/rss2-en.xml" rel="self" type="application/rss+xml"/>
    
    <description>A modern static site generator built on top of Nuxt.js and Vue.js</description>
    <pubDate>2017-05-25T09:11:19.000Z</pubDate>
    <generator>https://nustjs.com/</generator>
    
    <item>
      <title>一个栗子实践vue2.0与1.0的区别</title>
      <link>https://aotu.io/notes/2016-12-29/vue-clock</link>
      <guid>https://aotu.io/notes/2016-12-29/vue-clock</guid>
      <pubDate>2016-12-28T17:35:12.000Z</pubDate>
      <description>
      
        能用一个栗子解决的问题，都不是问题~~~
      
      </description>
      
      <content:encoded><![CDATA[<h3 id=序言>序言</h3><p>本文通过一个初熟的小栗子来实践2.0与1.0的不同之处，最终的效果如下图所示：<p><img src=//misc.aotu.io/yangzicheng/vue-clock/vue-clock_1.gif alt=""><h3 id=提示>提示</h3><ul><li>可作为vue2.0+vuex入门参考<li>只粘贴核心代码，看源码建议直接下载<a href=https://github.com/yangzicheng/vue-clock>demo</a> <font size=2 color=#aaa>其实只有sass没有贴上啦</font><li>demo在移动端亲测可用</ul><h3 id=搭建项目>搭建项目</h3><h4 id=知识点>知识点</h4><p>这个栗子将涉及以下知识点：<ul><li>vue2.0<li>vue-cli脚手架<li>vuex状态管理库<li>webpack</ul><h4 id=版本声明>版本声明</h4><p>本篇文章的版本：<ul><li>node: v6.2.0<li>vue: v2.1.0<li>vuex: v2.0.0<li>vue-router: v2.1.1<li>webpack: v1.13.2</ul><h4 id=文件目录>文件目录</h4><p><img src=//misc.aotu.io/yangzicheng/vue-clock/vue-clock_2.png alt=""><h4 id=安装>安装</h4><p>首先请确保已安装了node、npm、webpack。<ol><li><p>安装vue脚手架。<pre class=nust-code><code class="hljs bash"> npm install vue-cli -g</code></pre><li><p>选择一个目录并执行。<pre class=nust-code><code class="hljs bash"> vue init webpack 项目名字 或者vue init webpack-simple 项目名字 &lt;注意不能用中文></code></pre><p>然后根据命令行的相关提示输入信息； webpack与webpack-simple两者的区别在于webpack-simple没有包括eslint等功能，普通的项目用simple就好了； 我使用的是前者。<li><p>进入项目目录下载相关依赖。<pre class=nust-code><code class="hljs bash"> <span class=hljs-built_in>cd</span> 项目目录
 npm install</code></pre><li><p>启动。<pre class=nust-code><code class="hljs bash"> npm run dev</code></pre></ol><p>这一行命令会自动启动浏览器并运行项目(如果你不想占用8080端口，可通过 项目 <code>/config/index.js</code> 中的port修改)。<p><img src=//misc.aotu.io/yangzicheng/vue-clock/vue-clock_3.png alt=""><h3 id=初始化>初始化</h3><h4 id=初始化入口js文件-main-js>初始化入口js文件 main.js</h4><p>main.js是应用入口文件，可以在这里<ul><li>配置路由vue-router<li>引入路由子组件<li>引入状态管理store(注入所有子组件)<li>实例化Vue<li>引入公共样式等</ul><p>已完成的main.js如下： <font size=2 color=#aaa>懒癌患者可直接拷贝</font><pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> Vue <span class=hljs-keyword>from</span> <span class=hljs-string>'vue'</span>
<span class=hljs-keyword>import</span> store <span class=hljs-keyword>from</span> <span class=hljs-string>'./store'</span>
<span class=hljs-comment>//引入路由及组件</span>
<span class=hljs-keyword>import</span> VueRouter <span class=hljs-keyword>from</span> <span class=hljs-string>'vue-router'</span>
<span class=hljs-keyword>import</span> App <span class=hljs-keyword>from</span> <span class=hljs-string>'./App'</span>
<span class=hljs-keyword>import</span> Home <span class=hljs-keyword>from</span> <span class=hljs-string>'./components/Home'</span>
<span class=hljs-keyword>import</span> Clocklist <span class=hljs-keyword>from</span> <span class=hljs-string>'./components/Clocklist'</span>
<span class=hljs-comment>//引入公共css</span>
<span class=hljs-keyword>import</span> <span class=hljs-string>'./static/css/reset.css'</span>

Vue.use(VueRouter)

<span class=hljs-comment>//定义路由</span>
<span class=hljs-keyword>const</span> routes = [
    {
        <span class=hljs-attr>path</span> : <span class=hljs-string>'/'</span>,
        <span class=hljs-attr>component</span> : Home
    },
    {
        <span class=hljs-attr>path</span> : <span class=hljs-string>'/home'</span>,
        <span class=hljs-attr>component</span> : Home
    },
    {
        <span class=hljs-attr>path</span> : <span class=hljs-string>'/clocklist'</span>,
        <span class=hljs-attr>component</span> : Clocklist
    },
]

<span class=hljs-comment>//创建实例</span>
<span class=hljs-keyword>const</span> router = <span class=hljs-keyword>new</span> VueRouter({
  routes
})

<span class=hljs-comment>//实例化，并将store、router挂载到根实例，从而应用到整个项目</span>
<span class=hljs-keyword>new</span> Vue({
  store,
  router,
  ...App
}).$mount(<span class=hljs-string>'#app'</span>)<span class=hljs-comment>//或者直接在options里声明挂载的el</span></code></pre><blockquote><p>与1.0的不同<ul><li><strong>映射路由：</strong>1.0是通过router的map方法映射路由，并且map接收的是一个对象，2.0中map()被替换了，通过实例化VueRouter并定义一个数组来映射路由；<li><strong>初始化路由：</strong>1.0通过router.start()来初始化路由，2.0中router.start()被替换了，直接通过挂载到vue根实例进行初始化</ul></blockquote><h4 id=初始化根组件app-vue>初始化根组件App.vue</h4><p>在App.vue中添加路由，并引入Sidebar.vue组件，对应的样式直接写在每个独立的组件下，注意这里使用了sass语法，需在 <code>./build/webpack.base.conf.js</code> 中配置，如下所示：<pre class=nust-code><code class="hljs js">vue: {
    <span class=hljs-attr>loaders</span>: utils.cssLoaders({ <span class=hljs-attr>sourceMap</span>: useCssSourceMap }),
    <span class=hljs-attr>postcss</span>: [
      <span class=hljs-built_in>require</span>(<span class=hljs-string>'autoprefixer'</span>)({
        <span class=hljs-attr>browsers</span>: [<span class=hljs-string>'last 2 versions'</span>]
      }),
      <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-import'</span>),
      <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-sass-extend'</span>),
      <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-simple-vars'</span>),
      <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-nested'</span>)<span class=hljs-comment>//sass嵌套语法，其他的看最后一个单词就知道是干什么的了</span>
    ]
  }</code></pre><p>下面附上整个App.vue的代码，注意看注释掉的部分哦。 <font size=2 color=#aaa>从这里开始后面的sass不贴出来了</font><pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-comment>&lt;!-- 不加会报错 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_wrap"</span>></span>
        <span class=hljs-comment>&lt;!--S 头部 --></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>section</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_header"</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>h1</span>></span>计时器<span class=hljs-tag>&lt;/<span class=hljs-name>h1</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>section</span>></span>
        <span class=hljs-comment>&lt;!--E 头部 --></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>section</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_container"</span>></span>
            <span class=hljs-comment>&lt;!--S 导航 --></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>nav</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_nav"</span>></span>
                <span class=hljs-tag>&lt;<span class=hljs-name>router-link</span> <span class=hljs-attr>to</span>=<span class=hljs-string>"/home"</span>></span>首页<span class=hljs-tag>&lt;/<span class=hljs-name>router-link</span>></span>
                <span class=hljs-tag>&lt;<span class=hljs-name>router-link</span> <span class=hljs-attr>to</span>=<span class=hljs-string>"/clocklist"</span>></span>计时列表<span class=hljs-tag>&lt;/<span class=hljs-name>router-link</span>></span>
            <span class=hljs-tag>&lt;/<span class=hljs-name>nav</span>></span>
            <span class=hljs-comment>&lt;!--E 导航 --></span>

            <span class=hljs-comment>&lt;!--S sidebar --></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar"</span>></span>
                <span class=hljs-tag>&lt;<span class=hljs-name>sidebar</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>sidebar</span>></span>
            <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
            <span class=hljs-comment>&lt;!--E sidebar --></span>

            <span class=hljs-comment>&lt;!--S 路由部分 --></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_router"</span>></span>
                <span class=hljs-comment>&lt;!-- &lt;transition mode="out-in"> --></span>
                <span class=hljs-tag>&lt;<span class=hljs-name>transition</span> <span class=hljs-attr>:name</span>=<span class=hljs-string>"transitionName"</span>></span>
                    <span class=hljs-tag>&lt;<span class=hljs-name>router-view</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_router_inner"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>router-view</span>></span>
                <span class=hljs-tag>&lt;/<span class=hljs-name>transition</span>></span>
            <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
            <span class=hljs-comment>&lt;!--E 路由部分 --></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>section</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
<span class=hljs-keyword>import</span> Sidebar <span class=hljs-keyword>from</span> <span class=hljs-string>'./components/Sidebar.vue'</span>
<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    <span class=hljs-attr>data</span>:<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
        <span class=hljs-keyword>return</span> {
            <span class=hljs-attr>transitionName</span>: <span class=hljs-string>'slide-left'</span>
        }
    },
    <span class=hljs-attr>mounted</span>:<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
        <span class=hljs-keyword>if</span>(<span class=hljs-keyword>this</span>.$route.name==<span class=hljs-literal>undefined</span>){
            <span class=hljs-keyword>this</span>.$router.push(<span class=hljs-string>'home'</span>);
        }
    },
    <span class=hljs-comment>/*watch: {
      '$route' (to, from) {
        console.log(to.path)
      }
    },*/</span>
    components: {
        Sidebar
    }
}
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>style</span>></span><span class="undefined">
@import './static/sass/_function.scss';

body {
    overflow: hidden;
}

.clock_header {
    height: 42px;
    line-height: 42px;
    background: #39383e;
    h1 {
        font-size: 18px;
        color: #fff;
        text-align: center;
        &::before {
            content: '';
            width: 18px;
            height: 18px;
            display: inline-block;
            vertical-align: middle;
            margin: -2px 5px 0 5px;
            background: url(./static/img/logo.png) no-repeat;
            background-size: 100% 100%;
        }
    }
}

.clock_nav {
    height: 36px;
    line-height: 36px;
    background: #f0eff5;
    padding-left: 5px;
    font-size: 0;
    a {
        display: inline-block;
        padding: 0 10px;
        position: relative;
        font-size: 14px;
        &.router-link-active {
            color: $color_red;
        }

        &:not(:last-child) {
            &::after {
                content: '';
                width: 1px;
                background: #e1e0e6;
                position: absolute;
                right: 0;
                top: 12px;
                bottom: 12px;
            }
        }
    }
}

.clock_container {
    @extend %clearfix;
}

.clock_sidebar {
    width: 30%;
    float: left;
    box-sizing: border-box;
    border: 1px solid #ddd;
    margin-top: 10px;
}

.clock_router {
    width: 70%;
    float: left;
    position: relative;
    &_inner {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        transition: all .3s linear;
    }
}

.slide-left-enter{
  opacity: 0;
  transform: translate3d(60px, 0, 0);
}

.slide-left-leave-active {
  opacity: 0;
  transform: translate3d(-60px, 0);
}
</span><span class=hljs-tag>&lt;/<span class=hljs-name>style</span>></span></code></pre><p>这里我将路由样式设置为相对定位，路由的子组件设置为绝对定位，可以解决切换路由的时候页面抖动问题。<blockquote><p>与1.0的不同<ul><li><strong>根元素：</strong>在2.0中template下需要有一个根元素（clock_wrap），否则会报错；<li><strong>路由导航：</strong>在1.0中我们通过v-link来指定导航链接，在2.0中可以直接使用router-link组件来导航，在浏览器中渲染后是一个a标签,并且会自动设置选中的class属性值.router-link-active， 然后通过to 属性指定链接；<li><strong>过渡：</strong>在1.0中通过在目标元素（router-view）使用transition与transition-mode添加过渡，在2.0中，则改成了使用transition标签包裹目标元素，可以自定义name过渡，也可以使用自带的mode添加过渡动效(如mode="out-in")，2.0中也支持通过$route设置基于路由的动态过渡；<li><strong>钩子：</strong>在1.0中的ready已经被mounted取代，此外2.0还新增了beforeMount、beforeUpdate、update等，下面是1.0与2.0生命周期示意图</ul></blockquote><h5 id=1-0>1.0</h5><p><img src=//misc.aotu.io/yangzicheng/vue-clock/vue-clock_4.png alt=""><h5 id=2-0>2.0</h5><p><img src=//misc.aotu.io/yangzicheng/vue-clock/vue-clock_5.png alt=""><h4 id=创建首页home-vue>创建首页Home.vue</h4><pre class=nust-code><code class="hljs django"><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_time"</span>></span>
        <span class=hljs-comment>&lt;!-- &lt;div class="clock_time_inner" v-html = "time"> --></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_time_inner"</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>i</span>></span></span><span class=hljs-template-variable>{{hour}}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>i</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span>></span>:<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>i</span>></span></span><span class=hljs-template-variable>{{minute}}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>i</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span>></span>:<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>i</span>></span></span><span class=hljs-template-variable>{{second}}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>i</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_time_btn"</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span> @<span class=hljs-attr>click</span> = <span class=hljs-string>'doClock'</span> <span class=hljs-attr>v-bind:id</span>=<span class=hljs-string>"clockId"</span>></span>开始计时<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
    <span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
        data() {
            <span class=hljs-keyword>return</span> {
                <span class=hljs-comment>//time: '',</span>
                hour: <span class=hljs-string>''</span>,
                <span class=hljs-attr>minute</span>: <span class=hljs-string>''</span>,
                <span class=hljs-attr>second</span>: <span class=hljs-string>''</span>,
                <span class=hljs-attr>clockId</span>: <span class=hljs-string>'clock_time'</span>
            }
        },
        mounted () {
            <span class=hljs-keyword>this</span>.nowTime()
        },
        <span class=hljs-attr>methods</span>: {
            nowTime () {
                <span class=hljs-keyword>const</span> t = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>(),
                    h = t.getHours(),
                    m = t.getMinutes(),
                    s = t.getSeconds()
                <span class=hljs-comment>//this.$data.time =  '&lt;i>' + h +'&lt;/i>&lt;span>:&lt;/span>&lt;i>' + m +'&lt;/i>&lt;span>:&lt;/span>&lt;i>' + s + '&lt;/i>'</span>
                <span class=hljs-keyword>this</span>.$data.hour = h
                <span class=hljs-keyword>this</span>.$data.minute = m
                <span class=hljs-keyword>this</span>.$data.second = s

                setTimeout(<span class=hljs-function><span class=hljs-params>()</span> =></span> {
                    <span class=hljs-keyword>this</span>.nowTime()
                }, <span class=hljs-number>1000</span>)
            },
            doClock () {
                <span class=hljs-keyword>const</span> nowTime = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>()

                <span class=hljs-comment>//状态</span>
                <span class=hljs-keyword>this</span>.$store.dispatch(<span class=hljs-string>'changeStatus'</span>)
                <span class=hljs-comment>//时长</span>
                <span class=hljs-keyword>this</span>.$store.dispatch(<span class=hljs-string>'addDuration'</span>)
                <span class=hljs-comment>//计时列表</span>
                <span class=hljs-keyword>this</span>.$store.dispatch(<span class=hljs-string>'saveClockList'</span>, nowTime)
            }
        }
    }
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span></code></pre><p>通过nowTime ()方法获取当前的时间，doClock ()分别变更状态、时长以及存储计时记录，后面会讲到vuex部分。<blockquote><p>与1.0的不同<ul><li><strong>数据绑定：</strong>与1.0一样绑定数据的形式都使用“Mustache” 语法，但2.0不能在html属性中使用了，比如栗子中的绑定id 的方法v-bind:id="clockId"而不能直接使用<code>{% raw %}{{clockId}}{% endraw %}</code>，否则会报错；<li><strong>真实的html：</strong>1.0中输出真实的html是使用三个大括号<code>{% raw %}{{{ }}}{% endraw %}</code>，2.0之后需要使用v-html指令，如上面注释掉的部分所示；</ul></blockquote><h4 id=创建侧边栏sidebar-vue>创建侧边栏Sidebar.vue</h4><pre class=nust-code><code class="hljs django"><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_inner"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_item"</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_title"</span>></span>状态<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_desc"</span> <span class=hljs-attr>:class</span> = <span class=hljs-string>"{ 'green': status == '已计时', 'red': status == '已结束'  }"</span>></span></span><span class=hljs-template-variable>{{ status }}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_item"</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_title"</span>></span>时长<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
            <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clock_sidebar_desc"</span>></span></span><span class=hljs-template-variable>{{ duration }}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
    <span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
        <span class=hljs-attr>computed</span>: {
            status() {
                <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.$store.getters.getStatus
            },
            duration() {
                <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.$store.getters.getDuration
            }
        }
    }
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span></code></pre><p>通过计算属性computed去获取状态与时长。<h4 id=继续创建打卡列表clocklist-vue>继续创建打卡列表Clocklist.vue</h4><pre class=nust-code><code class="hljs applescript">&lt;template>
    &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record"</span>>
        &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record_nothing"</span> v-<span class=hljs-keyword>if</span> = <span class=hljs-string>"!list.length"</span>>没有记录&lt;/<span class=hljs-keyword>div</span>>
        &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record_item"</span> v-<span class=hljs-keyword>else</span> = <span class=hljs-string>"list.length > 0"</span> v-<span class=hljs-keyword>for</span> = <span class=hljs-string>"(item, index) in list"</span>>
            &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record_name"</span>>&lt;i>{{index + <span class=hljs-number>1</span>}}&lt;/i>{{ <span class=hljs-built_in>item</span>.<span class=hljs-built_in>date</span> }}&lt;/<span class=hljs-keyword>div</span>>
            &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record_desc"</span>>计时开始 {{ <span class=hljs-built_in>item</span>.gotowork }}&lt;/<span class=hljs-keyword>div</span>>
            &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"clock_record_desc"</span>>计时结束 {{ <span class=hljs-built_in>item</span>.gooffwork }}&lt;/<span class=hljs-keyword>div</span>>
        &lt;/<span class=hljs-keyword>div</span>>
    &lt;/<span class=hljs-keyword>div</span>>
&lt;/template>

&lt;<span class=hljs-keyword>script</span>>
    export default {
        computed: {
            <span class=hljs-built_in>list</span> () {
<span class=hljs-built_in>                return</span> this.$store.getters.switchTime
            }
        }
    }
&lt;/<span class=hljs-keyword>script</span>></code></pre><blockquote><p>与1.0的不同<ul><li><strong>v-else-if：</strong>在2.0中新增了v-else-if，类似于js中的else if，不能单独使用，需跟在v-if之后；<li><strong>v-for：</strong>在使用v-for遍历对象的时候，当存在index时，1.0的参数顺序是(index, value)，2.0变成了(value, index)；<li><strong>v-for：</strong>1.0中，v-for块内有一个隐性的特殊变量$index可以获取当前数组的索引，在2.0中移除了，改为了以上这种显式的定义方式；<li><strong>key：</strong>key替代track-by</ul></blockquote><h4 id=vuex部分>vuex部分</h4><p>vuex是为vue.js设计的一个状态管理模式，主要是用来存储共享状态、实现数据通信，简单理解就是统一管理和维护各个vue组件的状态 ，它可以解决多层嵌套组件的传参、兄弟组件的状态传递等难题， 代码更结构化且容易维护。核心概念包括State、Getters、Mutations、Actions、Modules。<h5 id=创建index-js>创建index.js</h5><p>在src目录新建store文件夹用来存放共享数据(vuex)，然后新建index.js，用来初始化并导出 store。 <font size=2 color=#aaa>store已经在main.js中引入</font><pre class=nust-code><code class="hljs js"><span class=hljs-keyword>import</span> Vue <span class=hljs-keyword>from</span> <span class=hljs-string>'vue'</span>
<span class=hljs-keyword>import</span> Vuex <span class=hljs-keyword>from</span> <span class=hljs-string>'vuex'</span>
<span class=hljs-keyword>import</span> state <span class=hljs-keyword>from</span> <span class=hljs-string>'./state'</span>
<span class=hljs-keyword>import</span> getters <span class=hljs-keyword>from</span> <span class=hljs-string>'./getters'</span>
<span class=hljs-keyword>import</span> mutations <span class=hljs-keyword>from</span> <span class=hljs-string>'./mutations'</span>
<span class=hljs-keyword>import</span> actions <span class=hljs-keyword>from</span> <span class=hljs-string>'./actions'</span>

Vue.use(Vuex)

<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-keyword>new</span> Vuex.Store({
    state,
    getters,
    mutations,
    actions
    strict: process.env.NODE_ENV !== <span class=hljs-string>'production'</span>, <span class=hljs-comment>//是否开启严格模式</span>
})</code></pre><p>strict为是否开启严格模式，在这种模式下任何状态变更不是由Mutation函数触发的都会报错，但是为了避免性能损失，<strong>不要在发布环境开启严格模式</strong>； 在构建大型应用时，store对象会变的非常臃肿，Vuex允许将store分割为模块（module）,每个模块有自己个State、Mutations、Actions、Getters。<pre class=nust-code><code class="hljs js"><span class=hljs-keyword>const</span> moduleA = {
  <span class=hljs-attr>state</span>: { ... },
  <span class=hljs-attr>mutations</span>: { ... },
  <span class=hljs-attr>actions</span>: { ... },
  <span class=hljs-attr>getters</span>: { ... }
}

<span class=hljs-keyword>const</span> moduleB = {
  <span class=hljs-attr>state</span>: { ... },
  <span class=hljs-attr>mutations</span>: { ... },
  <span class=hljs-attr>actions</span>: { ... }
}

<span class=hljs-keyword>const</span> store = <span class=hljs-keyword>new</span> Vuex.Store({
  <span class=hljs-attr>modules</span>: {
    <span class=hljs-attr>a</span>: moduleA,
    <span class=hljs-attr>b</span>: moduleB
  }
})</code></pre><h4 id=创建state-js>创建state.js</h4><p>在store目录下继续创建state.js,代码如下<pre class=nust-code><code class="hljs js"><span class=hljs-keyword>const</span> state = { 
    <span class=hljs-attr>status</span>: <span class=hljs-string>'已结束'</span>,
    <span class=hljs-attr>duration</span>: <span class=hljs-string>'0'</span>,
    <span class=hljs-attr>timer</span>: <span class=hljs-literal>null</span>,
    <span class=hljs-attr>len</span>: <span class=hljs-number>0</span>,
    <span class=hljs-attr>clockList</span>: []
}

<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> state</code></pre><p>Vuex使用一个state包含了全部的应用层级状态--也就是一个<strong>单一状态树</strong>； 通常在计算属性(computed)返回(检测到数据发生变动时就会执行对相应数据有引用的函数)，如下：<pre class=nust-code><code class="hljs pf">computed: {
  list () {
        return this.<span class=hljs-variable>$store</span>.<span class=hljs-keyword>state</span>.status
    }
}</code></pre><h4 id=创建mutations-js>创建mutations.js</h4><p>在store目录下继续创建mutations.js。<pre class=nust-code><code class="hljs js"><span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> types <span class=hljs-keyword>from</span> <span class=hljs-string>'./mutation-types'</span>

<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    [ types.CHANGE_STATUS ] ( state) {
        <span class=hljs-keyword>if</span>( state.status === <span class=hljs-string>'已结束'</span> ) {
            state.status = <span class=hljs-string>'已计时'</span>
        }<span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span>(state.status === <span class=hljs-string>'已计时'</span>) {
            state.status = <span class=hljs-string>'已结束'</span>
        } 
    },
    [ types.ADD_DURATION ] ( state, obj ) {
           <span class=hljs-keyword>if</span>( state.status === <span class=hljs-string>'已计时'</span> ) {
                state.duration = obj.time
                state.timer = obj.timer
           }<span class=hljs-keyword>else</span> {
                clearInterval(obj.timer)
           }

    },
    [ types.SAVE_CLOCK_LIST] (state, nowTime) {
        <span class=hljs-keyword>if</span>( state.status === <span class=hljs-string>'已计时'</span> ) {
            <span class=hljs-built_in>console</span>.log(state.clockList.length)
            state.len = state.clockList.length
            state.clockList.push({<span class=hljs-string>"gotowork"</span>: nowTime, <span class=hljs-string>'gooffwork'</span>: <span class=hljs-string>''</span>})
        }

        <span class=hljs-keyword>if</span>( state.status === <span class=hljs-string>'已结束'</span> ) {
            state.clockList[state.len].gooffwork = nowTime
        }
    } 
}</code></pre><p>mutations是注册各种数据变化的方法，它接受state作为第一个参数，需注意以下几点<ul><li>变更state必须通过mutation提交，这样使得我们可以方便地跟踪每一个状态的变化<li>mutation 必须是同步函数，异步应在action操作<li>通常使用常量替代mutation事件类型,在实际操作中通常会建立一个mutation-types.js来存储mutation常量，这样的好处是可以对整个 app 包含的 mutation 一目了然</ul><h4 id=创建mutation-types-js>创建mutation-types.js</h4><p>在store目录下继续创建mutation-types.js，用来存储mutation事件名<pre class=nust-code><code class="hljs js"><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> CHANGE_STATUS = <span class=hljs-string>'CHANGE_STATUS'</span>
<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> ADD_DURATION = <span class=hljs-string>'ADD_DURATION'</span>
<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> SAVE_CLOCK_LIST = <span class=hljs-string>'SAVE_CLOCK_LIST'</span></code></pre><h4 id=创建actions-js>创建actions.js</h4><p>action类似autation，与之不同的是：<ul><li>action不能直接变更state，而是提交mutation<li>action可包含异步操作，而mutation不能（严格模式下报错）</ul><p>Action基本语法如下：<pre class=nust-code><code class="hljs js">actions: {
  someMethod (context) {
    context.commit(<span class=hljs-string>'someMethod'</span>)
  }
}</code></pre><p>action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 在实践中，通常使用 ES2015 的 参数解构简化代码，如下：<pre class=nust-code><code class="hljs js">actions: {
  someMethod ({ commit }) {
    commit(<span class=hljs-string>'someMethod'</span>)
  }
}</code></pre><p>最后附上actions.js的所有代码<pre class=nust-code><code class="hljs js"><span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> types <span class=hljs-keyword>from</span> <span class=hljs-string>'./mutation-types'</span>

<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    changeStatus({ commit }) {
        commit(types.CHANGE_STATUS)
    },
    addDuration(context) {
        <span class=hljs-keyword>let</span> num = <span class=hljs-number>1</span>, obj = {}

        <span class=hljs-keyword>if</span>(context.state.status === <span class=hljs-string>'已计时'</span>) {
            obj.timer = setInterval(<span class=hljs-function><span class=hljs-params>()</span> =></span> {
                <span class=hljs-keyword>let</span> h = <span class=hljs-built_in>parseInt</span>(num / <span class=hljs-number>3600</span>),
                    m = <span class=hljs-built_in>parseInt</span>(num / <span class=hljs-number>60</span>),
                    s = num

                    <span class=hljs-keyword>if</span>(s >= <span class=hljs-number>60</span>) {
                        s = s % <span class=hljs-number>60</span>
                    }

                    <span class=hljs-keyword>if</span>(m >= <span class=hljs-number>60</span>) {
                        m = m % <span class=hljs-number>60</span>
                    }

                obj.time = h + <span class=hljs-string>'时'</span> + m + <span class=hljs-string>'分'</span> + s + <span class=hljs-string>'秒'</span>
                context.commit(types.ADD_DURATION, obj)
                num ++
            }, <span class=hljs-number>1000</span>)
        }<span class=hljs-keyword>else</span> {
            context.commit(types.ADD_DURATION, obj)
        }
    },
    saveClockList({ commit }, nowTime) {
        commit(types.SAVE_CLOCK_LIST, nowTime)
    }
}</code></pre><h4 id=创建getters-js>创建getters.js</h4><pre class=nust-code><code class="hljs js"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
   <span class=hljs-attr>getStatus</span>:<span class=hljs-function><span class=hljs-params>state</span> =></span> state.status,
   <span class=hljs-attr>getDuration</span>:<span class=hljs-function><span class=hljs-params>state</span> =></span> state.duration,
   <span class=hljs-attr>switchTime</span>:<span class=hljs-function><span class=hljs-params>state</span> =></span> {
        <span class=hljs-comment>//转换前</span>
        <span class=hljs-keyword>let</span> date = <span class=hljs-string>''</span>,
            toTime = <span class=hljs-string>''</span>,
            offTime = <span class=hljs-string>''</span>,
            list = []
        <span class=hljs-comment>//转换后</span>
        <span class=hljs-keyword>let</span> switchDate = <span class=hljs-string>''</span>,
            switchToTime = <span class=hljs-string>''</span>,
            switchOffTime = <span class=hljs-string>''</span>

        state.clockList.forEach(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>v, i</span>) </span>{
            switchDate = v.gotowork.getFullYear() + <span class=hljs-string>'年'</span> + ( v.gotowork.getMonth() + <span class=hljs-number>1</span> ) + <span class=hljs-string>'月'</span> + v.gotowork.getDate()
            switchToTime = v.gotowork.getHours() + <span class=hljs-string>':'</span> + v.gotowork.getMinutes() + <span class=hljs-string>':'</span> + v.gotowork.getSeconds()
            <span class=hljs-keyword>if</span>(v.gooffwork !== <span class=hljs-string>''</span>) {
                switchOffTime = v.gooffwork.getHours() + <span class=hljs-string>':'</span> + v.gooffwork.getMinutes() + <span class=hljs-string>':'</span> + v.gooffwork.getSeconds()
            }<span class=hljs-keyword>else</span> {
                switchOffTime = <span class=hljs-string>''</span>
            }
            list.push({<span class=hljs-string>'date'</span>: switchDate, <span class=hljs-string>'gotowork'</span>: switchToTime, <span class=hljs-string>'gooffwork'</span>: switchOffTime})
        })

        <span class=hljs-keyword>return</span> list
   }
}</code></pre><p>getter接收state作为第一个参数，我们可以通过它<ul><li>获取state的状态<li>对需要返回的数据进行处理，如过滤、转换等</ul><h4 id=关于代码结构>关于代码结构</h4><p>只要遵守了vuex的规则，如何组织代码可根据项目的实际情况以及个人、团队的使用习惯，vuex并不会限制你的代码结构。所以，放开手脚一起搞事吧！<p>以上就是整篇文章的所有内容，如有错误，恳请指正！ <font size=2 color=#aaa>反正咱也不改</font><h3 id=写在最后>写在最后</h3><p>不得不说前端的技术更新真是快啊，从来没有哪个行业像前端这样繁荣却又令人不安。作为前端人，我们唯有保持对新技术敏锐的嗅觉与热情，才能避免被技术前进的浪潮拍在沙滩上，正所谓路漫漫其修远兮，吾将...<font size=2 color=#aaa>好了好了，搬砖去了</font>...<h3 id=参考资料>参考资料</h3><p><a href=http://cn.vuejs.org/v2/guide/ >http://cn.vuejs.org/v2/guide/</a> <a href=http://vuex.vuejs.org/zh-cn/getting-started.html>http://vuex.vuejs.org/zh-cn/getting-started.html</a> <a href=https://gold.xitu.io/post/583d1fe00ce463006baca2fa>https://gold.xitu.io/post/583d1fe00ce463006baca2fa</a> <a href=https://aotu.io/notes/2016/10/13/vue2/ >https://aotu.io/notes/2016/10/13/vue2/</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>京东2016版首页改版前端总结</title>
      <link>https://aotu.io/notes/2016-12-27/jd-index-2016-summary</link>
      <guid>https://aotu.io/notes/2016-12-27/jd-index-2016-summary</guid>
      <pubDate>2016-12-26T20:25:57.000Z</pubDate>
      <description>
      
        经过1个多月的奋战，京东2016版首页终于捅上线了，本文主要对此次改版项目中前端所做的工作进行总结
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>深圳的天气总是多变，前一段时间还是凉意浓浓，似乎要步入冬天了，最近却又变得炎热起来，气温骤升，让人措手不及。正如我们负责的业务一样，一年下来有诸多变化。今年9月份我们接手了京东2016版首页改版开发，历经1个多月紧张地开发测试，终于在双11前成功全量发布，回想整个开发历程，感觉还是有很多值得思索的地方，例如北京一月，虽然日夜颠倒，加班不止，但整个人居然胖了许多，不禁让人匪夷所思。</blockquote><h2 id=整体架构>整体架构</h2><p>最初听说要做新版京东首页的时候，是怀有一丝惶恐的，毕竟是作为京东的门户，其重要性和受关注程度自然不言而喻，一行代码的失误可能会造成不可挽回的后果，而且过去的首页无论性能，还有体验在业界都已经是做得非常优秀了，要再想有些出彩的地方，也是十分困难，所以综上就是压力山大。当然，花开两朵，咱们单表一枝，本文主要还是相对这次改版工作中提炼的工作方法和优化方式做出一定的总结。<p>这次改版，在前端架构上大体还是沿用过去的架构，使用 <code>jQuery</code> + <code>Seajs</code> 这种古老的开发方式，因为首页还依赖着许多旧的系统与组件，无法在短时间内对基础架构进行升级，当然并不是说旧的就不好，要去盲目追求一些新的东西，而是这种架构还是有可以提升的地方。<p>而整个项目的架构是经历之前业务进行总结提炼出来的<p><img src=//misc.aotu.io/luckyadam/index_2016/architecture.jpg alt=架构><p><strong><a href=https://github.com/o2team/athena>Athena前端工程化工具</a></strong>，是我们团队自己探索开发的一套基于<code>NodeJs</code>的命令行式前端工程化工具，解决了自动化编译、代码处理、依赖分析、文件压缩等前端开发中的常规问题，有效地提升了我们的工作效率，解放生产力，目前已经应用于我们团队的多个业务中，首页改版也使用<a href=https://github.com/o2team/athena>Athena</a>来进行开发；<p><strong>Athena管理平台</strong>，是Athena工具配套的管理后台，它会收集本地工具操作中上报的统计数据，包括项目、模块、页面、组件创建的信息，文件、资源依赖关系的信息等，通过这些数据来进行项目和资源的管理，同时提供了项目模板，方便使用本地工具创建项目时选择，具体可以参考之前的博文<a href=https://aotu.io/notes/2016/07/19/A-little-exploration-of-front-end-engineering/ >我们是如何做好前端工程化和静态资源管理</a>；<p><strong>Athena组件平台</strong>，是基于Athena总结的一套业务组件的平台，可以很好地管理我们的业务组件，方便组件的复用和传播；<p><strong><a href=https://github.com/o2team/channel-base>Athena基础库及组件库</a></strong>，是业务中总结出的基于<code>jQuery</code> + <code>Seajs</code>的js库，简化业务开发，提供完整的框架；<p><strong>Athena模拟接口</strong>，可以自由编辑生成指定接口的假数据，用于开发时真实接口的替代，让开发不再依赖后端接口；<p><strong>Athena兜底接口服务</strong>，可以指定接口生成一份兜底数据接口，平台会定时去抓取指定接口数据，然后生成兜底数据到CDN，从而生成对应的兜底接口，这样让正常接口多一份兜底保障；<p><strong>Athena前端监控</strong>，通过在页面中进行埋点上报的方式，我们可以在监控系统中，实时地看到性能相关数据。我们进行上报的不止有页面性能、速度相关的数据，同时会上报用户的环境信息，例如操作系统、浏览器、网速等，而且还会对页面中错误信息进行上报，如模块的隐藏等，通过这些数据，对我们的业务进行实时地监控与分析。<p>在我们的架构中，各种各样的工具与系统相辅相成，覆盖到了开发到上线的各个环节，自成一套体系。这样的架构不止是针对首页这个业务的，而是在基于对之前业务开发总结的基础上进行完善、调整的架构，适用于我们各个业务。而这次首页的改版中，我们对开发模式、性能优化、体验优化都进行了一些新的探索，让我们对于业务开发的整体解决方案又有了新的改进。<h2 id=开发模式>开发模式</h2><h3 id=athena>Athena</h3><p>开发效率的提升是我们一直追求的，工欲善其事，必先利其器，我们通过总结以往的开发工作，提出了各种手段来优化我们的开发效率，前端工具<code>Athena</code>就是其中的一个产物，当然它又不仅仅是为了提升开发效率而已，它是我们总结出的一套针对前端开发的完整解决方案，可以让我们的整体开发流程更加简单明了。<p><code>Athena</code>提供了统一的项目架构，根据业务功能不同，我们将一个项目(app)拆分成不同的业务模块(module)，而每一个模块都包含自身的页面(page)以及构成页面所需要的组件(widget)。<p><img src=//misc.aotu.io/luckyadam/index_2016/project_architecture.jpg alt=项目架构><p>在本地使用<code>Athena</code>创建完整的项目结构，随后我们就可以只关注代码逻辑的书写，<code>Athena</code>提供了简便的操作命令可以一键式地实时编译预览我们的页面，从而让我们不必去关心文件处理、代码编译等细节，开发完后，可以通过<code>Athena</code>执行完整的编译步骤并同步到我们的服务器上方便进行浏览测试。<p>使用<code>Athena</code>，新版首页开发模式大致如下：<p><img src=//misc.aotu.io/luckyadam/index_2016/workflow.jpg alt=开发模式><h3 id=前后端分离>前后端分离</h3><p>基于<code>Athena</code>工具，我们目前已经可以做到完全地本地开发调试了，但是还并不能做到完全的前后端分离，以过去首页为例，页面被拆分成<strong>首屏</strong>和<strong>楼层</strong>，首屏采用直出的方式以提升速度，楼层则使用异步加载的方式，拉取服务器上已经渲染好的<code>HTML</code>字符串，如图<p><img src=//misc.aotu.io/luckyadam/index_2016/past.jpg alt=过去模式><p>整个页面，包括首屏和楼层，都需要前端写好静态<code>HTML</code>，然后给后端开发同学来套用，转成后端语言对应的模板，这样导致前后端耦合较深，<code>HTML</code>更新极不方便，开发成本较高。<p>为了解决这样前后端耦合的问题，减少沟通成本，这次首页改版我们使用了新的开发方式，为了保证首屏速度，首屏依然采用直出的方式，但对非首屏的楼层进行改进，使用<strong>前端模板</strong> + <strong>数据</strong>开发方式，将DOM字符串的渲染放到前端来做，后端只提供数据接口，以此来达到前后端分离的效果，同时在开发中使用<strong>假数据平台</strong>模拟接口，让前端工作不再依赖后端。<p><img src=//misc.aotu.io/luckyadam/index_2016/now.jpg alt=现网模式><p>在最开始提出这样前后端分离方案的时候还是受到了不少的质疑，因为使用<strong>前端模板</strong> + <strong>数据</strong>开发方式，会使得每个楼层都多一个接口，并且需要依靠JS来动态渲染，会影响到楼层加载的性能，但经过我们的测试证明在现代PC浏览器下两种模式前端渲染和后端渲染并不会相差太多，并且在模板、数据双重缓存下，这样的差距更是微乎其微了，更关键的是能让我们的开发效率有所提升。<p><img src=//misc.aotu.io/luckyadam/index_2016/compare.jpg alt=性能数据对比><p>当然，我们对于性能的追求总是孜孜不倦，为了让楼层的加载速度更快，减少请求，我们在后续将使用在服务端定时获取数据编译前端模板，然后生成静态文件推送到CDN的方式来改进，和之前的由后端开发同学套模板生成静态文件不同的是，我们将自己搭建这样的中间层服务，在服务端编译前端模板，实现前后端同构，而前端可以随时切换渲染方式，改成请求渲染好的 <code>HTML</code> 字符串来进行加载，以此来提升性能。<h2 id=对性能优化的探索>对性能优化的探索</h2><p>性能永远是前端工程师追求的主题，过去首页在性能优化上已经做得非常极致了，它已经使用了各种手段来优化性能，包括首屏直出、样式直出来提升首屏速度，楼层按需加载，减少不必要的请求等等，所以在做新版首页的时候，我们感觉战战兢兢，因为改版不能让页面受到影响，而且最好还能比原来更快，所以，这次改版中我们主要通过如下手段来进行性能的优化。<h3 id=首屏直出和精简>首屏直出和精简</h3><p>首屏直出是让首屏速度更快的最佳选择，此次版本依然选择了首屏直出的方式，直出的内容包括首屏<code>HTML</code>，页面楼层骨架，以及样式和一些必须的脚本，看起来和之前的方式如出一辙，但此次改版我们还是做了很大的改进，那就是让首屏更加精简。<p>过去是将页面引用的所有样式都直出在页面上，没有外链的CSS，各种优化手段都考虑进去了，那么新版首页就只能在精简大小上下功夫了，所以新版首页的首屏只直出了首屏必须的样式，同时只直出一小部分必须的脚本，而非首屏的楼层样式拆分到各自楼层中，和楼层的模板放在一起，按需加载。<p>通过对<code>Athena</code>工具的改造，我们实现样式、模板的统一抽离这一功能，并且是在项目编译阶段自动实现的，开发者勿需关心。由于Athena统一的项目结构，每一个楼层在我们的项目中对应一个<code>widget</code>的组件，组件包含自己的<code>HTML</code> 、<code>CSS</code>、 <code>JavaScript</code>文件，同时<code>widget</code>的组件是可以继续调用其他<code>widget</code>的组件的，所以在编译时，工具会自动分析所有<code>widget</code>的依赖关系，然后把楼层的模板和所有引用到样式打包到一个文件中。最后在楼层加载的时候去请求这个文件，然后解析加载。这样的抽离工作会在最后的项目编译阶段进行，而进行本地开发预览的时候并不会执行，这样保证了开发的效率。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.js</span>
jsonCallBack_rec_tpl({
    <span class=hljs-attr>dom</span>: <span class=hljs-string>'{%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible && pageConfig.wideVersion;%}{% var len = o.list.length; len = Math.min(len, 3); %}{% if (len >= 1) { %}&lt;div class="grid_c1 rec_inner">&lt;ul class="rec_list">{% for(i = 0; i &lt; len; i++){ %}{% var item = o.list[i]; %}{% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %}&lt;li class="rec_item" fclog="{%= item.clog %}">&lt;a href="{%= item.url %}" class="rec_lk" target="_blank" clstag="{%= clstagPrefix + \'a\' + (i &lt; 9 ? \'0\' : \'\') + (1+i) %}">&lt;img src="//misc.360buyimg.com/mtd/pc/common/img/blank.png" data-lazy-img="{%= imgUrl %}" alt="{%= item.title %}" title="{%= item.title %}" class="rec_img" data-webp="no" >&lt;/a>&lt;/li>{% } %}&lt;/ul>&lt;/div>{% } %} '</span>,
    <span class=hljs-attr>style</span>: <span class=hljs-string>".rec_list{overflow:hidden;height:100px}.rec_item{overflow:hidden;float:left;width:396px;height:100%}.rec_lk{display:block;height:100%}.rec_img{display:block;margin:auto}.o2_mini .rec_item{width:330px}.csstransitions .rec_img{-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s}.csstransitions .rec_lk:hover .rec_img{opacity:.8}"</span>,
    <span class=hljs-attr>time</span>: <span class=hljs-number>1479195351434</span>,
    <span class=hljs-attr>version</span>: <span class=hljs-string>"ff78610a0ef9cdbb"</span>
});</code></pre><p>通过上述手段，我们让首屏变得更加精简，从下面的对比中就可以看出<p>这是过去首页首屏大小<p><img src=//misc.aotu.io/luckyadam/index_2016/past_size.jpg alt=过去首页首屏><p>这是新版首页首屏大小<p><img src=//misc.aotu.io/luckyadam/index_2016/now_size.jpg alt=新版首页首屏><p>可以看出优化精简之后，新版的首屏的大小减小了非常之多。<h3 id=首屏轮播第一帧直出>首屏轮播第一帧直出</h3><p>一直以来轮播都是靠页面最后加载的JS来进行渲染的，因为轮播图有随机渲染图片的逻辑需要依赖JS，但在一段时间的观察之后发现，如果CDN出现抖动，或者用户的网速较慢，那么首屏轮播这一块位置就会一直空着，给人的体验非常不好<p><img src=//misc.aotu.io/luckyadam/index_2016/past_carsouel.jpg alt=轮播><p>所以在这一版的首页中我们将轮播图第一帧的数据直出在页面上，同时也将第一帧的渲染逻辑也直出在页面上，这样一来，首屏轮播出来得就非常快，减少用户的等待时间。<p><img src=//misc.aotu.io/luckyadam/index_2016/now_carsouel.jpg alt=轮播><h3 id=楼层按需加载与滚动优化>楼层按需加载与滚动优化</h3><p>首屏直出后，非首屏的内容肯定也不会一次性全部加载，因为像首页这样的页面楼层非常之多，一次性加载全部不仅仅慢，而且对接口来说也是一种损耗，所以我们考虑将楼层按需加载。<p>在我们新的方案中，已经采用了前端模板+数据的开发模式，所以在开发中我们想用直接书写前端模板的方式来进行开发，然后在本地进行预览，而在项目编译时能将我们的模板编译成独立的文件，方便渲染逻辑进行加载。所幸<code>Athena</code>工具已经支持了这样的功能，在开发中我们以编写前端模板的方式去开发整个页面，随后通过编译工具，在代码编译阶段自动将楼层的模板和样式抽离成一个与组件同名的独立JS文件，通过页面加载逻辑去按需拉取模板文件，再进行渲染。<p>下面例子揭示了楼层模板生成的过程<blockquote><p>直接书写前端模板，编写模板时我们给模板加上标记位 o2-out-tpl<pre class=nust-code><code class="hljs javascript">&lt;script type=<span class=hljs-string>"text/template"</span> <span class=hljs-class><span class=hljs-keyword>class</span></span>=<span class=hljs-string>"o2template"</span> o2-out-tpl>
  {%
    <span class=hljs-keyword>var</span> i,
      clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;
    <span class=hljs-keyword>var</span> isWide = pageConfig.compatible && pageConfig.wideVersion;
  %}
   {% <span class=hljs-keyword>var</span> len = o.list.length; len = <span class=hljs-built_in>Math</span>.min(len, <span class=hljs-number>3</span>); %}
   {% <span class=hljs-keyword>if</span> (len >= <span class=hljs-number>1</span>) { %}
   &lt;div <span class=hljs-class><span class=hljs-keyword>class</span></span>=<span class=hljs-string>"grid_c1 rec_inner"</span>>
       <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ul</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"rec_list"</span>></span>
           {% for(i = 0; i <span class=hljs-tag>&lt; <span class=hljs-attr>len</span>; <span class=hljs-attr>i</span>++){ %}
           {% <span class=hljs-attr>var</span> <span class=hljs-attr>item</span> = <span class=hljs-string>o.list[i];</span> %}
           {% <span class=hljs-attr>var</span> <span class=hljs-attr>imgUrl</span> = <span class=hljs-string>isWide</span> ? <span class=hljs-attr>item.imgUrl</span> <span class=hljs-attr>:</span> <span class=hljs-attr>item.imgUrlB</span>; %}
           &lt;<span class=hljs-attr>li</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"rec_item"</span> <span class=hljs-attr>fclog</span>=<span class=hljs-string>"{%= item.clog %}"</span>></span>
               <span class=hljs-tag>&lt;<span class=hljs-name>a</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"{%= item.url %}"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"rec_lk"</span> <span class=hljs-attr>target</span>=<span class=hljs-string>"_blank"</span> <span class=hljs-attr>clstag</span>=<span class=hljs-string>"{%= clstagPrefix + 'a' + (i &lt; 9 ? '0' : '') + (1+i) %}"</span>></span>
                   <span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"//misc.360buyimg.com/mtd/pc/common/img/blank.png"</span> <span class=hljs-attr>data-lazy-img</span>=<span class=hljs-string>"{%= imgUrl %}"</span> <span class=hljs-attr>alt</span>=<span class=hljs-string>"{%= item.title %}"</span> <span class=hljs-attr>title</span>=<span class=hljs-string>"{%= item.title %}"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"rec_img"</span> <span class=hljs-attr>data-webp</span>=<span class=hljs-string>"no"</span> ></span>
               <span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>
           <span class=hljs-tag>&lt;/<span class=hljs-name>li</span>></span>
           {% } %}
       <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>></span>
   <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></span>
   {% } %}
&lt;<span class=hljs-regexp>/script></span></code></pre><p>在编译时扫描依赖关系，生成模板JS文件依赖组件的关系表<pre class=nust-code><code class="hljs xquery"><span class=hljs-string>"dependency"</span>: {
  <span class=hljs-string>"elevator_tpl.js"</span>: [],
  <span class=hljs-string>"entry_tpl.js"</span>: [
    {
      <span class=hljs-string>"widgetName"</span>: <span class=hljs-string>"spetit"</span>,
      <span class=hljs-string>"module"</span>: <span class=hljs-string>"home"</span>,
      <span class=hljs-string>"moduleId"</span>: <span class=hljs-string>"f1c9d790-765a-11e6-927d-63ab47c8eeb2"</span>,
      <span class=hljs-string>"widgetType"</span>: <span class=hljs-string>"widget"</span>,
      <span class=hljs-string>"exists"</span>: true
    }
  ],
  <span class=hljs-string>"fbt_tpl.js"</span>: [
    {
      <span class=hljs-string>"widgetName"</span>: <span class=hljs-string>"find"</span>,
      <span class=hljs-string>"module"</span>: <span class=hljs-string>"home"</span>,
      <span class=hljs-string>"moduleId"</span>: <span class=hljs-string>"f1c9d790-765a-11e6-927d-63ab47c8eeb2"</span>,
      <span class=hljs-string>"widgetType"</span>: <span class=hljs-string>"widget"</span>,
      <span class=hljs-string>"exists"</span>: true
    },
    {
      <span class=hljs-string>"widgetName"</span>: <span class=hljs-string>"brand"</span>,
      <span class=hljs-string>"module"</span>: <span class=hljs-string>"home"</span>,
      <span class=hljs-string>"moduleId"</span>: <span class=hljs-string>"f1c9d790-765a-11e6-927d-63ab47c8eeb2"</span>,
      <span class=hljs-string>"widgetType"</span>: <span class=hljs-string>"widget"</span>,
      <span class=hljs-string>"exists"</span>: true
    },
    {
      <span class=hljs-string>"widgetName"</span>: <span class=hljs-string>"top"</span>,
      <span class=hljs-string>"module"</span>: <span class=hljs-string>"home"</span>,
      <span class=hljs-string>"moduleId"</span>: <span class=hljs-string>"f1c9d790-765a-11e6-927d-63ab47c8eeb2"</span>,
      <span class=hljs-string>"widgetType"</span>: <span class=hljs-string>"widget"</span>,
      <span class=hljs-string>"exists"</span>: true
    }
  ]
}</code></pre><p>通过关系表去合并处理CSS样式，再和前端模板一起计算出MD5，生成独立的JS文件<pre class=nust-code><code class="hljs javascript">jsonCallBack_rec_tpl({<span class=hljs-attr>dom</span>:<span class=hljs-string>'{%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible && pageConfig.wideVersion;%}{% var len = o.list.length; len = Math.min(len, 3); %}{% if (len >= 1) { %}&lt;div class="grid_c1 rec_inner">&lt;ul class="rec_list">{% for(i = 0; i &lt; len; i++){ %}{% var item = o.list[i]; %}{% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %}&lt;li class="rec_item" fclog="{%= item.clog %}">&lt;a href="{%= item.url %}" class="rec_lk" target="_blank" clstag="{%= clstagPrefix + \'a\' + (i &lt; 9 ? \'0\' : \'\') + (1+i) %}">&lt;img src="//misc.360buyimg.com/mtd/pc/common/img/blank.png" data-lazy-img="{%= imgUrl %}" alt="{%= item.title %}" title="{%= item.title %}" class="rec_img" data-webp="no" >&lt;/a>&lt;/li>{% } %}&lt;/ul>&lt;/div>{% } %} '</span>,<span class=hljs-attr>style</span>:<span class=hljs-string>".rec_list{overflow:hidden;height:100px}.rec_item{overflow:hidden;float:left;width:396px;height:100%}.rec_lk{display:block;height:100%}.rec_img{display:block;margin:auto}.o2_mini .rec_item{width:330px}.csstransitions .rec_img{-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s}.csstransitions .rec_lk:hover .rec_img{opacity:.8}"</span>,<span class=hljs-attr>time</span>:<span class=hljs-number>1479466862559</span>,<span class=hljs-attr>version</span>:<span class=hljs-string>"ff78610a0ef9cdbb"</span>});</code></pre><p>同时会在逻辑脚本入口位置自动加入模板的版本号<pre class=nust-code><code class="hljs javascript">{
  <span class=hljs-string>"elevator_tpl"</span>: <span class=hljs-string>"e4d5dbaa3ecd12d2"</span>,
  <span class=hljs-string>"entry_tpl"</span>: <span class=hljs-string>"e3150fce4b2b332a"</span>,
  <span class=hljs-string>"fbt_tpl"</span>: <span class=hljs-string>"18f8bff18188a453"</span>,
  <span class=hljs-string>"floor_coupon_tpl"</span>: <span class=hljs-string>"1559694cb962e0d6"</span>,
  <span class=hljs-string>"floor_ract_tpl"</span>: <span class=hljs-string>"13b92d16fb6e2f7a"</span>,
  <span class=hljs-string>"mod_footer_tpl"</span>: <span class=hljs-string>"49142394d0e7f24e"</span>,
  <span class=hljs-string>"more_tpl"</span>: <span class=hljs-string>"d300081dd7f13f78"</span>,
  <span class=hljs-string>"portal_tpl"</span>: <span class=hljs-string>"68fae801a032cf93"</span>,
  <span class=hljs-string>"rec_tpl"</span>: <span class=hljs-string>"ff78610a0ef9cdbb"</span>,
  <span class=hljs-string>"seckill_tpl"</span>: <span class=hljs-string>"f11d04fd7eabc0e6"</span>
}</code></pre></blockquote><p>模板文件通过系统发布到CDN后，我们就需要有一套加载逻辑来进行加载。通过监听滚动事件，我们判断让处于浏览器视窗内的楼层进行加载，由于监听了滚动事件，为了让滚动更加流畅，我们必然要对滚动中做的操作进行优化。为了避免滚动操作不断被触发，需要对滚动进行节流处理。我们的原则是尽量避免在滚动的时候进行<code>DOM</code>操作与复杂计算，所以在渲染逻辑初始化的时候，我们就已经收集好了楼层的相关信息，包括楼层高度、楼层的<code>offsetTop</code>等，这样在滚动的时候就不再需要进行任何<code>DOM</code>操作了，让滚动的效率有所提升。而当楼层的数据例如楼层高度发生变化时，则通过消息通知的机制来实时地更新楼层信息即可。<h3 id=脚本延后加载执行>脚本延后加载执行</h3><p>除了楼层是按需加载的，页面中用到的一些脚本文件也是尽量延后加载、执行。<code>Athena</code>工具在代码打包的时候，会对每个独立的文件进行单独处理，同时生成一份静态资源的线上对应表，在编译的最后会将引用的资源替换成配置的线上绝对地址。我们可以使用<code>Seajs</code>提供的<code>require.async</code>API来进行异步加载资源，这样让资源加载更加合理。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// 开发中的代码</span>
<span class=hljs-built_in>require</span>.async(__uri(<span class=hljs-string>'APP_JS_ROOT/header.js'</span>))

<span class=hljs-comment>// 编译后</span>
<span class=hljs-built_in>require</span>.async(<span class=hljs-string>'//misc.360buyimg.com/mtd/pc/index/js/header.js'</span>)</code></pre><p>同时，还有业务上一些统计上报等逻辑，可以放到 <code>window onload</code> 事件之后再执行，这样可以避免由于类似统计这样的请求占用到页面加载资源，从而降低页面 <code>onload</code> 时间。<h3 id=模板-数据分离缓存>模板、数据分离缓存</h3><p>每个楼层都按需加载之后，每次去加载这个楼层是否都要重新去请求这个楼层的模板和数据呢？答案当然是否定的。<p>目前大部分浏览器已经提供了许多前端缓存的解决方案，而其中<a href="http://caniuse.com/#search=webstorage">兼容性</a>最好，易用性最强的非<code>localStorage</code>莫属。利用<code>localStorage</code>我们可以对模板和数据进行缓存，这样当用户第二次加载的时候就可以不用再去请求网络资源，而可以直接从本地获取了。<p>但缓存之后如何进行更新呢？我们可以通过进行MD5校验版本来实现。<p>对数据来说，数据是由后端给出的，我们可以让后端同学将可以缓存的接口数据计算出一个MD5值作为版本号，然后直出在页面上，同时在接口中返回这个版本号，这样当前端去加载是首先判断版本号是否一致，以此来判断是直接读缓存还是从网络请求资源。<p><img src=//misc.aotu.io/luckyadam/index_2016/source_version.jpg alt=接口版本号><p>而对于模板来说，则可以通过<code>Athena</code>工具，在每次编译的时候自行计算出版本号，写入模板文件和入口JS文件中，这样在模板加载的时候也可以进行比对。<p>单个模板文件<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.js</span>
jsonCallBack_rec_tpl({
    <span class=hljs-attr>dom</span>: <span class=hljs-string>'{%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible && pageConfig.wideVersion;%}{% var len = o.list.length; len = Math.min(len, 3); %}{% if (len >= 1) { %}&lt;div class="grid_c1 rec_inner">&lt;ul class="rec_list">{% for(i = 0; i &lt; len; i++){ %}{% var item = o.list[i]; %}{% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %}&lt;li class="rec_item" fclog="{%= item.clog %}">&lt;a href="{%= item.url %}" class="rec_lk" target="_blank" clstag="{%= clstagPrefix + \'a\' + (i &lt; 9 ? \'0\' : \'\') + (1+i) %}">&lt;img src="//misc.360buyimg.com/mtd/pc/common/img/blank.png" data-lazy-img="{%= imgUrl %}" alt="{%= item.title %}" title="{%= item.title %}" class="rec_img" data-webp="no" >&lt;/a>&lt;/li>{% } %}&lt;/ul>&lt;/div>{% } %} '</span>,
    <span class=hljs-attr>style</span>: <span class=hljs-string>".rec_list{overflow:hidden;height:100px}.rec_item{overflow:hidden;float:left;width:396px;height:100%}.rec_lk{display:block;height:100%}.rec_img{display:block;margin:auto}.o2_mini .rec_item{width:330px}.csstransitions .rec_img{-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s}.csstransitions .rec_lk:hover .rec_img{opacity:.8}"</span>,
    <span class=hljs-attr>time</span>: <span class=hljs-number>1479195351434</span>,
    <span class=hljs-attr>version</span>: <span class=hljs-string>"ff78610a0ef9cdbb"</span>
});</code></pre><p>JS入口文件<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// https://misc.360buyimg.com/mtd/pc/index/home/index_focus.min.js</span>
<span class=hljs-built_in>window</span>.tplVersion = {
    <span class=hljs-string>"1212_tpl"</span>: <span class=hljs-string>"ce7dcd7cd0beacb2"</span>,
    <span class=hljs-attr>elevator_tpl</span>: <span class=hljs-string>"e4d5dbaa3ecd12d2"</span>,
    <span class=hljs-attr>entry_tpl</span>: <span class=hljs-string>"2caa7cd543c322ea"</span>,
    <span class=hljs-attr>fbt_tpl</span>: <span class=hljs-string>"18f8bff18188a453"</span>,
    <span class=hljs-attr>floor_coupon_tpl</span>: <span class=hljs-string>"b98cf33be84aae98"</span>,
    <span class=hljs-attr>floor_ract_tpl</span>: <span class=hljs-string>"13b92d16fb6e2f7a"</span>,
    <span class=hljs-attr>mod_footer_tpl</span>: <span class=hljs-string>"072072ffc47778be"</span>,
    <span class=hljs-attr>more_tpl</span>: <span class=hljs-string>"25dcb060800c503a"</span>,
    <span class=hljs-attr>portal_tpl</span>: <span class=hljs-string>"68fae801a032cf93"</span>,
    <span class=hljs-attr>rec_tpl</span>: <span class=hljs-string>"ff78610a0ef9cdbb"</span>,
    <span class=hljs-attr>seckill_tpl</span>: <span class=hljs-string>"4fee56c5b073e5e1"</span>
};</code></pre><p>通过上述方式，我们实现了模板、数据的分离缓存，由于楼层类似的关系，页面中的模板大多数是重复，这样子模板缓存起来就能大大提高模板的利用率，当用户第二次访问的时候将不会再产生请求，在加速访问的同时，减少网络带宽消耗，并且如果数据发生更新，用户只需要更新数据即可，大大减少流量消耗。<h3 id=大量使用webp格式图片>大量使用WebP格式图片</h3><p>在这次改版中，很多的图片我们都使用了WebP格式来减小图片大小。<p>WebP格式，是谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。但WebP的兼容性不太好，目前基本只有<code>Chrome浏览器</code>可以支持，不过这对我们的首页来说，使用WebP还是会有很大的收益，因为通过我们的统计数据可知，首页<code>Chrome</code>用户已经占到了<code>60%</code>左右。<h2 id=体验优化探索>体验优化探索</h2><p>在努力提升页面性能的同时，还要让页面的用户体验有所提升，这需要我们能站在用户和前端的角度提出合理的优化方案。<h3 id=高清屏适配方案>高清屏适配方案</h3><p>人类的社会在发展，人类的社会在进步，现如今高清分辨率屏幕的应用已经越来越多，高冷的Mac自不必说，现在许多新型号的Windows电脑也配备了高清分辨率的显示器，所以为了提升这一部分用户的浏览体验，我们需要在高清屏上启用高清素材。<p>但页面中素材图基本都是运营上传的，如果传两套图对运营来说未免太过麻烦，但如果只传一套高清图，直接展示的话对非高清屏没有必要，会造成流量损耗。这时候京东给力的图片服务就发挥作用了。<p>图片服务支持按一定规则改变URL来等比缩放图片，例如原图是一张<code>800X340</code>的图片<pre class=nust-code><code class="hljs awk"><span class=hljs-regexp>//img</span>13.<span class=hljs-number>360</span>buyimg.com<span class=hljs-regexp>/cms/</span>jfs<span class=hljs-regexp>/t3412/</span><span class=hljs-number>357</span><span class=hljs-regexp>/1332248120/</span><span class=hljs-number>113691</span><span class=hljs-regexp>/f29c2f1e/</span><span class=hljs-number>58244</span>d4dN08b89f9e.jpg!q90.webp</code></pre><p>我们可以通过这样设置来得到一样等比缩放<code>400X170</code>的图片<pre class=nust-code><code class="hljs awk"><span class=hljs-regexp>//img</span>13.<span class=hljs-number>360</span>buyimg.com<span class=hljs-regexp>/cms/</span>s400x170_jfs<span class=hljs-regexp>/t3412/</span><span class=hljs-number>357</span><span class=hljs-regexp>/1332248120/</span><span class=hljs-number>113691</span><span class=hljs-regexp>/f29c2f1e/</span><span class=hljs-number>58244</span>d4dN08b89f9e.jpg!q90.webp</code></pre><p>这样的话，运营同学只需要上传一张高清图片，我们通过判断是否高清屏，来动态改变URL，使用图片服务来得到一张等比缩放的非高清素材，而且CDN会根据图片URL进行缓存，也就是说只要第一次访问过缩放的图片就好，这样性能也不会有什么损耗。<h3 id=强制webkit内核渲染>强制webkit内核渲染</h3><p>很多国产浏览器都是双内核，例如360、QQ浏览器等，而它们都提供了强制使用Webkit内核渲染的开启方式，这样可以让用户获得更好的浏览体验。<pre class=nust-code><code class="hljs routeros">&lt;meta <span class=hljs-attribute>name</span>=<span class=hljs-string>"renderer"</span> <span class=hljs-attribute>content</span>=<span class=hljs-string>"webkit"</span> /></code></pre><h3 id=opensearch>OpenSearch</h3><p>现在很多网站都能实现在浏览器搜索框内直接调用网站内部搜索的功能，这是通过 <strong>OpenSearch</strong> 来做到的，而京东之前一直是没有的，这样显然是不合适，而且有一些习惯于使用地址栏搜索的用户不能满足。在这次改版中，我们加上了这一功能，使得用户可以在浏览器地址栏就能直达京东搜索。<p><img src=//misc.aotu.io/luckyadam/index_2016/open_search.jpg alt=OpenSearch><h3 id=使用icon-font>使用Icon Font</h3><p>使用Icon Font可以提升设计师的发挥空间，在页面上使用一些特殊字体以提升页面的美观程度，让页面看起来更具有设计感，更加细腻，从而提升用户的浏览体验。<p><img src=//misc.aotu.io/luckyadam/index_2016/icon_font.jpg alt="Iconf font"><p>而且Icon Font兼容性非常好，可以让不同浏览器的用户获得一致的浏览体验，并且通过字体压缩工具，压缩后的字体文件也可以非常小，不会有太多的性能损耗。<h3 id=空闲时间自动加载楼层及图片>空闲时间自动加载楼层及图片</h3><p>前文提到，我们使用了按需加载来提升页面性能，但这样带来的问题就是只有当用户滚动楼层到浏览器视窗内，楼层才会开始加载，这样用户滚动得稍微快一点就会出现很多loading动画。<p><img src=//misc.aotu.io/luckyadam/index_2016/floor_auto_load.jpg alt=空闲加载><p>为了减少这种情况的发生，让用户觉得楼层也加载很快，在不影响页面滚动、加载性能的前提下我们在用户操作的空闲时间自动加载剩余的楼层和图片。<p>将楼层的加载操作放入一个队列中，我们可以在用户停止滚动操作3s后开始自动加载这个队列中的楼层，而当用户开始滚动的时候清空这个加载队列，停止滚动3秒后又重新开始加载。通过这样处理可以合理利用用户浏览的空闲时间来加载页面，让用户感觉页面加载更快。<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> scrollTimer = <span class=hljs-literal>null</span>;
<span class=hljs-keyword>var</span> isScrolling = <span class=hljs-literal>false</span>;
$(<span class=hljs-built_in>window</span>).bind(<span class=hljs-string>'scroll.loadFloor'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{
  isScrolling = <span class=hljs-literal>true</span>;
  clearTimeout(autoLoadTimer);
  clearTimeout(scrollTimer);
  autoLoadingQueue = [];
  resourceLoader && resourceLoader.pause();
  scrollTimer = setTimeout(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{
    isScrolling = <span class=hljs-literal>false</span>;
      <span class=hljs-keyword>if</span> (pageConfig.idleTimeLoad) {
      autoLoadTimer = setTimeout(autoLoad, <span class=hljs-number>3000</span>);
    }
  }, <span class=hljs-number>200</span>);
});

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>autoLoad</span> (<span class=hljs-params></span>) </span>{
  <span class=hljs-keyword>if</span> (!isScrolling) {
    runFloorLoadQueue();
  }
}</code></pre><h2 id=页面可用性保障和监控>页面可用性保障和监控</h2><h3 id=灾备策略>灾备策略</h3><p>对于像京东首页这种大流量的网站，后端接口可能偶尔会出现错误，或者直接挂掉，特别是在双11这种可能会达到流量峰值的时候，但是不能因为接口出错的原因而使得页面显示出现错误。这就需要前端来配合给出一套合理的灾备方案。<p>通常，我们通过接口缓存、超时、重试来进行灾备处理。目前首页大部分接口、及所有模板请求，在请求成功后都会存入本地缓存，第二次请求，假如缓存没有过期将直接使用缓存，假如缓存过期将会重新请求，而一次正常的请求，都会经过超时或异常重试的逻辑，来保证用户能尽量访问到正常的数据，在正常接口无法获取数据之后又会有兜底接口来保障数据来源，这样的层层保障，很好地保证了页面的完整性。而且，针对所有接口，前端均有数据校验逻辑，每一个后端接口都要经过前端的数据校验，来验证接口的可用性，假如接口数据异常，前端将主动调用兜底接口来替代，这样来保证页面不至于错乱。<p>综上所述，首页的接口和模板正常请求流程如下<p><img src=//misc.aotu.io/luckyadam/index_2016/request_flow.jpg alt=接口请求流程><p>这样一套复杂的流程下，每一个接口、模板请求都是统一的，所以需要对此进行封装，以便调用。首页是通过封装改造<code>$.ajax</code>来实现的，使用<code>$.ajaxPrefilter</code>和<code>$.ajaxTransport</code>方法对每个异步请求进行捕获处理，将接口、模板请求的重试、超时、缓存、兜底调用等封装起来，对调用者透明，使用起来变得非常容易，而不需要关心以上灾备策略的实现。<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> ajax = <span class=hljs-built_in>require</span>(<span class=hljs-string>'load_async'</span>);
<span class=hljs-comment>// 本质就是$.ajax方法</span>
ajax({
  <span class=hljs-attr>url</span>: <span class=hljs-string>'//f.3.cn/index-floor/?argv=aggr'</span>,
  <span class=hljs-attr>jsonpCallback</span>: <span class=hljs-string>'jsonpCallbakcAggr'</span>, <span class=hljs-comment>// jsonp回调函数名</span>
  params: {}, <span class=hljs-comment>// 参数</span>
  needStore: <span class=hljs-literal>true</span>, <span class=hljs-comment>// 是否需要缓存</span>
  storeSign: <span class=hljs-string>'3aad2efsdf'</span>, <span class=hljs-comment>//用户判断缓存是否过期的标记</span>
  timeout: <span class=hljs-number>3000</span>, <span class=hljs-comment>//接口超时</span>
  times: <span class=hljs-number>2</span>, <span class=hljs-comment>// 超时重试次数</span>
  backup: <span class=hljs-string>'//www.3.cn/bak/aggr'</span>, <span class=hljs-comment>// 兜底接口</span>
  dataCheck: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>result</span>) </span>{ <span class=hljs-comment>// 接口数据校验，校验接口返回数据，若为true则走正常逻辑，为false则自动调用兜底逻辑</span>
    <span class=hljs-keyword>if</span> (result && result.code === <span class=hljs-number>0</span>) {
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;
    }
    <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;
  }
});</code></pre><h3 id=数据统计驱动改进>数据统计驱动改进</h3><p>在这次首页改版项目中我们接入了<code>Athena测速系统</code>用于收集首页各种性能以及用户环境相关的数据，因为有了数据统计，我们才能知道用户端具体的情况信息，有了数据统计，我们才能对页面进行实时监控，有了数据统计，我们才能掌握我们做性能优化的成果，所有的分析都是要基于数据来进行，否则就是在自己在YY了。<p>目前我们主要收集了，用户网速、操作系统、浏览器分布、分辨率分布等各种信息，同时对于页面加载情况也有一定的监控，如页面测速打点上报、数据接口出现调用兜底接口的情况上报、楼层接口失败导致楼层隐藏的情况上报等。<p>通过以上数据统计，我们可以灵活地对我们的页面进行优化，同时及时发现问题，避免损失。例如我们通过统计发现用户在网速低于一定值时页面楼层隐藏数增多，这样我们就可以通过设置更长的超时时间来减少这一情况的发生，还有就是假如某时刻开始发现某接口调用兜底请求数暴增，可以判定接口出现问题而及时反馈给后端同学。<h2 id=更长远的探索>更长远的探索</h2><p>新版首页已经上线小一个月了，表现一直还算良好，我们做出的性能以及体验优化也得到了体现，在此基础上，我们思考了更多的可以做的工作，来提升首页的表现。<h3 id=静态资源预加载>静态资源预加载</h3><p>首页承载着许多页面的入口，如频道页还有活动页，在双11的时候，首页会有很多直达活动的入口，如果我们能在首页预加载某些重要的活动页面的资源的话，当用户去访问这些活动页面就能更加迅速地打开浏览了。<p><img src=//misc.aotu.io/luckyadam/index_2016/hermes.jpg alt=静态资源预加载><h3 id=架构升级>架构升级</h3><p><code>jQuery</code> + <code>Seajs</code>或许让人感到老旧且沮丧，我们考虑在首页上渐渐使用一些新的技术，例如去<strong>Seajs</strong>化，提供更优的打包方式，让页面性能进一步提升。<h3 id=中间层探索>中间层探索</h3><p>目前首页虽然差不多实现了前后端分离，但是首屏这里前后端依然存在耦合，假如前端可以介入到中间层的开发，那问题就迎刃而解了，接入中间层后，我们还可以将页面部分楼层做服务端渲染，以减少前端渲染的性能损耗，可以在实现前后端分离的基础上，让页面性能更好，还是有一定意义的。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>vim给代码行尾加分号的几种方法</title>
      <link>https://aotu.io/notes/2016-12-08/vim-4</link>
      <guid>https://aotu.io/notes/2016-12-08/vim-4</guid>
      <pubDate>2016-12-08T10:25:35.000Z</pubDate>
      <description>
      
        vim下给代码行尾添加分号的四种方法及介绍
      
      </description>
      
      <content:encoded><![CDATA[<p>给下面的代码每一行行尾加入分号，有几种方法呢？<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> foo = <span class=hljs-string>'aotu'</span>
<span class=hljs-keyword>var</span> bar = <span class=hljs-string>'is a team'</span>
<span class=hljs-keyword>var</span> foobar = foo + bar</code></pre><h2 id=方法一-使用点操作符>方法一，使用点操作符</h2><ol><li><code>$</code>移动到行尾，<code>a;&lt;Esc></code>完成一行分号的输入；($a;&lt;Esc>)<li>按<code>j</code>移动到下一行，重复步骤1再来一遍，完成第二行；(j$a;&lt;Esc>)<li>重复步骤2，完成第三行。(j$a;&lt;Esc>)</ol><p>好累，还不如鼠标点呢，vim的哲学就是<strong>Don't repeat yourself</strong>，我们要想办法减少一些重复。<p>在vim里，<code>.</code>命令是会<strong>重复上次修改</strong>，我们要<strong>构造可重复的修改</strong>，于是方法为：<ol><li><code>$</code>移动到行尾，<code>a;&lt;Esc></code>完成一行分号的输入；($a;&lt;Esc>)<li>按<code>j</code>移动到下一行，然后<code>$.</code>，完成第二行；(j$.)<li>重复步骤2，完成第三行。(j$.)</ol><p>可以看到<code>.</code>命令非常有用，尽量让可以重复的操作变成可以用<code>.</code>来重复的操作。<p>回过头来，什么样的才是“修改”呢，<code>x</code>会删除光标下的字符；<code>dd</code>删除一行；<code>>G</code>从当前行到文档末尾缩进，都算得上修改，它们都是在普通模式中执行的命令。 插入模式的修改肯定也是修改啦，不过如何记录的呢？就是从进入插入模式的那一刻起(例如输入<code>i</code>)，直到返回普通模式为止(也就是输入&lt;Esc>或&lt;Ctrl + [ >>，Vim会记录每一个按键操作。 复合命令<code>A</code>相当于<code>$a</code>在这里更显得有用了，因为它是可重复的修改：<ol><li><code>A</code>到行尾，<code>;&lt;Esc></code>完成一行分号的输入；(A;&lt;Esc>)<li>按<code>j</code>移动到下一行，然后<code>.</code>，完成第二行；(j.)<li>重复步骤2，完成第三行。(j.)</ol><p>认识<code>.</code>命令的魅力，尽量使操作可重复。<h2 id=方法二-使用列块模式>方法二，使用列块模式</h2><ol><li><code>&lt;Ctrl + v></code>（如果macvim或者gvim则是&lt;Ctrl + q>）进入列块可视模式，<code>jj$</code>先下移动两行然后跳到行尾；<li><code>A;</code>进入插入模式输入分号；<li>&lt;Esc>回到普通模式完成插入。</ol><p>这个方法里用了可视模式里列块选择，&lt;Ctrl + v>是进入列块选择，通过移动建立选取后，使用<code>A</code>和<code>I</code>进入插入模式编辑文本，然后使用&lt;Esc>退出插入模式，同时结束列块模式，这时插入的文本就会扩散到选区选中的行了。<p>有意思的是，可以进入列块选择后复制，然后把它贴出来，试试咯。<p>如果你多输入了一个字符怎么办呢？<code>gv</code>可以重新选择刚才的选区，再调整一下选中你想删除的字符，删除它。<code>gv</code>适用于可视模式哦。<h2 id=方法三-使用ex>方法三，使用EX</h2><ol><li>查看行号，假设是x到y，然后适用命令<code>:x,ynormal A;</code></ol><p>这个方法里用到了命令行模式，在命令行模式中执行的命令又被称为Ex命令。有时使用Ex命令，能比普通模式命令更快地完成同样的工作。<p>其中<code>:</code>是进入命令行模式，<code>x,y</code>就是开始行号x和结束行号y，两者中间加上逗号表示范围;除了行号，其实我们还可以使用正则，比如删除含aotu字符的行到含有labs的行，则可以使用<code>:/aotu/ , /labs/ d</code>，可以用<code>-</code>来表示匹配行的前一行，<code>+</code>表示匹配行的下一行，那么删除匹配行的下一行则应该是<code>:/aotu/+ d</code>。<p><code>normal</code>就是表示执行正常（noramal）模式下的命令，后面的<code>A;</code>就很好理解了，在行尾插入分号。如果是<code>m(ove)</code>移动行，<code>d(elet)</code>删除行，<code>co(py)</code>或<code>t</code>复制行，是不用输入<code>noraml</code>的。如:<code>1,5 co 100</code> 复制1～5行并把它们粘贴到100行以下。<p><code>.</code> 代表当前行；<code>:.,/pattern/ d</code>会删除当前行到包含pattern的行。<p><code>$</code> 代表文件的最后一行；<code>:5, . m $</code>会移动第5行到当前行移动到文件末尾。<p><code>%</code> 代表文件的每一行，等同于<code>1,$</code>。全文替换到时候常常<code>:%s/foo/bar/g</code>。<p>也许有人问，如果这个例子里的行是不联系的，怎么办呢？<p>你可以使用<code>:x,y g/pattern/normal A;</code>或者<code>:x,y v/pattern/normal A;</code> 这里的<code>g</code>就是globally，整个的意思就是x到y行之间匹配pattern的行normal模式执行<code>A;</code>，而<code>v</code>则是来自于conVerse的v，所以整个的意思就是x到y行之间<strong>不匹配</strong>pattern的行normal模式执行<code>A;</code>。<h2 id=方法四-使用宏>方法四，使用宏</h2><ol><li>在第一行上<code>qa</code>，然后<code>A;&lt;Esc></code>,按<code>q</code>；<li><code>j</code>到第二行上<code>@a</code>；<li><code>j</code>到第三行上<code>@@</code>。</ol><p>宏记录就是说vim会记录你所操作的序列，然后你可以在记录完成后的任意时间（normal模式下）一键播放录制的操作序列(宏)。<p>上面的例子，在普通模式中<code>qa</code>中的<code>q</code>就是进入宏模式，<code>a</code>就是这个宏的名字叫做a,宏的名字可以是26个字母中的某一个，大小写都可以，然后可以看到vim状态栏上显示“recording @a”，这时你的所有操作都会被记录。直到你返回会普通模式，然后按<code>q</code>。<p><code>@a</code>就是播放名字为a的宏，而<code>@@</code>就是重复播放刚刚播放过的宏。<p>其实上面为了演示<code>@@</code>而没有让他们可重复起来，可重复应该是在第1步<code>qaA;&lt;Esc>jq</code>，然后在第2步<code>2@qa</code>就直接添加了第2和第3行的分号了。<p>上面只是大概的四种方法，要细分可能还有一些方法。<p>最后话说VS code 的vim插件挺好用的，更新也很快。<p>参考资料：<a href=https://item.jd.com/11445638.html>《vim实用技巧》</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>正则表达式实践篇</title>
      <link>https://aotu.io/notes/2016-12-07/regexp-practice</link>
      <guid>https://aotu.io/notes/2016-12-07/regexp-practice</guid>
      <pubDate>2016-12-07T10:34:01.000Z</pubDate>
      <description>
      
        实践一下，才记得住杂七杂八的真知啊~
      
      </description>
      
      <content:encoded><![CDATA[<h2 id=简单的练习->简单的练习：</h2><h3 id=题目>题目</h3><ol><li>与搜索字符串开始处的 3 个数字匹配。<li>与除 a、b 和 c 以外的任何字符匹配。<li><code>'1234567'.match(/\d{1,3}/g)</code>的结果。<li>不以“th”开头的单词匹配。<li>对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。<li>匹配一个中文字符。</ol><h3 id=答案>答案</h3><ol><li>与搜索字符串开始处的 3 个数字匹配：<code>/^\d{3}/</code>。<li>与除 a、b 和 c 以外的任何字符匹配： <code>/[^abc]/</code>。<li>'1234567'.match(/\d{1,3}/g)，根据贪婪原则，结果是 <code>["123", "456", "7"]</code>。<li>不以“th”开头的单词匹配：<code>/\b(?!th)\w+\b/</code> 。<li>对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： <code>/^(?=.*\d).{4,8}$/</code> 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。<li>匹配一个中文字符：<code>/[\u4e00-\u9fa5]/</code>。</ol><p>当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~ 如果还不了解正则，可以前往<a href=https://aotu.io/notes/2016/11/17/regexp-theory/ >正则表达式理论篇</a> 了解哇~<h2 id=真正的实践来了>真正的实践来了</h2><p>要想在复杂性和完整性之间取得平衡，一个重要因素是要<strong>了解将要搜索的文本</strong>。 好的正则表达式：<ul><li><strong>只匹配期望的文本，排除不期望的文本</strong>；<li><strong>易于控制和理解</strong>；<li><strong>保证效率</strong>。</ul><p>有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。<p>不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~<h2 id=匹配美元>匹配美元</h2><p>正则表达式：<code>/^\$[0-9]+(\.[0-9][0-9])?$/</code>。<p>分为四部分：<ul><li><code>^\$</code> 以美元符号开头。<li><code>[0-9]+</code> 至少包含一个数字。<li><code>(\.[0-9][0-9])?</code> 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。<li><code>$</code> 最后的$表示以数字结尾的。</ul><p>缺点：不能匹配$1,000<h2 id=匹配24小时制的时间-比如-09-59>匹配24小时制的时间，比如 09:59</h2><ul><li><strong>小时部分</strong></ul><p><strong>方法一</strong>：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（<strong>0可选</strong>）；白天10到19点；晚上20到23点。<p>因此有三个多选分支，得到的结果为：<pre class=nust-code><code class="hljs lsl"><span class=hljs-number>0</span>?[<span class=hljs-number>0</span><span class=hljs-number>-9</span>]|<span class=hljs-number>1</span>[<span class=hljs-number>0</span><span class=hljs-number>-9</span>]|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-3</span>]</code></pre><p>还可以优化一下，合并前面的两个多选分支，得到：<pre class=nust-code><code class="hljs lsl">[<span class=hljs-number>01</span>]?[<span class=hljs-number>0</span><span class=hljs-number>-9</span>]|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-3</span>]</code></pre><p><strong>方法二</strong>：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）：<p><img src=//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/24hour.png alt=24hour><p>因此有两个多选分支，结果为：<pre class=nust-code><code class="hljs lsl">[<span class=hljs-number>012</span>]?[<span class=hljs-number>0</span><span class=hljs-number>-3</span>]|[<span class=hljs-number>01</span>]?[<span class=hljs-number>4</span><span class=hljs-number>-9</span>]</code></pre><ul><li>分钟部分</ul><p>分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为:<pre class=nust-code><code class="hljs markdown">[<span class=hljs-string>0-5</span>][<span class=hljs-symbol>0-9</span>]</code></pre><ul><li>最后的结果：</ul><p>小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项； 冒号、分钟数拼起来； 最后加上一个分界<code>\b</code>表示单词的开始或结束，得到最终的结果：<pre class=nust-code><code class="hljs markdown">/\b(?:[<span class=hljs-string>01</span>]?[<span class=hljs-string>0-9</span>]|2[<span class=hljs-string>0-3</span>]):[<span class=hljs-string>0-5</span>][<span class=hljs-symbol>0-9</span>]\b/
// 或者
/\b(?:[<span class=hljs-string>012</span>]?[<span class=hljs-string>0-3</span>]|[<span class=hljs-string>01</span>]?[<span class=hljs-string>4-9</span>]):[<span class=hljs-string>0-5</span>][<span class=hljs-symbol>0-9</span>]\b/</code></pre><ul><li>验证：</ul><pre class=nust-code><code class="hljs markdown">var reg = /\b(?:[<span class=hljs-string>01</span>]?[<span class=hljs-string>0-9</span>]|2[<span class=hljs-string>0-3</span>]):[<span class=hljs-string>0-5</span>][<span class=hljs-symbol>0-9</span>]\b/;
'现在是09:49点'.match(reg);    // ["09:49"]
'现在是009:490点'.match(reg);     // null</code></pre><p>其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者 复杂的字符串搜寻替换。<p>情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个<code>\b</code>需要改成^，第二个<code>\b</code>改成<code>$</code>。<p>情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如'跑步用时19:50',明显的，'19:50'表示19分50秒，而不是表示24小时制的时间19点50分。<h2 id=匹配ip地址>匹配IP地址</h2><p>IP地址的规则：点号分开的四个字段，每个字段在0-255之间。<ul><li>第一步：</ul><p>如果一个字段是一个数或两个数，肯定是在0-255的范围内的； 如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。<p>从上面的陈述中我们就可以得到三个多选分支：<pre class=nust-code><code class="hljs taggerscript"><span class=hljs-symbol>\d</span>|<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>|[01]<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span></code></pre><p>我们稍微合并一下这三个多选分支，得到：<pre class=nust-code><code class="hljs taggerscript">[01]?<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>?</code></pre><ul><li>第二步：</ul><p>我们再来看以2开头的三位数：<p>第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支：<pre class=nust-code><code class="hljs lsl"><span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>]</code></pre><ul><li>第三步：</ul><p>前两步合并起来，得到一个字段0-255的表示方法：<pre class=nust-code><code class="hljs lsl">[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>]</code></pre><ul><li>第四步：</ul><p>四个字段合并起来，IP地址正则如下：<pre class=nust-code><code class="hljs taggerscript">/^(?:[01]?<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>?|2[0-4]<span class=hljs-symbol>\d</span>|25[0-5])<span class=hljs-symbol>\.</span>(?:[01]?<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>?|2[0-4]<span class=hljs-symbol>\d</span>|25[0-5])<span class=hljs-symbol>\.</span>(?:[01]?<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>?|2[0-4]<span class=hljs-symbol>\d</span>|25[0-5])<span class=hljs-symbol>\.</span>(?:[01]?<span class=hljs-symbol>\d</span><span class=hljs-symbol>\d</span>?|2[0-4]<span class=hljs-symbol>\d</span>|25[0-5])$/</code></pre><p>点号要转义一下，^和$需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。<p>一些测试结果：<pre class=nust-code><code class="hljs prolog">var reg = /^(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])$/;

<span class=hljs-string>'123.11.22.33.44'</span>.match(reg); // null
<span class=hljs-string>'52123.3.22.993'</span>.match(reg);  // null
<span class=hljs-string>'123.11.22.33'</span>.match(reg);  // [<span class=hljs-string>"123.11.22.33"</span>]
<span class=hljs-string>'0.0.0.0'</span>.match(reg);     // [<span class=hljs-string>"0.0.0.0"</span>]</code></pre><p>虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上(?!0+.0+.0+.0+$) ：<pre class=nust-code><code class="hljs prolog">var reg = /^(?!<span class=hljs-number>0</span>+<span class=hljs-number>.0</span>+<span class=hljs-number>.0</span>+<span class=hljs-number>.0</span>+$)(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])\.(?:[<span class=hljs-number>01</span>]?\d\d?|<span class=hljs-number>2</span>[<span class=hljs-number>0</span><span class=hljs-number>-4</span>]\d|<span class=hljs-number>25</span>[<span class=hljs-number>0</span><span class=hljs-number>-5</span>])$/;

<span class=hljs-string>'123.11.22.33'</span>.match(reg); // [<span class=hljs-string>"123.11.22.33"</span>]
<span class=hljs-string>'0.0.0.0'</span>.match(reg);  // null</code></pre><h2 id=匹配分隔符之内的文本>匹配分隔符之内的文本</h2><h3 id=常见的匹配要求>常见的匹配要求</h3><ul><li>匹配<code>/*</code>和<code>*/</code>之间的css注释。<li>匹配引文字符串""，且容许其中包含转义的引号\"。<li>匹配一个HTML tag，也就是尖括号之内的文本，例如。</ul><h3 id=匹配思路的步骤>匹配思路的步骤</h3><ol><li>匹配起始分隔符。<li>匹配正文（即结束分隔符之前的所有文本）。<li>匹配结束分隔符。</ol><h3 id=容许引文字符串中出现转义引号>容许引文字符串中出现转义引号</h3><h4 id=大概思路>大概思路</h4><p>描述：起始分隔符和结束分隔符都是<code>"</code>,且正文中容许出现转义之后的引号<code>\"</code>。<p>简单情况分析：<p>举例：匹配类似 <code>I "start \"x3\" end" U</code> 文本的 <code>"start \"x3\" end"</code> 引文字符串，注意<code>\"</code>属于转义引号。<ul><li>起始分隔符和结束分隔符都是<code>"</code>。<li>字符不是引号，肯定是正文。即<code>[^"]</code>表示不是引号的其他任意字符。<li>引号<code>"</code>前面有反斜线\，且被反斜线\转义，则也属于正文。例如<code>start\"</code>引号的前面有<strong>一个</strong>反斜线，那么这个引号也属于正文。即(?&lt;=\)"表示匹配一个引号，它的前面有一个<code>\</code>，注意正则的反斜线也要用<code>\</code>来转义一下,因为\是特殊字符。</ul><p>用非捕获分组<code>(?:)</code>将<code>[^"]|(?&lt;=\\)"</code>括起来，给个量词<code>*</code>，表示匹配正文0次或多次。 因此可以写出正则表达式： <code>/"(?:[^"]|(?&lt;=\\)")*"/</code> 注意：ES7才支持逆序环视<code>(?&lt;=)</code><h4 id=验证1->验证1：</h4><p>验证正则：<code>/"(?:[^"]|(?&lt;=\\)")*"/</code><pre class=nust-code><code class="hljs ada"><span class=hljs-symbol>'I</span> <span class=hljs-string>"start \"</span>x3\<span class=hljs-string>" end"</span> U'.match(/<span class=hljs-string>"(?:[^"</span>]|(?&lt;=\\)<span class=hljs-string>")*"</span>/);
// 结果： [<span class=hljs-string>""</span>start <span class=hljs-string>""</span>]

<span class=hljs-symbol>'I</span> <span class=hljs-string>"start \\"</span>x3\\<span class=hljs-string>" end"</span> U'.match(/<span class=hljs-string>"(?:[^"</span>]|(?&lt;=\\)<span class=hljs-string>")*"</span>/);
// 结果：[<span class=hljs-string>""</span>start \<span class=hljs-string>"x3\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>""</span>]</code></pre><p>为什么第2个才是对的呢？我们看一下返回的input属性就了解了：<p><img src=//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/reg_input.png alt=input属性><h4 id=验证2->验证2：</h4><p>验证正则：<code>/"(?:[^"]|(?&lt;=\\)")*"/</code><pre class=nust-code><code class="hljs sql">'I "<span class=hljs-keyword>start</span> \\<span class=hljs-string>"x3\\\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U'.match(/"</span>(?:[^<span class=hljs-string>"]|(?&lt;=\\)"</span>)*<span class=hljs-string>"/);
// 结果与期望不符合：[""start \"x3\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>""</span>]
// 期望：[<span class=hljs-string>""</span><span class=hljs-keyword>start</span>\<span class=hljs-string>"x3\\"</span>]
// 注意返回的<span class=hljs-keyword>input</span>属性为：<span class=hljs-string>"I "</span><span class=hljs-keyword>start</span> \<span class=hljs-string>"x3\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U"</span></code></pre><p>引号"前面有反斜线\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。 什么情况反斜线\不转义引号呢？ 这个反斜线\本身就是被转义的情况。<p>上面的结果按照预期结果应该返回 <code>[""start\"x3\\"]</code>，但是现在多了<code>end"</code>。 因此验证这个正则表达式不正确。<p>也就是说，正文中可出现转义的字符，因此得出正则<code>\\.</code> ，注意第一个<code>\</code>表示转义第二个<code>\</code>,点表示匹配除换行符 \n 之外的任何单个字符）,例如可以匹配<code>\+</code>或者<code>\\</code>。而且转义的字符已经包含了<code>\"</code>的情况，因此正则<code>(?&lt;=\\)"</code>可以不用写了，且替换成<code>\\.</code>。<p>因此改正后的正则：<code>/"(?:\\.|[^"])*"/</code><p>你可能注意到了，我把[^"]和\.的位置调换一下，后面的验证3会讲到为什么要这么做。<h4 id=验证3->验证3：</h4><p>验证正则：<code>/"(?:\\.|[^"])*"/</code> 和 <code>/"(?:[^"]|\\.)*"/</code><pre class=nust-code><code class="hljs sql">'I "<span class=hljs-keyword>start</span> \\<span class=hljs-string>"x3\\\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U'.match(/"</span>(?:\\.|[^<span class=hljs-string>"])*"</span>/);
// 结果与期望符合：[""<span class=hljs-keyword>start</span> \<span class=hljs-string>"x3\\""]
// input: "</span>I <span class=hljs-string>"start \"x3\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U"</span>

// [^<span class=hljs-string>"]和\\.的位置调换
'I "</span><span class=hljs-keyword>start</span> \\<span class=hljs-string>"x3\\\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U'.match(/"</span>(?:[^<span class=hljs-string>"]|\\.)*"</span>/);
// 结果与期望不符合：[""<span class=hljs-keyword>start</span> \<span class=hljs-string>""</span>]
// 期望：[<span class=hljs-string>""</span><span class=hljs-keyword>start</span>\<span class=hljs-string>"x3\\"</span>]
// <span class=hljs-keyword>input</span>: <span class=hljs-string>"I "</span><span class=hljs-keyword>start</span> \<span class=hljs-string>"x3\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U"</span></code></pre><p><code>[^"]</code>和<code>\\.</code>的位置调换后，结果与期望不符合。那是因为<code>[^"]</code>匹配<code>start \</code>后，遇到紧接着的<code>"</code>不匹配，交给后面的多选分支<code>\\.</code>，也不匹配，又刚好结束分隔符是<code>"</code>,导致匹配成功，结束匹配。<p>因此两个正则之间 正确的正则是 <code>/"(?:\\.|[^"])*"/</code><h4 id=验证4->验证4：</h4><p>验证：<code>/"(?:\\.|[^"])*"/</code><pre class=nust-code><code class="hljs vim"><span class=hljs-string>'I "start \\"x3\\" end U'</span>.<span class=hljs-keyword>match</span>(/<span class=hljs-string>"(?:\\.|[^"</span>])*<span class=hljs-comment>"/);</span>
// 结果与期望不符合：[<span class=hljs-string>""</span>start \<span class=hljs-string>"x3\""</span>]
// 注意end后面少了<span class=hljs-comment>",期望结果是null，不匹配</span>
// inpu<span class=hljs-variable>t:</span> <span class=hljs-string>"I "</span>start \<span class=hljs-string>"x3\" end U"</span></code></pre><p>上面的字符串 <code>"start\"x3\"</code> 其实是没有结束分隔符的，但是还是匹配了。那是因为正则<code>[^"]</code>和<code>\\.</code> 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 <code>x3\</code>后面的引号，匹配成功，结束匹配。<p>回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支<code>|</code>匹配内容出现重叠。<p>你想想，如果符合正文的反斜线，不是以<code>[^"]</code>方式匹配,而是以<code>\\.</code>的方式匹配，那就不会把好好的<code>\"</code>拆开来匹配了。<p>综上所述，一定要让反斜线是以<code>\\.</code>的方式匹配，字符串里的反斜杆不能以<code>[^"]</code>方式匹配。 因此将<code>[^"]</code>改成<code>[^\\"]</code>。这样子就可以确保正确识别正文特殊的<code>\"</code>和结束分隔符<code>"</code>了。<p>注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 <code>\</code> 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 <code>\\</code>。<p>改正的正则：<code>/"(?:\\.|[^\\"])*"/</code><h4 id=验证5>验证5</h4><p>验证：<code>/"(?:\\.|[^\\"])*"/</code><pre class=nust-code><code class="hljs xquery"><span class=hljs-string>'I "start \\"x3\\" end U'</span>.match(/<span class=hljs-string>"(?:\\.|[^\\"</span>])*<span class=hljs-string>"/);
// 结果与期望符合：null
// input: "</span>I <span class=hljs-string>"start \"</span>x3\<span class=hljs-string>" end"</span> U<span class=hljs-string>"


'I "</span><span class=hljs-keyword>start</span> \\<span class=hljs-string>"x3\\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U'.match(/"</span>(?:\\.|[^\\<span class=hljs-string>"])*"</span>/);
// 结果与期望符合：[<span class=hljs-string>""</span><span class=hljs-keyword>start</span> \<span class=hljs-string>"x3\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>""</span>]
// input: <span class=hljs-string>"I "</span><span class=hljs-keyword>start</span> \<span class=hljs-string>"x3\"</span> <span class=hljs-keyword>end</span><span class=hljs-string>" U"</span></code></pre><p>为了优化，我们可以把<code>[^\\"]</code>放在前面，因为普通字符的匹配可能性更大。 注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。<p>优化后的正则：<code>/"(?:[^\\"]|\\.)*"/</code><h3 id=html-tag>HTML Tag</h3><p>经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。<p>描述与要求：匹配类似<code>&lt;input name=123 value=">" ></code>的HTML标签，起始分隔符是<code>&lt;</code>，结束分隔符是<code>></code>，且HTML 标签属性值中可以出现<code>></code>。<p>起始分隔符和结束分隔符都是明确的，我们来分类一下正文。<ul><li>双引号引用文本<li>单引号引用文本<li>除了>和引号之外的任意字符</ul><p>可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号<code>\</code>变成了普通字符。<p>根据三种情况，分别写出三个正则：<ul><li><code>"[^"]*"</code><li><code>'[^']*'</code><li><code>[^'">]</code></ul><p>好了，用多选分支连起来<code>"[^"]*"|'[^']*'|[^'">]</code>，再用非捕获分组(?:)将多选分支括起来，如<code>(?:"[^"]*"|'[^']*'|[^'">])</code>，用<code>*</code>表示匹配任意次，最后前后加上开始结束分隔符，搞定：<p><code>/&lt;(?:"[^"]*"|'[^']*'|[^'">])*>/</code><p>验证：<pre class=nust-code><code class="hljs javascript"><span class=hljs-string>'&lt;input name=123 value=">" >'</span>.match(<span class=hljs-regexp>/&lt;(?:"[^"]*"|'[^']*'|[^'">])*>/</span>)
<span class=hljs-comment>// 结果： ["&lt;input name=123 value=">" >"]</span></code></pre><h2 id=体会->体会：</h2><p>看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。<h2 id=参考>参考</h2><p>《精通正则表达式》 <a href=http://imweb.io/topic/56e804ef1a5f05dc50643106>http://imweb.io/topic/56e804ef1a5f05dc50643106</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>源码赏析 - 1K的Firewatch游戏</title>
      <link>https://aotu.io/notes/2016-12-04/firewatcher-appreciation</link>
      <guid>https://aotu.io/notes/2016-12-04/firewatcher-appreciation</guid>
      <pubDate>2016-12-04T15:33:00.000Z</pubDate>
      <description>
      
        逗我呢！1K的代码能干啥？JQ都不够吧！
      
      </description>
      
      <content:encoded><![CDATA[<h3 id=前言>前言</h3><p>讲真，做前端越久，我们就越容易被思维所束缚。比如，应该没几个人会相信用1K代码能够写出一个游戏，而且还是3d的游戏。<p>在看这段代码之前我们不得不提到一个一年一度的比赛：<a href=http://js1k.com>js1k</a>。每年，主办方会提出一个比赛主题，参赛者们必须围绕这个主题，用1024个字节以内的JS代码做一个参赛作品。比赛的要求有以下几个：<ul><li><p><strong>Create a fancy pancy JavaScript demo</strong> (用JS做出一个华丽的demo)<li><p><strong>Submissions may be up to 1024 bytes</strong> (最多1024字节)<li><p><strong>Externals are strictly forbidden</strong> (禁止引用外部资源)<li><p><strong>Must work current generation browsers</strong> (必须能在现代浏览器中运行)<li><p><strong>Minification and hacks allowed</strong> (允许代码压缩或者hack)</ul><p>另外，作为基础，demo运行的环境中<strong>内置了一部分变量</strong>供调用：<ul><li><p><code>window.a</code> 是一个canvas元素<li><p><code>window.b</code> 是document.body<li><p><code>window.c</code> 是a元素对应的2D/3D上下文<li><p><code>window.d</code> 是document对象</ul><p>是不是还挺贴心？只需要用一个字母就可以调用原本一长串代码才能拿到的对象喔。<p>除了这些，比赛还有一些小规则，可以查看比赛的 <a href=http://js1k.com/2016-elemental/rules>规则页</a> ，里面有详细描述，这里就不再多说。<p>今年比赛的主题是 <strong>Let's get eleMental!</strong>，我们今天要看的 <a href=http://js1k.com/2016-elemental/demo/2512>Firewatch</a> 就是其中第三位的作品（第一名作品是 <a href=http://js1k.com/2016-elemental/demo/2552>Romanesco 2.0</a> 3D分形展示，有强烈的不明觉厉感，建议前往围观；第二名 <a href=http://js1k.com/2016-elemental/demo/2497>Voxeling</a> 是一个3D像素Demo）。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-thetop2.jpg alt=前二甲作品><h3 id=demo介绍>Demo介绍</h3><p>游戏通过键盘<strong>上下左右+空格键</strong>操作。在开始游戏后，面前会有一颗烟花炸开。紧接着烟花下的树开始着火。玩家的任务就是按下空格，用水枪将火扑灭。在一定时间后，树上的火还会点燃周围的树。如果不慎走神，很有可能就救不回这片森林了喔。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-gameui.jpg alt=游戏画面><h3 id=源码解析>源码解析</h3><p>粗略地讲，这份源码总共就分为两个部分：<ol><li><strong>创建对象</strong><li>绑定用户交互，进行<strong>事件循环</strong></ol><h4 id=创建对象>创建对象</h4><p>下面是创建对象部分的代码：<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// add trees</span>
<span class=hljs-keyword>for</span> (entities = [playerA = <span class=hljs-number>256</span>]; s = playerX = playerZ = playerA--;)
    <span class=hljs-keyword>for</span> (
        <span class=hljs-comment>// create trunk</span>
        entities.push({
          <span class=hljs-attr>c</span>: [i = <span class=hljs-number>12</span>, <span class=hljs-number>60</span>, <span class=hljs-number>30</span>],
          <span class=hljs-attr>x</span>: X = <span class=hljs-built_in>Math</span>.sqrt(playerA) * <span class=hljs-number>12</span> * <span class=hljs-built_in>Math</span>.cos(playerA) + <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>12</span>,
          <span class=hljs-attr>h</span>: <span class=hljs-number>1</span>,
          <span class=hljs-attr>y</span>: Y = <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>3</span> - <span class=hljs-number>1</span>,
          <span class=hljs-attr>z</span>: Z = <span class=hljs-built_in>Math</span>.sqrt(playerA) * <span class=hljs-number>12</span> * <span class=hljs-built_in>Math</span>.sin(playerA) + <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>12</span>,
          <span class=hljs-attr>s</span>: <span class=hljs-number>2</span>,
          <span class=hljs-attr>S</span>: Y * <span class=hljs-number>2</span> + <span class=hljs-number>16</span>
        });
        i--;
        <span class=hljs-comment>// create leaf</span>
        entities.push({
          <span class=hljs-attr>c</span>: [<span class=hljs-number>150</span>, <span class=hljs-number>60</span>, i * <span class=hljs-number>2</span>],
          <span class=hljs-attr>x</span>: X + f * <span class=hljs-built_in>Math</span>.cos(e = <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>7</span>),
          <span class=hljs-attr>z</span>: Z + f * <span class=hljs-built_in>Math</span>.sin(e),
          <span class=hljs-attr>h</span>: <span class=hljs-number>860</span>,
          <span class=hljs-attr>y</span>: Y - i / <span class=hljs-number>2</span> + <span class=hljs-number>10</span>,
          <span class=hljs-attr>s</span>: <span class=hljs-number>8</span>
        })
    )
      <span class=hljs-comment>// create fallen fruit</span>
      f = <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>7</span>,
      i % <span class=hljs-number>2</span> || entities.push({
        <span class=hljs-attr>c</span>: [<span class=hljs-number>50</span>, <span class=hljs-number>60</span>, i * <span class=hljs-number>2</span>],
        <span class=hljs-attr>x</span>: X + f * <span class=hljs-built_in>Math</span>.cos(e = <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>7</span>),
        <span class=hljs-attr>z</span>: Z + f * <span class=hljs-built_in>Math</span>.sin(e),
        <span class=hljs-attr>h</span>: <span class=hljs-number>860</span>,
        <span class=hljs-attr>y</span>: <span class=hljs-number>-8</span>,
        <span class=hljs-attr>s</span>: <span class=hljs-number>1</span>
      });
<span class=hljs-comment>// burn a leaf (doubles as object for active keys)</span>
entities[<span class=hljs-number>30</span>].p = burn = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
  <span class=hljs-comment>// update fire</span>
  e.h--;
  e.c = [<span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>60</span>, <span class=hljs-number>100</span>, <span class=hljs-number>0</span>],
  e.s = <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>5</span> + <span class=hljs-number>6</span>,

  <span class=hljs-comment>// create smoke / fireworks</span>
  s % <span class=hljs-number>16</span> || entities.push({
    <span class=hljs-attr>c</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, e.w ? <span class=hljs-number>-30</span> : <span class=hljs-number>10</span>],
    <span class=hljs-attr>x</span>: e.x + <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>6</span>,
    <span class=hljs-attr>y</span>: e.y,
    <span class=hljs-attr>z</span>: e.z,
    <span class=hljs-attr>h</span>: <span class=hljs-number>90</span>,
    <span class=hljs-attr>v</span>: <span class=hljs-number>60</span>,
    <span class=hljs-attr>p</span>:
      s ? <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
        e.h--;
        e.y += <span class=hljs-number>.5</span>
      } : <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
        e.h--;
        e.c = [<span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>60</span>, <span class=hljs-number>100</span>, <span class=hljs-number>0</span>],
        e.h &lt; <span class=hljs-number>12</span> ? e.s += <span class=hljs-number>3</span> : e.y += <span class=hljs-number>3</span>
      },
    <span class=hljs-attr>s</span>: <span class=hljs-number>4</span>
  });

  <span class=hljs-comment>// spread fire</span>
  entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
    <span class=hljs-keyword>return</span>(s % <span class=hljs-number>300</span> || f.s == <span class=hljs-number>8</span> && <span class=hljs-built_in>Math</span>.abs(e.x - f.x) + <span class=hljs-built_in>Math</span>.abs(e.z - f.z) &lt; <span class=hljs-number>40</span> && <span class=hljs-built_in>Math</span>.random() * <span class=hljs-number>50</span> &lt; <span class=hljs-number>1</span> && (f.p = burn))
  });

  e.w = <span class=hljs-number>0</span>
};</code></pre><p>为了减少代码占用的空间，作者大量使用了单字母的变量名与属性名，比如<code>entities.c</code>，<code>entities.x</code>等等，代码可读性非常差。<p>浏览一遍，我们是根本看不出上面这些变量是什么含义了。<p>但是，我们能够确定的是，这段代码初始化了<code>playerA</code>，<code>playerX</code>，<code>playerZ</code>变量，然后把所有的对象设定好属性后都存入了<code>entities</code>数组中，包括树干，树底下的水果，还有树干等等。没办法，只能先跳过这部分了。<h4 id=用户交互>用户交互</h4><p>这是代码中主管用户交互的代码：<pre class=nust-code><code class="hljs javascript">onkeydown = onkeyup = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
  burn[e.keyCode - <span class=hljs-number>32</span>] = e.type[<span class=hljs-number>5</span>]
};</code></pre><p>蛤？就这么短？<p>...<p><strong>真是这么短。</strong><p>上面这段代码，看着更像是定义了onkeydown跟onkeyup俩函数，后面理应还有类似于addEventListener之类的语句将这个函数绑定给某个元素某个事件的代码。因为身为前端，我们早已习惯绑定事件的那几种套路：<pre class=nust-code><code class="hljs javascript">DomEl.addEventListener(eventname, callback); <span class=hljs-comment>// webkit</span>
DomEl.attachEvent(eventname, callback); <span class=hljs-comment>// IE</span>
$.bind(eventname, callback); <span class=hljs-comment>// jQ</span>
<span class=hljs-comment>// ...</span></code></pre><p>可是任凭老司机怎么 Ctrl+f 搜索代码，也并没有找到所谓的绑定事件的语句。<p>事实上，作者在定义这两个函数的时候，并没有使用var关键字。意味着，这后面定义的变量，是直接挂在window下的。那么凭空定义的这两个函数，就分别会变成 <code>window.onkeydown</code> 和 <code>window.onkeyup</code> 。没错，这就是我们<strong>极度不推崇的绑定回调的方式</strong>了。<p>回调函数的内容，是在用户按下按键的时候将burn中下标为 <code>keyCode - 32</code> 的属性设定为 <code>keydown</code> 或者 <code>keyup</code> 的第六个字母，也就是 <code>w</code> 或者 <code>undefined</code> 。这个做法十分精妙，下面举例说明。<p>假设我们按下了空格键（keyCode=32），执行 <code>onkeydown</code> 函数，<code>burn[0] = 'w'</code>；而放手的时候，则执行 <code>onkeyup</code> 函数， <code>burn[0] = undefined</code> 。这样一来，在事件循环里面只需要判断<code>burn[0]</code>是<code>true</code>还是<code>false</code>，就可以知道空格键按下了没有。同理，<code>burn[5]</code>，<code>burn[6]</code>，<code>burn[7]</code>，<code>burn[8]</code>分别代表了左，上，右，下键的状态。<p>可是，印象中burn是个函数呀，<code>entities[30].p = burn = function (e, f) {...}</code>，怎么就用来表示按键状态了呢？目的只能有一个，省下一个声明变量的语句。<p><strong>为了省下多几个字符，程序员真是什么事都做得出来啊...</strong><h4 id=事件循环>事件循环</h4><p>终于到了事件循环部分了。这部分代码占了源码大概一半的篇幅。折叠后，代码结构大概是这样的：<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-eventloop.png alt=事件循环><p>结构大概清晰了：首先是玩家的移动，接着是水枪的处理，紧接着是背景天空森林地板的渲染。<p>每个事件循环一开始，先是移动玩家。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// move player</span>
playerA += (!!burn[<span class=hljs-number>7</span>] - !!burn[<span class=hljs-number>5</span>]) / <span class=hljs-number>20</span>,
playerX += (e = !!burn[<span class=hljs-number>6</span>] - !!burn[<span class=hljs-number>8</span>]) * <span class=hljs-built_in>Math</span>.sin(playerA),
playerZ += e * <span class=hljs-built_in>Math</span>.cos(playerA),</code></pre><p>理解了用户交互部分的内容，这里就很好理解了。burn[5]与burn[7]分管左右两键，那么<code>playerA</code>很明显就是用户的朝向。而burn[6]与burn[8]分管前后，在经过换算后，我们很快也就能知道<code>playerX</code>与<code>playerZ</code>分别是玩家在<strong>x-z平面上</strong>的坐标。别忘了这游戏可是3D的，所以并不用x-y坐标系。<p>接下来是水枪的代码：<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// discharge water</span>
burn[<span class=hljs-number>0</span>] && entities.push({
  <span class=hljs-attr>c</span>: [<span class=hljs-number>200</span>, <span class=hljs-number>60</span>, <span class=hljs-number>-5</span> * <span class=hljs-built_in>Math</span>.sin(s)],
  <span class=hljs-attr>x</span>: playerX + <span class=hljs-number>12</span> * <span class=hljs-built_in>Math</span>.cos(playerA),
  <span class=hljs-attr>z</span>: playerZ - <span class=hljs-number>12</span> * <span class=hljs-built_in>Math</span>.sin(playerA),
  <span class=hljs-attr>e</span>: playerA - <span class=hljs-number>.5</span>,
  <span class=hljs-attr>s</span>: <span class=hljs-number>2</span>,
  <span class=hljs-attr>h</span>: <span class=hljs-number>20</span>,
  <span class=hljs-attr>p</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
    e.h--;
    e.x += <span class=hljs-number>2</span> * <span class=hljs-built_in>Math</span>.sin(e.e),
    e.z += <span class=hljs-number>2</span> * <span class=hljs-built_in>Math</span>.cos(e.e),
    e.y = <span class=hljs-number>5</span> - (e.h / <span class=hljs-number>2</span> - <span class=hljs-number>5</span>) * (e.h / <span class=hljs-number>2</span> - <span class=hljs-number>5</span>) / <span class=hljs-number>2</span>,
    entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
      f.p == burn && <span class=hljs-built_in>Math</span>.abs(e.x - f.x) + <span class=hljs-built_in>Math</span>.abs(e.z - f.z) &lt; e.s / <span class=hljs-number>2</span> + f.s / <span class=hljs-number>2</span> && (
        f.h -= f.w = <span class=hljs-number>9</span>
      )
    });
  }
});</code></pre><p>只要空格被按下，就会有新的对象被插入<code>entities</code>数组中。不过既然是水枪的代码，我们很容易可以想到，这里插进去的对象正是水流。<p>水流浇到火上是可以灭火的，所以下面这段带有一堆abs的代码，十有八九是用来<strong>判断水流跟火焰的位置关系</strong>的。<pre class=nust-code><code class="hljs javascript">entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
  f.p == burn && <span class=hljs-built_in>Math</span>.abs(e.x - f.x) + <span class=hljs-built_in>Math</span>.abs(e.z - f.z) &lt; e.s / <span class=hljs-number>2</span> + f.s / <span class=hljs-number>2</span> && (
    f.h -= f.w = <span class=hljs-number>9</span>
  )
});</code></pre><p>后面可以证明我们的猜测并没有错。另外，这段代码最后的&&符号后面的代码，就是灭火的处理函数了。<p>遍历数组，我们一般是用<code>forEach</code>，而作者在这个例子中全都是用<code>some</code>来做的。我猜作者并没有别的用意，纯粹是因为长度的原因。所以我觉得这里使用<code>map</code>应该更好。<p>接下来是一些零散的处理。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// prepare canvas</span>
c.translate(<span class=hljs-number>90</span>, (a.height += <span class=hljs-number>0</span>) / <span class=hljs-number>2</span> - <span class=hljs-number>120</span> | <span class=hljs-number>0</span>);

<span class=hljs-comment>// update entities</span>
entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
  f.p && f.p(f)
});</code></pre><p>首先是平移了画布，其次是遍历对象数组，执行对象的p函数。这样一来就很清晰了。对象的<strong>属性p，就是在每个事件循环中处理对象的函数</strong>。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// draw sky</span>
<span class=hljs-keyword>for</span> (i = <span class=hljs-number>30</span>; i--;)
  c.fillStyle = <span class=hljs-string>'hsla('</span> + [<span class=hljs-number>160</span>, <span class=hljs-number>60</span> + <span class=hljs-string>'%'</span>, <span class=hljs-number>50</span> + i + <span class=hljs-string>'%'</span>, <span class=hljs-number>1</span>],
  c.fillRect(<span class=hljs-number>0</span>, i * <span class=hljs-number>4</span>, <span class=hljs-number>320</span>, <span class=hljs-number>4</span>);</code></pre><p>接下来，作者巧妙地用<strong>循环 + hsla</strong>渲染了一个带渐变色的天空。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// remove entities no longer needed</span>
entities = entities.filter(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
  <span class=hljs-keyword>return</span>(e.h > <span class=hljs-number>0</span>)
});</code></pre><p>这段代码过滤掉了对象数组中h属性不大于0的对象。<p>回想一下，我们前面看到的每种对象的p函数，都带着h--，而p函数在每个事件循环都会执行。那么这个h属性表示的就是对象的寿命了。这个事件循环的间隔是33ms，也就是30h相当于1秒。<pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// draw background forest</span>
<span class=hljs-keyword>for</span> (i = <span class=hljs-number>30</span>; i--;)
  c.fillStyle = <span class=hljs-string>'hsla('</span> + [<span class=hljs-number>160</span>, <span class=hljs-number>60</span> + <span class=hljs-string>'%'</span>, <span class=hljs-number>10</span> + i + <span class=hljs-string>'%'</span>, <span class=hljs-number>1</span>],
  c.fillRect(<span class=hljs-number>0</span>, <span class=hljs-number>220</span> - i * <span class=hljs-number>4</span>, <span class=hljs-number>320</span>, <span class=hljs-number>4</span>);

<span class=hljs-comment>// sort entities by distance from the screen</span>
entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
  f.Z = (f.x - playerX) * <span class=hljs-built_in>Math</span>.sin(playerA) + (f.z - playerZ) * <span class=hljs-built_in>Math</span>.cos(playerA)
});
entities.sort(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e, f</span>) </span>{
  <span class=hljs-keyword>return</span>(f.Z - e.Z)
});

<span class=hljs-comment>// draw ground</span>
<span class=hljs-keyword>for</span> (i = <span class=hljs-number>30</span>; i--;)
  c.fillStyle = <span class=hljs-string>'hsla('</span> + [<span class=hljs-number>10</span> + <span class=hljs-number>60</span>, <span class=hljs-number>60</span> + <span class=hljs-string>'%'</span>, <span class=hljs-number>50</span> + i + <span class=hljs-string>'%'</span>, <span class=hljs-number>1</span>],
  c.fillRect(<span class=hljs-number>0</span>, <span class=hljs-number>236</span> - i * <span class=hljs-number>4</span>, <span class=hljs-number>320</span>, <span class=hljs-number>4</span>);</code></pre><p>接下来的这部分，前面的画背景与后面的画地板还是跟前面一样的套路，分别使用循环来绘制带渐变色的森林与地板。可是中间这段是什么鬼？<p>根据注释说明，这个部分是将Z属性设置为对象到屏幕的距离，随后做了一次从近到远排序。<p>至于对象到屏幕的距离如何计算，这里直接画图说明，就不再赘述。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-calcdist.jpg alt=计算距离><pre class=nust-code><code class="hljs javascript">  <span class=hljs-comment>// draw entities</span>
  entities.some(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>f</span>) </span>{
    !f.v && f.Z > <span class=hljs-number>160</span> || f.Z &lt; <span class=hljs-number>8</span> ||
    <span class=hljs-built_in>Math</span>.abs(e = (f.x - playerX) * <span class=hljs-built_in>Math</span>.cos(playerA) * <span class=hljs-number>160</span> / f.Z - (f.z - playerZ) * <span class=hljs-built_in>Math</span>.sin(playerA) * <span class=hljs-number>160</span> / f.Z) &lt; <span class=hljs-number>160</span> && (
      c.fillStyle = <span class=hljs-string>'hsla('</span> + [f.c[<span class=hljs-number>0</span>], f.c[<span class=hljs-number>1</span>] + <span class=hljs-string>'%'</span>, f.Z / <span class=hljs-number>6</span> - f.c[<span class=hljs-number>2</span>] + <span class=hljs-number>46</span> + <span class=hljs-string>'%'</span>, f.S ? <span class=hljs-number>1</span> : <span class=hljs-number>.8</span>],
      c.fillRect(
        <span class=hljs-number>160</span> + e - f.s * <span class=hljs-number>160</span> / f.Z / <span class=hljs-number>2</span>,
        <span class=hljs-number>120</span> - f.y * <span class=hljs-number>160</span> / f.Z - (f.S || f.s) * <span class=hljs-number>160</span> / f.Z / <span class=hljs-number>2</span>,
        f.s * <span class=hljs-number>160</span> / f.Z,
        (f.S || f.s) * <span class=hljs-number>160</span> / f.Z
      )
    )
  });</code></pre><p>接下来的这段代码就是这个游戏的灵魂所在了。<p>这是一个遍历entities数组的操作。以 <code>||</code> 符号分割，这个操作可以分为三个部分：<ol><li><code>!f.v && f.Z > 160</code><li><code>f.Z &lt; 8</code><li><code>Math.abs(...) &lt; 160 && (...)</code></ol><p>语句1跟2只要有一个成立，语句3就不会被执行。语句1跟2也很好理解，主要是判断对象跟屏幕之间的距离是不是处在(8, 160)的区间内，如果不是就直接跳过该对象。<p>这里有一个例外情况，在距离大于160的情况下，如果对象带有v属性则还是可以继续后面的判断的。纵观整个代码，带有v属性的只有前面提到的烟雾以及烟花。这就说明烟雾与烟花就算是在160距离开外，依然是可以看到的，事实上也的确如此。<p>语句3被 <code>&&</code> 符号分割为了两部分：<ol><li><code>Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160</code><li><code>(c.fillStyle='...',c.fillRect(...))</code></ol><p>语句1中的比较，转换为代数式，经过简单的代数变换后，可以变为：<p><code>dx*cos(α) - dz*sin(α) &lt; f.Z</code><p>结合刚刚的图，这个语句意义就是指，线段a需要小于f.Z。而从图上我们可以知道，线段a就是对象投影在屏幕上后与玩家的距离。这样一来，<strong>视角90°</strong>以外的对象就不会被渲染了。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-example.jpg alt=参考图><p>语句2就是渲染对象的语句了。看到这里的<code>fillStyle</code>函数我们才明白，前面所定义的<code>f.c</code>属性，其实就是定义了对象颜色的hsl值。另外，从<code>fillRect</code>函数的传参情况来看，也很容易看出<code>f.y</code>指的就是对象的y坐标，<code>f.s</code>表示对象的宽高，而<code>f.S</code>则是在绘制树干的时候作为对象的高度来使用。<h4 id=再回首>再回首</h4><p>现在我们对这段代码有大概的理解了，是时候回头看一看了。<p>首先是创建对象的部分，此处开了两重循环，种下了256课树，每棵树分别有一根树干，12个对象组成的叶子，另外地上有6个果实。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-tree.png alt=树><p>接下来，第30棵树被恶意纵了火（将<code>f.p</code>设置为<code>burn</code>函数），第一棵着火的树还会发出一个烟花作为信号。而由于每一帧最后都有<code>s--</code>语句，这个<code>s</code>被作为一个计数器，让着火的树每16帧发出一个烟圈。<p><img src=//misc.aotu.io/Littly/2016-12-04-firewatcher-appreciation-smoke.png alt=烟雾><p>过后，就是熟悉的与用户交互的环节了。这部分已经十分清晰，就不再赘述。<h3 id=写在最后>写在最后</h3><p>这段代码虽然短，却是麻雀虽小五脏俱全。实现了游戏的基本功能不说，有一些小细节也是让我大吃一惊。比如树着火时冒出的烟，在普通情况下是深灰色的，而在被水枪浇到的时候，会变成浅灰色；又比如寿命的设定，使树叶在着火之后一段时间会被烧完。<p>在编程思想上，作者也是很有见地。使用entities数组存储所有对象的信息，给每种对象一个变换函数，这本身就有粒子的思想在其中。此外，<code>setInterval</code>的使用，则是再正常不过的事件循环机制的实现。<p>编程手法就不用多说了。比如各种利用<code>some</code>函数代替<code>forEach</code>来省字数，又或者是利用<code>burn[e.keyCode - 32] = e.type[5]</code>来判断按键的状态......作者是老司机，这一点是没跑了。<p>这段代码构思巧妙，思路行云流水...类似的溢美之词说再多也没用。更关键的是，我们<strong>干前端这一行的，绝对不只是jQ，选择器，或者node小工具</strong>。偶尔看一看别人的代码，还是能够学到很多意想不到的知识的。<h3 id=参考资料>参考资料</h3><ul><li>js1k官网 <a href=http://js1k.com>http://js1k.com</a><li>js1k规则页 <a href=http://js1k.com/2016-elemental/rules>http://js1k.com/2016-elemental/rules</a><li>Romanesco 2.0 <a href=http://js1k.com/2016-elemental/demo/2552>http://js1k.com/2016-elemental/demo/2552</a><li>Voxeling <a href=http://js1k.com/2016-elemental/demo/2497>http://js1k.com/2016-elemental/demo/2497</a><li>Firewatch <a href=http://js1k.com/2016-elemental/demo/2512>http://js1k.com/2016-elemental/demo/2512</a><li>Firewatch 源码 <a href=http://js1k.com/2016-elemental/details/2512>http://js1k.com/2016-elemental/details/2512</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>项目心得 -- 京东云改版</title>
      <link>https://aotu.io/notes/2016-12-03/jcloud</link>
      <guid>https://aotu.io/notes/2016-12-03/jcloud</guid>
      <pubDate>2016-12-02T16:26:14.000Z</pubDate>
      <description>
      
        实际工作中好多地方都可以以小见大，总结积累，沉淀工作方法。
      
      </description>
      
      <content:encoded><![CDATA[<p>2016年即将过去，回顾总结项目的时候，发现日常工作中一些值得我们思考的地方，这次选了印象比较深刻的京东云项目，希望本文能对读者有所帮助，文多图少，一目百行的客官请轻虐。<h2 id=项目变数>项目变数</h2><p>由于项目的紧迫性，项目进度基本处于多线并行追赶的状态，产品、视觉、前端三个线边输出边交接，产品和视觉会把重要的框架性的页面先输出给到前端，这样一来，前端得到的交互文档、视觉稿基本是阶段性的，并没有完整的项目逻辑和项目页面可以参考来评估项目的构建方案，项目的公用模块、公用组件、组件管理方式等全局性的内容难以确定，类似这些项目中各种不能确定的信息，我称之为『变数』。『变数』会给构建页面过程带来很多不可预测的问题，这些问题可能会令一部分工作推倒或翻工。<h3 id=主动获取项目信息>主动获取项目信息</h3><p>面对这种时间线短、各线并行、存在『变数』的项目，主动获取项目信息尤其重要，个人觉得比较重要的有以下几个：项目整体信息结构、整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期、前端交接 Deadline、项目各线对接负责人。<p>这次项目属于改版类，从旧版大概了解到站点频道划分、频道之间逻辑关系、业务模块的引用情况等信息，这次改版产品的逻辑变化不大，主要是视觉的优化。虽然前期视觉给到我们的视觉稿只有站点首页，频道的首页和频道的内页都还在并行进行中，但从旧版站点逻辑和产品交互侧得到的信息以及已出的视觉稿可以确定站点哪些部分可以作为公用组件去制作，也可以大致确定项目的资源目录分布。<p>对于旧站点常见的组件而在已出视觉稿未体现到的，如侧导航弹浮层，找到产品和交互进一步了解后，得知会在频道首页和内页会用到，亦可以确认作为公用组件制作，并可以提前为这些组件制作评估工作量并选择最佳的实现方案。<p>整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期以及前端交接 Deadline，这些信息都是项目时间维度上的信息，这类信息的确认，可以让我们更准确评估工作量（在时间线内是否可以完成所有工作），从而在项目紧急性方面做好更合理的人力投入。<h3 id=潜在-变数->潜在『变数』</h3><p>我们接到新项目，一般都会考虑以上的因素，主动去获取项目的信息，这些信息都是显而易见的，但有些信息略显隐蔽。<p>拿到设计稿的时候，发现视觉设计师只提供了一份 1280 分辨率的宽屏版，国内分辨率使用占比名列前 5 的 1024 分辨率并没有兼容，带着疑问找到视觉确认，得知首页会有 1280 分辨率和 1024 分辨率两个版本，适配 1024 分辨率版本会迟一点给到。<p>对于这种看似不是问题的问题而前期又可以确认的问题，我是一定要去确认的！这种问题在前期看上去并不会成为项目推进的阻力，但是说不定会在项目后期爆发，对项目造成吨暴击伤害。<p>记得刚入行的时候就亲身经历过联调阶段调整分辨率兼容问题，产品说『我的笔记本电脑首页出现横向滚动条了』，然后去排查了一下，发现产品用了 1024 分辨率，而视觉给到前端的视觉稿只兼容到 1280 分辨率，当时缺少实际项目经验，就默默按照 1280 去做了。当产品找到视觉，视觉回答『立项的时候文档没有写到分辨率兼容情况呀，所以当时只做了宽屏1280了』，最后产品『还是兼容一下吧，做一个窄版适配吧』，再然后视觉和前端就只能『......』。<p>这种问题两条线人员很容易懵B『O嘴』，而且最终还是需要重新调整适配 1024 分辨率，视觉和前端两条线都需要额外的工时，而这些工时并不在前期规划内，所以最有可能会令到视觉或前端或两者都加班，如果加班在可控的时间内完成的话还算是亡羊补牢，但如果加班后还是影响到项目进展造成项目 delay 的话，那就不是影响视觉和前端两条工作线工作效率这么简单了，这是一种潜在的『变数』，应该如何避免这种『变数』的出现，非常值得我们去思考。<p>如果前端可以从立项就开始参与和产品、交互、视觉、开发各线大前期沟通的话，每个岗位的同事都可以就各自的专业去衡量评估项目，是不是能更早地去发现一些潜在的『变数』呢？而去执行实现的话是否需要在流程上做出改动？如果因为团队的合作模式不能实现，作为前端，我们是不是应该更主动去找到各线的同事进行沟通？<p>当然，这仅仅是针对此情况而去考虑的东西，其实我想提出的是，<strong>面对『项目变数』我们需要做的就是尽可能及时掌握更多关于项目的任何信息去深入了解项目，对项目未来发展作出预见性的判断从而掌握主动权，而不是静静地等待进入前端流程。项目可见度越高，准备越充分，项目主动性越强，只有 100% 的项目信息确认，才能 Kill the 『潜变数』Tens of Thousands Times 。</strong><h2 id=方案推动>方案推动</h2><p>首页的设计稿包含了很多单色图标，图标复用性很强，同一个图标出现在不同的模块，而且大小又不一样，又需要多态并且兼容 Retina 高清屏。<p>站在前端角度考虑，PC平台的解决方案，第一时间肯定会想到 iconfont 图标。iconfont 图标已不是什么新鲜的技术，不少同事都在不少项目中都有应用到，可是大家在遇到同一问题使用相同技术的时候，处理方法亦有不同。有的同事可能会自己制作 iconfont 图标；有的同事可能会让设计师提供图标 SVG 文件，利用线上的工具自动生成 iconfont 图标；有的同事可能会把 iconfont 的生成工具介绍给视觉设计师，让视觉设计师生成 iconfont 图标。<p>站在视觉角度考虑，当然想图标在所以设备都可以高清呈现。不同的设计师经验不一样，有些可能会提供 SVG 文件，有些可能会提供一套1X，2X图，有些甚至会把 3X 图也一起给到前端<p>当项目同时由多人维护的时候，就可能会出现同一个项目同样的的技术方案出现不一样的协作方式，一旦人员交叉交接的时候，就有意思了。从协作效率上来看是存在一定问题的，因此很有必要让前端和视觉设计师统一一套解决 iconfont 图标的方案。<p>如何实行？ 个人觉得，最重要的是让大家对问题达成共识，也就是：<strong>解决这个问题于工作有何收益？</strong><p>首先需要站在视觉方角度让他们知道<strong>问题痛点</strong>，再<strong>提出解决方案</strong>并<strong>希望得到他们的协作</strong>，下面我以对话的形式将当时我和视觉沟通的对话内容简单叙述一下（前端：FE，视觉：VD）：<blockquote><p><em>FE</em>：啊宏，这些单色图标数量挺多的呀，复用率又高，很多还有双态，同一个图标还有不一样的尺寸，全部做成图片的话数量很多哇，即使全部合并成 sprite 图，图片的 K 数也会很大呢。最要命的是图标后续不知道还会有多少种色态会扩展，首页还要求适配高清屏呢，这工作量不是一般的小呀。<p><em>VD</em>：确实啊，高清屏适配每一个图标我都要给一个 2X 图你，10个图标我就得给你 20 个，如果有双态的话，就得给你40个,这次首页纯色图标就有50个。。。<p><em>FE</em>：嗯，会出人命的，主要这些图标都是纯色图标，都做成图片不值得，用 iconfont 图标可以解决，全矢量，还可以用样式控制尺寸大小和颜色，高清屏、尺寸、配色都不是问题呀，省力省时间呢！<p><em>VD</em>：666，那这个 iconfont 图标要怎么个搞法啊？我需要做些什么呢？<p><em>FE</em>：只需要把图标做成 SVG 文件提供给我就 OK 了呀，网上有 SVG 转 iconfont 图标的服务哈<p><em>VD</em>：没问题呀，如果能解决刚才说的问题<p><em>FE</em>：是啊是啊！主要是这样处理的话可以节省大家的时间，效率成倍提高的啊，不过生成 iconfont 图标后有些图标会在 windows 显示出问题，有问题的图标需要你用 Ai 再处理一下哟，没问题吧？<p><em>VD</em>：没问题啊，总比切一堆图好吧，哈哈~~<p><em>FE</em>：好的，那么我们约定好，以后这一类纯色图标我们都统一用 iconfont 图标处理，由视觉这边提供图标的 SVG 文件，然后前端负责生成 iconfont 图标，我会在组内推一下这个处理 iconfont 的流程，麻烦你在视觉组内也推一下这个方法哈，都统一这么处理，看OK么？<p><em>VD</em>：好的没问题~~ 6666 ~~~<p><em>FE</em>：6666~~</blockquote><p>项目最后一共投入了5个人力完成后期的构建，成功统一使用了这个 iconfont 图片处理流程，避免了一大波 icon 的蹂躏：<p><img src=//misc.aotu.io/mihanX/jcloud/img_icon.png alt=""><p><strong>痛点定位和效率收益</strong>是这次协作成功推动的关键点，<strong>个人觉得要成功推动一个方案实施，『痛点』及『收益点』必定是核心点</strong>。以上仅仅是一个简单的方案推动例子，真正操作起来也不会太困难，但关键是我们需要从每次的工作收益中沉淀点<a href=http://hkdic.my-helper.com/%E8%A6%81%E5%90%83%E5%A5%BD%E8%A5%BF/ >『好西』</a>出来就很好了。<p>好了，以上就是我在京东云改版项目中对工作流程以及上下线协作中感受比较深的一些思考和总结。其实问题都很常见，也有很多更好的解决方案，但是要将这些问题和解决方案存在的价值转化出来，还是需要我们做完每一次的项目后认真去总结沉淀，最后，做好业务无非几个字，<strong>想得周全，助得快乐，踩得深入，跳得出来</strong>。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>css3 animation 属性众妙</title>
      <link>https://aotu.io/notes/2016-11-28/css3-animation-properties</link>
      <guid>https://aotu.io/notes/2016-11-28/css3-animation-properties</guid>
      <pubDate>2016-11-28T10:00:00.000Z</pubDate>
      <description>
      
        css3 animation 属性使用场景及技巧
      
      </description>
      
      <content:encoded><![CDATA[<p>本文不会详细介绍每个 css3 animation 属性（需要了解的同学可先移步 <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/animation>MDN</a>），而是结合实际的开发经验，介绍 css3 animation 属性的一些使用场景及技巧。<h3 id=1-animation-delay>1. animation-delay</h3><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay>MDN</a> 中的介绍：<blockquote><p>animation-delay CSS 属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。</blockquote><p>该属性值默认为 0s，可为正值，也可为负值。<h4 id=动画时间轴>动画时间轴</h4><p>由于 css3 动画没有时间轴，<code>animation-delay</code> 最常见的是用于将动画与其他动画的执行时机错开，将动画落到不同的时间点，形成动画时间轴。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.ani--first</span> {
    <span class=hljs-attribute>animation-name</span>: aniFirst;
    <span class=hljs-attribute>animation-duration</span>: <span class=hljs-number>2s</span>;
    <span class=hljs-attribute>animation-delay</span>: <span class=hljs-number>0s</span>;
}
<span class=hljs-selector-class>.ani--second</span> {
    <span class=hljs-attribute>animation-name</span>: aniSecond;
    <span class=hljs-attribute>animation-duration</span>: <span class=hljs-number>1s</span>;
    <span class=hljs-attribute>animation-delay</span>: <span class=hljs-number>2s</span>; <span class=hljs-comment>/* aniSecond 延迟 2s 执行*/</span>
}</code></pre><p>形成的时间轴如下图所示： <img src=//misc.aotu.io/Yettyzyt/2016-11-28-css3-animation-properties/animation-delay-timeline.png alt=动画时间轴><h4 id=轮播>轮播</h4><p>css3 animation 亦可实现一些 js 的效果，例如利用 <code>animation-delay</code> 可以实现一个简单的轮播。以下是一个三屏轮播的例子。<pre class=nust-code><code class="hljs scss"><span class=hljs-selector-class>.slider__item</span> {
    <span class=hljs-attribute>animation</span>: ani <span class=hljs-number>6s</span> infinite linear both;
    @<span class=hljs-keyword>for</span> <span class=hljs-variable>$i</span> from 1 to 4 {
      &:nth-child(#{<span class=hljs-variable>$i</span>}) {
        <span class=hljs-attribute>animation-delay</span>: (-<span class=hljs-number>1</span>+<span class=hljs-variable>$i</span>)*<span class=hljs-number>2s</span>;
      }
    }
}
@keyframes ani {
  0%, 33<span class=hljs-selector-class>.33</span>% {<span class=hljs-attribute>opacity</span>: <span class=hljs-number>1</span>; <span class=hljs-attribute>visibility</span>: visible;}
  33<span class=hljs-selector-class>.34</span>%, 100% {<span class=hljs-attribute>opacity</span>: <span class=hljs-number>0</span>; <span class=hljs-attribute>visibility</span>: hidden;}
}</code></pre><p><p data-height=368 data-theme-id=0 data-slug-hash=KNvRxZ data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=KNvRxZ class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/KNvRxZ/ >KNvRxZ</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><h4 id=序列动画>序列动画</h4><p>多个元素使用相同的动画效果时，将动画执行时机依次错开，可形成整齐有序的序列动画效果。<pre class=nust-code><code class="hljs scss">@<span class=hljs-keyword>for</span> <span class=hljs-variable>$i</span> from 1 to 6 {
  <span class=hljs-selector-class>.list__item</span>:nth-child(#{<span class=hljs-variable>$i</span>}) {
    <span class=hljs-attribute>animation-delay</span>: (-<span class=hljs-number>1</span>+<span class=hljs-variable>$i</span>)*<span class=hljs-number>0.1s</span>; <span class=hljs-comment>/*计算每个元素的 animation-delay */</span>
  }
}</code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=BQWZWz data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=listAni class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/BQWZWz/ >listAni</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><p>以笔者开发的<a href=http://jdc.jd.com/h5/jd-campus-2017/international/index.html>京东2017海外招聘</a>项目为例，第二屏的菜单和第三屏的时间轴的进退场动画都运用了序列动画。下图展示第三屏时间轴的进场效果，有兴趣的同学亦可扫码观看完整案例。<p><img src=//misc.aotu.io/Yettyzyt/2016-11-28-css3-animation-properties/animation-delay-campus.gif alt=京东2017海外招聘><h4 id=无限循环的序列动画>无限循环的序列动画</h4><p><code>animation-delay</code> 可为负值。<strong>负值会让动画从它的动画序列中某位置立即开始。</strong> 巧用这个负值，可以解决实际开发中的一些问题。<p>如若上述的序列动画要进行无限循环，单纯将 <code>animation-iteration-count</code> 设置为 <code>infinite</code>，动画开始时会有延迟。此时，将 <code>animation-delay</code> 设置为负值，提前动画开始执行的时机，当用户看到动画时，动画便已经处于进行中的状态。<pre class=nust-code><code class="hljs scss">@<span class=hljs-keyword>for</span> <span class=hljs-variable>$i</span> from 1 to 6 {
  <span class=hljs-selector-class>.list__item</span>:nth-child(#{<span class=hljs-variable>$i</span>}) {
    <span class=hljs-attribute>animation-delay</span>: -<span class=hljs-variable>$i</span>*<span class=hljs-number>0.1s</span>; <span class=hljs-comment>/* animation-delay 为负值*/</span>
  }
}</code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=VmpMEE data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=listAniInfinite class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/VmpMEE/ >listAniInfinite</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><h4 id=调试动画>调试动画</h4><p>将 <code>animation-play-state</code> 设置为 <code>paused</code>，<code>animation-delay</code> 设置成不同的负值，可以查看动画在不同帧时的状态，便于进行动画调试。<pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-class>.list__item</span> {
    <span class=hljs-attribute>animation</span>: listAni <span class=hljs-number>0.5s</span> linear both alternate infinite;
    <span class=hljs-attribute>animation-play-state</span>: paused;
}
@for <span class=hljs-variable>$i</span> from <span class=hljs-number>1</span> to <span class=hljs-number>6</span> {
    <span class=hljs-selector-class>.list--first</span> <span class=hljs-selector-class>.list__item</span>:nth-child(#{<span class=hljs-variable>$i</span>}) {
        <span class=hljs-attribute>animation-delay</span>: -<span class=hljs-variable>$i</span>*<span class=hljs-number>0.1s</span>;
    }
}
@for <span class=hljs-variable>$i</span> from <span class=hljs-number>1</span> to <span class=hljs-number>6</span> {
    <span class=hljs-selector-class>.list--second</span> <span class=hljs-selector-class>.list__item</span>:nth-child(#{<span class=hljs-variable>$i</span>}) {
        <span class=hljs-attribute>animation-delay</span>: (-<span class=hljs-number>2</span>-<span class=hljs-variable>$i</span>)*<span class=hljs-number>0.1s</span>;
    }
}
@for <span class=hljs-variable>$i</span> from <span class=hljs-number>1</span> to <span class=hljs-number>6</span> {
    <span class=hljs-selector-class>.list--third</span> <span class=hljs-selector-class>.list__item</span>:nth-child(#{<span class=hljs-variable>$i</span>}) {
        <span class=hljs-attribute>animation-delay</span>: (-<span class=hljs-number>4</span>-<span class=hljs-variable>$i</span>)*<span class=hljs-number>0.1s</span>;
    }
}</code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=ObprrZ data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=listAniPaused class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/ObprrZ/ >listAniPaused</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><h3 id=2-animation-fill-mode>2. animation-fill-mode</h3><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode>MDN</a> 中的介绍：<blockquote><p>animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。</blockquote><p><code>animation-fill-mode</code> 应该算是 <code>animation</code> 属性里比较难上手的一个，但它的作用却很大。<h4 id=保持结束状态>保持结束状态</h4><p>“动画结束后，突然跳回第一帧！” 很多刚接触 css3 动画的同学，都是在这个场景下，接触了 <code>animation-fill-mode</code> 属性。将 <code>animation-fill-mode</code> 设置为 <code>forwards</code>，动画执行结束后保持最后一帧的样式。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.ani-area__item--forwards</span> {
    <span class=hljs-attribute>animation</span>: ani <span class=hljs-number>1s</span> ease;
    <span class=hljs-attribute>animation-fill-mode</span>: forwards;
}</code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=MbmvQL data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=MbmvQL class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/MbmvQL/ >MbmvQL</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><h4 id=开始前状态>开始前状态</h4><p>开发动画时，我们都是先根据视觉稿做好构建，再来给元素加动画的。如上文所述，可通过 <code>animation-delay</code> 来延迟的动画的执行。而在执行前，元素往往需要先隐藏（<code>translate</code> 定位到视窗外 / <code>opacity</code> 设置为 0 / <code>scale</code> 设置为 0 等）。若将隐藏元素的样式直接应用到元素上，一来不利于构建，二来对于不支持动画的浏览器来说，只会呈现一片空白。此时，<code>animation-fill-mode</code> 的 <code>backwards</code> 属性值便派上用场。<p>对于 <code>backwards</code> 的解释，笔者见过不少文章的说法都有不妥之处，认为 <code>backwards</code> 与 <code>forwards</code> 相反，表示动画执行结束后保持第一帧的样式。实则不然，我们看下 <a href=http://www.w3school.com.cn/cssref/pr_animation-fill-mode.asp>w3c</a> 的解释：<blockquote><p>backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。</blockquote><p>换句话说，<code>backwards</code> 作用的是 <code>animation-delay</code> 的时间段，应用第一个关键帧的样式。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.ani-area__item--backwards</span> {
    <span class=hljs-attribute>animation</span>: ani <span class=hljs-number>1s</span> <span class=hljs-number>1s</span> ease;
    <span class=hljs-attribute>animation-fill-mode</span>: backwards;
}</code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=YpVxpw data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=YpVxpw class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/YpVxpw/ >YpVxpw</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><p>当然，动画的第一帧和最后一帧的计算还受 <code>animation-direction</code> 和 <code>animation-iteration-count</code> 的影响，<a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode>MDN</a> 中有详细解释：<blockquote><p>forwards<table><thead><tr><th>animation-direction<th>animation-iteration-count<th>last keyframe encountered<tbody><tr><td>normal<td>even or odd<td>100% or to<tr><td>reverse<td>even or odd<td>0% or from<tr><td>alternate<td>even<td>0% or from<tr><td>alternate<td>odd<td>100% or to<tr><td>alternate-reverse<td>even<td>100% or to<tr><td>alternate-reverse<td>odd<td>0% or from</table><p>backwards<table><thead><tr><th>animation-direction<th>first relevant keyframe<tbody><tr><td>normal or alternate<td>0% or from<tr><td>reverse or alternate-reverse<td>100% or to</table></blockquote><h3 id=3-animation-direction>3. animation-direction</h3><p>既然上表中涉及了 <code>animation-direction</code> 属性，那我们就顺着来研究一下它。 <a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction>MDN</a> 中的介绍：<blockquote><p>animation-direction CSS 属性指示动画是否反向播放。</blockquote><h4 id=进-退场动画复用>进/退场动画复用</h4><p>动画元素有进场动画，往往也会需要退场动画。比较常见的做法，退场时使用与进场动画反向的动画。<code>animation-direction</code> 的 <code>reverse</code> 属性值可简单实现反向动画。<p>先看<a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction>MDN</a> 中的介绍：<blockquote><p>reverse：反向运行动画，每周期结束动画由尾到头运行。</blockquote><pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-class>.on</span> {
  <span class=hljs-selector-class>.ani--translate</span> {
      <span class=hljs-attribute>animation</span>: aniTranslate <span class=hljs-number>1s</span> ease forwards;
  }
}
<span class=hljs-selector-class>.off</span> {
  <span class=hljs-selector-class>.ani--translate</span> {
      <span class=hljs-attribute>animation</span>: aniTranslate <span class=hljs-number>1s</span> ease forwards reverse;
  }
}
@keyframes aniTranslate {
  <span class=hljs-number>0%</span> { <span class=hljs-attribute>transform</span>: translateY(<span class=hljs-number>300px</span>) }
  <span class=hljs-number>100%</span> { <span class=hljs-attribute>transform</span>: translateY(<span class=hljs-number>0</span>) }
}</code></pre><pre class=nust-code><code class="hljs shell"><span class=hljs-meta>$</span><span class=bash>wrap.removeClass(<span class=hljs-string>'on'</span>);</span>
<span class=hljs-meta>$</span><span class=bash>wrap.innerWidth(<span class=hljs-variable>$wrap</span>.innerWidth); /* 使用 reflow 重新触发一下 animation */</span>
<span class=hljs-meta>$</span><span class=bash>wrap.addClass(<span class=hljs-string>'off'</span>);</span></code></pre><p><p data-height=265 data-theme-id=0 data-slug-hash=YpQqKZ data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=YpQqKZ class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/YpQqKZ/ >YpQqKZ</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><p>当然，上述例子为了演示方便，只是简单做了只有两帧的动画，这种效果用 <code>transition</code> 同样可以实现。<h3 id=4-animation-play-state>4. animation-play-state</h3><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state>MDN</a> 中的介绍：<blockquote><p>animation-play-state CSS 属性定义一个动画是否运行或者暂停。</blockquote><h4 id=翻页动画控制>翻页动画控制</h4><p>在做翻页 h5 时，需要对动画的播放进行控制。只有当用户进入当前屏时，动画才开始播放。通常我们会给当前屏加上一个 <code>acitve</code> 类，用来给元素添加动画：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.active</span> <span class=hljs-selector-class>.ele</span> {
    <span class=hljs-attribute>animation</span>: ani <span class=hljs-number>1s</span> ease;
}</code></pre><p>或者如上文“进/退场动画复用”中的例子，分别用 <code>on</code> 和 <code>off</code> 控制进/退场动画。这都是常见的思路。 如果是不需要重复触发的动画，用 <code>animation-play-state</code> 同样可以实现动画的控制。动画属性直接添加到元素上， <code>animation-play-state</code> 默认设置为 <code>paused</code>，当进入当前屏时，将 <code>animation-play-state</code> 设置为 <code>running</code> 即可。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.ani</span> { 
    <span class=hljs-attribute>animation</span>: ani1 <span class=hljs-number>1s</span> ease;
    <span class=hljs-attribute>animation-play-state</span>: paused; <span class=hljs-comment>/* animation-play-state 默认设置为 paused */</span>
}
<span class=hljs-selector-class>.active</span> <span class=hljs-selector-class>.ani</span> {
    <span class=hljs-attribute>animation-play-state</span>: running; <span class=hljs-comment>/* 进入当前屏，animation-play-state 设置为 running */</span>
}</code></pre><p><p data-height=572 data-theme-id=0 data-slug-hash=vymWwE data-default-tab=css,result data-user=Yetty data-embed-version=2 data-pen-title=vymWwE class=codepen>See the Pen <a href=http://codepen.io/Yetty/pen/vymWwE/ >vymWwE</a> by Yetty (<a href=http://codepen.io/Yetty>@Yetty</a>) on <a href=http://codepen.io>CodePen</a>.</p><script async src=https://production-assets.codepen.io/assets/embed/ei.js></script><h4 id=轮播的交互>轮播的交互</h4><p>在前文介绍 <code>animation-delay</code> 时，提到了一个轮播的例子，当用户 <code>hover</code> 时，轮播动画应该暂停，用 <code>animation-play-state</code> 属性便可轻松实现交互：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.slider</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-class>.slider__item</span>{ 
    <span class=hljs-attribute>animation-play-state</span>: paused;
}</code></pre><h3 id=5-animation-timing-function>5. animation-timing-function</h3><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function>MDN</a> 中的介绍：<blockquote><p>CSS animation-timing-function 属性定义 CSS 动画在每一动画周期中执行的节奏。</blockquote><p>关于 <code>animation-timing-function</code>，有一个特别需要注意的点，<a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function>MDN</a> 中有强调：<blockquote><p>对于关键帧动画来说，timing function 作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束。</blockquote><p>也就是说，<code>animation-timing-function</code> 是作用于 <code>@keyframes</code> 中设置的两个关键帧之间的，这一点在该属性值为 <code>steps()</code> 时可明显感知。<h4 id=逐帧动画>逐帧动画</h4><p><code>animation-timing-function</code> 最让人感到惊（beng）艳（kui）的莫过于 <code>steps()</code> 属性值。利用 <code>steps()</code>，可以轻松实现逐帧动画（又称“精灵动画”），从而告别不可控的 gif 时代。 关于逐帧动画，笔者之前在<a href=//aotu.io/ >凹凸实验室</a>平台已经发布过相关文章介绍，此处不再赘述，有兴趣的同学可前往围观：<a href=//aotu.io/notes/2016/05/17/css3-animation-frame/ >《CSS3逐帧动画》</a>。<p>参考文章：<ul><li><a href=https://css-tricks.com/debugging-css-keyframe-animations/ >Debugging CSS Keyframe Animations - SARAH DRASNER</a><li><a href=http://isux.tencent.com/css-animation-skills.html>多屏复杂动画CSS技巧三则 - zhangxinxu</a><li><a href=https://isux.tencent.com/html5-animation-performance-analysis.html>打造H5动感影集的爱恨情仇(动画性能篇) －TQ</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>FIGlet初识</title>
      <link>https://aotu.io/notes/2016-11-23/figlet</link>
      <guid>https://aotu.io/notes/2016-11-23/figlet</guid>
      <pubDate>2016-11-22T17:33:00.000Z</pubDate>
      <description>
      
        FIGlet这么专业的术语，在前端界中问十个人，至少有十一个没听过，那你呢？
      
      </description>
      
      <content:encoded><![CDATA[<p>FIGlet这个词诂计对于很多前端工程师来说可能比较陌生，但在计算机领域中常常见到。早在十几年前就已经开始有许多利用文字与线条组成的图形，当时甚至用 ASCII 来表示颜色，然而到了今天也被广范使用。<h2 id=figlet是什么->FIGlet是什么？</h2><p>「FIGlet」是基于<code>ASCII</code>字符组成的字符画。它的名字由来，其实有几个固定的名称，几种比较主要的称呼分别是：「ASCII TEXT」、「ASCII TEXT Banner」、「ASCII Art」、「ASCII Decorator」和「FIGlet」。然而「FIGlet」这个词应该是最标准的用法，因为维基百科上有相关介绍 ( <a href=https://en.wikipedia.org/wiki/FIGlet>https://en.wikipedia.org/wiki/FIGlet</a> )。「FIGlet」原作者是Glenn Chappell、Ian Chai，源于 Frank、Ian 和 Glen当初在写邮件签名的时候加上去的一些字体艺术。 ( 參考：<a href=http://www.figlet.org/figlet_history.html>http://www.figlet.org/figlet_history.html</a>)<p><img src=https://misc.aotu.io/youing/20161122/1.png alt=FAQ><h3 id=figlet的历史>FIGlet的历史</h3><p>「FIGlet」在1991年春天，仅仅是一个只有170行用C语言编写的小程序，当时叫做<code>newban</code>，作者认为它是一个可以长期使用于互联网中的程序，然后用带“新”的英文不太合适，于是后来称之为<code>FIGlet 1.0</code>。当时的版本只有一个字体并且仅仅包含了一些小写字母。<p>于是1993年的时候，决定重写「FIGlet」，花了7个月的时间整理了13个字体以及相关文档，因此<code>FIGlet 2.0</code>正式版也正式诞生。<p>当时「FIGlet」像暴风一样席卷互联网，每周都有新的字体涌现，不少人自愿把figlet这个功能接入到<code>non-Unix</code>当中，当然还有一些bug的报告。因为这些从而使得「FIGlet」更加国际化，所以在<code>FIGlet 2.1</code>中加入了支持非ASCII字符，还有从右到左打印等功能。直至今天最新版本是2.2.5，可以从<a href=http://www.figlet.org/ >官方网站</a>找到相关代码的<a href=ftp://ftp.figlet.org/pub/figlet/program/unix/figlet-2.2.5.tar.gz>下载地址</a>。<h2 id=figlet如何制作>FIGlet如何制作</h2><p>接下来就是介绍生成这样的字符图形的几种方式：<h3 id=在线生成>在线生成</h3><p>除了字体，其实也有不少图片转为ASCII的工具，有兴趣的可以参考一下 <a href=https://en.wikipedia.org/wiki/ASCII_art>ASCII Art</a>，或者是这个网站：<a href=http://picascii.com/ >http://picascii.com/</a>，都是通过程序帮我们实现。可以看一下<a href=http://picascii.com/ >picascii.com</a>这个网站转出来的效果<p><img src=https://misc.aotu.io/youing/20161122/2.png alt=效果><h3 id=利用编辑器>利用编辑器</h3><p>目前一些比较流行的编辑器如<code>Sublime</code>、<code>VSCODE</code>、<code>Atom</code>等都有相关的插件帮助我们生成字符图形，例如在VSCODE中在插件管理，搜索<code>“VSC Figlet”</code>并安装<p><img src=https://misc.aotu.io/youing/20161122/4.jpg alt=效果><p>然后在MAC下通过快捷键<code>command+shift+p</code>调出令命面板,输入查找<code>“VSC Figlet”</code><p><img src=https://misc.aotu.io/youing/20161122/5.jpg alt="VSC Figlet"><p>然后输入根据提示，输入您想要转换的字符<p><img src=https://misc.aotu.io/youing/20161122/6.jpg alt=您想要转换的字符><p>选择一种字体效果<p><img src=https://misc.aotu.io/youing/20161122/7.jpg alt=选择一种字体效果><p>最终效果如下<p><img src=https://misc.aotu.io/youing/20161122/8.jpg alt=效果><h3 id=使用node-js>使用Node.js</h3><p>作为一名高逼格的前端工程师，想必看一下<strong>Node.js</strong>里面有没有相关的模块，于是去<a href=https://www.npmjs.com/ ><strong>npm</strong></a>上搜了一把，结果更新频率比较高的，有这个名叫<strong>figlet</strong>的npm包<p><img src=https://misc.aotu.io/youing/20161122/13.jpg alt=figlet><h4 id=安装>安装</h4><pre class=nust-code><code class="hljs cmake">npm <span class=hljs-keyword>install</span> figlet</code></pre><p>简单示例<pre class=nust-code><code class="hljs lisp"> var figlet = require('figlet')<span class=hljs-comment>;</span>

figlet('JDC O2 Team', function(<span class=hljs-name>err</span>, data) {
    if (<span class=hljs-name>err</span>) {
        console.log('Something went wrong...')<span class=hljs-comment>;</span>
        console.dir(<span class=hljs-name>err</span>)<span class=hljs-comment>;</span>
        return<span class=hljs-comment>;</span>
    }
    console.log(<span class=hljs-name>data</span>)
})<span class=hljs-comment>;</span></code></pre><p>输出<pre class=nust-code><code class="hljs gherkin">      _ ____   ____    ___ ____    _____                    
     |<span class=hljs-string> </span>|<span class=hljs-string>  _ \ / ___</span>|<span class=hljs-string>  / _ \___ \  </span>|<span class=hljs-string>_   _</span>|<span class=hljs-string>__  __ _ _ __ ___  
  _  </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string>     </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string>__) </span>|<span class=hljs-string>   </span>|<span class=hljs-string> </span>|<span class=hljs-string>/ _ \/ _` </span>|<span class=hljs-string> '_ ` _ \ 
 </span>|<span class=hljs-string> </span>|<span class=hljs-string>_</span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string>_</span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string>___  </span>|<span class=hljs-string> </span>|<span class=hljs-string>_</span>|<span class=hljs-string> / __/    </span>|<span class=hljs-string> </span>|<span class=hljs-string>  __/ (_</span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|<span class=hljs-string> </span>|
  \___/|<span class=hljs-string>____/ \____</span>|<span class=hljs-string>  \___/_____</span>|<span class=hljs-string>   </span>|<span class=hljs-string>_</span>|<span class=hljs-string>\___</span>|<span class=hljs-string>\__,_</span>|<span class=hljs-string>_</span>|<span class=hljs-string> </span>|<span class=hljs-string>_</span>|<span class=hljs-string> </span>|<span class=hljs-string>_</span>|</code></pre><p>也可以直接安装命令行<pre class=nust-code><code class="hljs avrasm">npm install -g figlet-<span class=hljs-keyword>cli</span></code></pre><p>这里输入<a href=https://aotu.io><strong>凹凸实验室</strong></a>出品－前端自动化流程构建工具<a href=https://athena.aotu.io/ >「Athena」</a>的名称看看<pre class=nust-code><code class="hljs nginx"><span class=hljs-attribute>figlet</span> <span class=hljs-string>"Athena"</span></code></pre><p>输出效果<pre class=nust-code><code class="hljs maxima">     <span class=hljs-symbol>_</span>   <span class=hljs-symbol>_</span>   <span class=hljs-symbol>_</span>                      
    / \ | |<span class=hljs-symbol>_</span>| |<span class=hljs-symbol>__</span>   ___ <span class=hljs-symbol>_</span> <span class=hljs-symbol>__</span>   <span class=hljs-symbol>__</span> <span class=hljs-symbol>_</span> 
   / <span class=hljs-symbol>_</span> \| <span class=hljs-symbol>__</span>| '<span class=hljs-symbol>_</span> \ / <span class=hljs-symbol>_</span> \ '<span class=hljs-symbol>_</span> \ / <span class=hljs-symbol>_</span>` |
  / ___ \ |<span class=hljs-symbol>_</span>| | | |  <span class=hljs-symbol>__</span>/ | | | (<span class=hljs-symbol>_</span>| |
 /<span class=hljs-symbol>_</span>/   \<span class=hljs-symbol>_</span>\<span class=hljs-symbol>__</span>|<span class=hljs-symbol>_</span>| |<span class=hljs-symbol>_</span>|\___|<span class=hljs-symbol>_</span>| |<span class=hljs-symbol>_</span>|\<span class=hljs-symbol>__</span>,<span class=hljs-symbol>_</span>|</code></pre><p>效果是不是跟官方配图很像。<p><img src=https://misc.aotu.io/youing/20161122/15.jpg alt=Athena><h4 id=在浏览器中使用>在浏览器中使用</h4><p>如果想直接做一个类似的在线转换工具，可以参考一下网页版本<a href=http://patorjk.com/software/taag/ >http://patorjk.com/software/taag/</a>，里面主要用到<code>figlet.js</code>。<pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"text/javascript"</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"//cdnjs.cloudflare.com/ajax/libs/fetch/1.0.0/fetch.min.js"</span>></span><span class="undefined"></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"text/javascript"</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"figlet.js"</span>></span><span class="undefined"></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>

    figlet(inputText, <span class=hljs-string>'Standard'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>err, text</span>) </span>{
        <span class=hljs-keyword>if</span> (err) {
            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'something went wrong...'</span>);
            <span class=hljs-built_in>console</span>.dir(err);
            <span class=hljs-keyword>return</span>;
        }
        <span class=hljs-built_in>console</span>.log(text);
    });

</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><h2 id=figlet的应用>FIGlet的应用</h2><ul><li>chrome开发者工具里面的控制台输出。<li>Sublime Text等具有右侧快速定位视图功能的编辑器，如果你代码很长的时候，可以使用figlet来做个说明隔开，那找起代码来更加一目了然了。<li>当你写封纯文字邮件的时候，可以加入figlet字符让邮件更加生动一些。<li>在终端中的打印字符图形，如登录服务器后的字符提示。</ul><h2 id=总结>总结</h2><p>看到这里，这绝对不是一篇软文，相信你至少能从文章中学习到一点小知识。<h2 id=参考>参考</h2><ul><li><a href=https://en.wikipedia.org/wiki/FIGlet>https://en.wikipedia.org/wiki/FIGlet</a><li><a href=https://www.npmjs.com/package/figlet>https://www.npmjs.com/package/figlet</a><li><a href=http://patorjk.com/software/taag>http://patorjk.com/software/taag</a><li><a href=https://en.wikipedia.org/wiki/ASCII_art>https://en.wikipedia.org/wiki/ASCII_art</a><li><a href=http://www.figlet.org/ >http://www.figlet.org/</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>三看 SVG Web 动效</title>
      <link>https://aotu.io/notes/2016-11-23/SVG_Web_Animation</link>
      <guid>https://aotu.io/notes/2016-11-23/SVG_Web_Animation</guid>
      <pubDate>2016-11-22T17:33:00.000Z</pubDate>
      <description>
      
        800字作文再也不用担心凑不够字数啦！
      
      </description>
      
      <content:encoded><![CDATA[<p>CSS3 动效玩腻了吗？没关系的，我们还有 SVG。<p><a href=http://www.welikesmall.com/ >Welikesmall</a> 是一个互联网品牌宣传代理，这是我见过的最喜欢使用 SVG 做动效的网页设计团队。事实上，越来越多的网页动效达人选择在 SVG 的疆土上开辟动效的土壤，即便 SMIL 寿终正寝，事实上这反而将 SVG 动效推向了一个新的世界：CSS3 Animation + SVG。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/1479630242685.png alt="Alt text"><p>（<a href=https://css-tricks.com/smil-is-dead-long-live-smil-a-guide-to-alternatives-to-smil-features/ >SMIL is dead! Long live SMIL! A Guide to Alternatives to SMIL Features</a>）<p>还记得我在久远的<a href=https://aotu.io/notes/2015/11/23/css3-animation-to-movie-part_1/ >《以电影之眼看 CSS3 动画》</a>中说道：“CSS3 动画简直拥有了整个世界！”那么带上 SVG 的 CSS3 动画则已突破天际向着宇宙级的可能性前进（感觉给自己挖了一个无比巨大的坑，网页动画界可不敢再出新技术了[扶额]）。<p>CSS 与 SVG 的打通无疑将 html 代码的可读性又推上一个台阶，我们可以通过 CSS 控制 SVG 图形的尺寸、填色、边框色、过渡、移动变幻等相当实用的各种属性，除此之外，将图形分解的动画在这种条件下也变得相当简单。<h2 id=索引>索引</h2><p>本文将讲到三个动效例子：<ul><li><a href=http://codepen.io/lyxuncle/pen/wozzrV><strong>箭头</strong>描线动效</a><li><a href=http://codepen.io/lyxuncle/pen/qqbopp><strong>播放按钮</strong>滤镜动效</a><li><a href=http://codepen.io/lyxuncle/pen/bBejZZ><strong>虚线</strong>描线动效</a></ul><p>动效来源：<a href=http://www.welikesmall.com/work/adobe/ >WLS-Adobe</a><p>即将聊到的 SVG 标签：<ul><li><code>&lt;path></code><li><code>&lt;g></code><li><code>&lt;symbol></code><li><code>&lt;defs></code><li><code>&lt;use></code><li><code>&lt;clipPath></code><li><code>&lt;mask></code></ul><p>以及属性：<ul><li><code>viewBox</code><li><code>preserveAspectRatio</code><li><code>fill</code><li><code>stroke</code><li><code>stroke-dasharray</code><li><code>stroke-dashoffset</code><li><code>d</code><li><code>clip-path</code><li><code>mask</code></ul><h2 id=从一个简单的例子说起>从一个简单的例子说起</h2><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/arrow_hover_svg.gif alt="arrow hover"><p>要做出这样的效果，第一步是将图形画出来。徒手敲代码这种事还是留给图形工具来做，但是，为了更好地控制与制作动效，咱至少要做到读懂 SVG 代码。<p>SVG 的基本格式是使用 <code>&lt;svg></code> 标签对代码进行包裹，可直接将代码段插入 html 中，也可以保存成 svg 文件之后使用 <code>img</code>、<code>object</code> 进行引用。<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"100%"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"100%"</span>></span>   
  <span class=hljs-comment>&lt;!-- SVG markup here. --></span>    
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p>由于交互动效所需，这里仅介绍直接使用 <code>svg</code> 标签的情况。<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"90"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"13"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 89.4 12.4"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"6.2"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"59.6"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"6.2"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"54.7"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"0.7"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"60.5"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"6.5"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"54.7"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"11.7"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"60.5"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"5.8"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p>这是箭头的代码段，使用了最简单的线条进行绘制。可以看到其中包裹了许多坐标样的属性值。有坐标就意味着有坐标系。<p>SVG 的坐标系存在三个概念：视窗、视窗坐标系、用户坐标系。视窗坐标系与用户坐标系属于 SVG 的两种坐标系统，默认情况下这两个坐标系的点是一一对应的。与 web 其他坐标系相同，原点位于视窗的左上角，x 轴水平向右，y 轴垂直向下。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/Canvas_default_grid.png alt="Canvas Default Grid"><p>（图片来源：<a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Positions>MDN-SVG Tutorial-Positions</a>）<p>SVG 的位置、大小与文档流中的块级元素相同，都可由 CSS 进行控制。<p>视窗即为在页面中 SVG 设定的尺寸可见部分，默认情况下 SVG 超出隐藏。<p>SVG 能通过 viewBox 属性就完成图形的位移与缩放。<blockquote><p>viewBox属性值的格式为(x0,y0,u_width,u_height)，每个值之间用逗号或者空格隔开，它们共同确定了视窗显示的区域：视窗左上角坐标设为(x0,y0)、视窗的宽设为 u_width，高为 u_height；这个变换对整个视窗都起作用。</blockquote><p>下图展示了当 viewBox 尺寸与 SVG 尺寸相同、放大一倍、缩小一倍时的表现：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/viewBox1-1.gif alt="viewBox 1:1"><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/viewBox1-2.gif alt="viewBox 1:2"><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/viewBox2-1.gif alt="viewBox 2:1"><p>一句话总结，就是用户坐标系需要以某种方式铺满整个视窗。默认的方式是以最短边为准铺满，也就是类似 background-size 中的 cover 值。通过 <code>preserveAspectRatio</code> 属性你可以控制用户坐标系的展开方式与位置，完美满足你的各种需求。<blockquote><p>preserveAspectRatio 是一個以對齊為主，然後再選擇要自動填滿還是咖掉的屬性。——引用来源<a href=http://www.oxxostudio.tw/articles/201409/svg-23-viewpoint-viewBox.html>《SVG 研究之路 (23) - 理解 viewport 與 viewbox》</a></blockquote><p>属性的语法如下：<code>preserveAspectRatio="[defer] &lt;align> [&lt;meetOrSlice>]"</code><p>注意3个参数之间需要使用空格隔开。<blockquote><p><strong><code>defer</code></strong>：可选参数，只对 <code>image</code> 元素有效，如果 <code>image</code> 元素中 <code>preserveAspectRatio</code> 属性的值以 <code>defer</code> 开头，则意味着 <code>image</code> 元素使用引用图片的缩放比例，如果被引用的图片没有缩放比例，则忽略 <code>defer</code>。所有其他的元素都忽略这个字符串。<p><strong>meetOrSlice</strong>：可选参数，可以去下列值：<ul><li><code>meet</code> - 默认值，统一缩放图形，让图形全部显示在 viewport 中。<li><code>slice</code> - 统一缩放图形，让图形充满 viewport，超出的部分被剪裁掉。</ul><p>——引用来源<a href=http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html>《突袭 HTML5 之 SVG 2D 入门6 - 坐标与变换》</a></blockquote><p><strong>align</strong>：必选参数。由两个名词组成。<blockquote><p>這兩個名詞分別代表 viewbox 與 viewport 的 x 方向對齊模式，以及 y 方向的對齊模式，換句話說，可以想成：「水平置中 + 垂直靠上對齊」的這種感覺，不過在這個 align 的表現手法倒是很抽象，可以用下方的表格看出端倪：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/preserveAspectRatio-align.png alt="preserveAspectRatio align"><p>也因此我們要做一個「水平置中 + 垂直靠上對齊」的 viewbox 設定，就必須寫成：xMidYMin，做一個「水平靠右對齊 + 垂直靠下對齊」的 viewbox 設定，就必須寫成：xMaxYMax，不過這裡有個細節請特別注意，「Y」是大寫呀！真是不知道為什麼會這樣設計，我想或許跟命名規則有關吧！<p>——引用来源<a href=http://www.oxxostudio.tw/articles/201409/svg-23-viewpoint-viewBox.html>《SVG 研究之路 (23) - 理解 viewport 與 viewbox》</a></blockquote><p>下图诠释了各种填充的效果：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/PreserveAspectRatio.png alt=PreserveAspectRatio><p>（图片来源：<a href=https://www.w3.org/TR/SVG/coords.html>7 Coordinate Systems, Transformations and Units</a>）<p>在这一层面处理好图形的展示之后，剩下的所有变换，无论是 translate、rotate 还是 opacity，我们都可以全权交给 CSS 来处理，并且可以将图形细化到形状或者路径的层面进行变换。<p>然而实际情况是，刚才的那段代码，放进codepen之后是什么也看不见的，原因就在于这个路径的绘制既没有填充颜色也没有描边。<h3 id=填充-code-fill-code->填充——<code>fill</code></h3><p><code>fill</code> 属性用于给形状填充颜色。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-tag>svg</span> <span class=hljs-selector-tag>line</span> {
    <span class=hljs-attribute>fill</span>: <span class=hljs-number>#000</span>; <span class=hljs-comment>/* 填充黑色 */</span>
}</code></pre><p>填充色的透明度通过 <code>fill-opacity</code> 设置。<blockquote><p><code>fill-rule</code> 用于设置填充方式，算法较为抽象，除了 <code>inherit</code> 这个取值，还可取以下两种值：<p><code>nonzero</code>：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的处的走向；计算结果从0开始，每有一个交点处的线段是从左到右的，就加1；每有一个交点处的线段是从右到左的，就减1；这样计算完所有交点后，如果这个计算的结果不等于0，则该点在图形内，需要填充；如果该值等于0，则在图形外，不需要填充。看下面的示例：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/1479651074890.png alt="Alt text"><p><code>evenodd</code>：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的个数，个数为奇数则改点在图形内，需要填充；个数为偶数则点在图形外，不需要填充。看下图的示例：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/1479651086456.png alt="Alt text"><p>——引用来源<a href=http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html>《突袭 HTML5 之 SVG 2D 入门4 - 笔画与填充》</a></blockquote><p>然而我们发现，我们的箭头即使填充了颜色，还是什么也看不见，问题就出在我们绘制的时候使用了没有面积的 <code>line</code> 标签。这个时候，就需要出动描边了。<h3 id=描边-code-stroke-code->描边——<code>stroke</code></h3><p>这个 <code>stroke</code> 可得大书特书，因为光是这个 <code>stroke</code> 就能搞定80%的描线动效。<p>直接通过 <code>stroke</code> 设置描边色，我们就能立刻看到刚才的箭头了。通过 <code>stroke-width</code> 则可以对描边的粗细进行修改。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-tag>svg</span> <span class=hljs-selector-tag>line</span> {
  <span class=hljs-attribute>stroke</span>: <span class=hljs-number>#000</span>;
  <span class=hljs-attribute>stroke-width</span>: <span class=hljs-number>1px</span>;
}</code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/arrow.png alt=arrow><h4 id=线的虚实-code-stroke-dasharray-code->线的虚实：<code>stroke-dasharray</code></h4><p>（敲黑板）王牌属性出现辣！ 这个属性的属性值是1到 n 个数字，多个数字由逗号隔开，CSS 中的定义则由空格分开，每个数字定义了实线段的长度，分别是按照绘制、不绘制这个顺序循环下去。<p>下面是设置了1个、2个、3个数字时虚线的描绘情况对比：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/stroke-dasharray.png alt=stroke-dasharray><h4 id=-code-stroke-dashoffset-code-><code>stroke-dashoffset</code></h4><p>（敲黑板）这个也是重点属性！ 当我们将描边虚实设置成实线部分与图形描边长度相同时，我们是看不到空白段的部分的。这时形状的描边就像完全描绘出来了一样。这时我们使用这个属性，将虚线开始的位置稍微做一下移动，无论是往前移还是往后移，我们都能看到图形描边出现了一段空白，当这个移动形成一个连续的动作时，描线动效就这么不经意的出现了（蓦然回首）。<pre class=nust-code><code class="hljs css"><span class=hljs-selector-tag>svg</span> <span class=hljs-selector-tag>line</span> {
  <span class=hljs-attribute>stroke-dasharray</span>: <span class=hljs-number>60</span>;
    <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>60</span>;
    <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>5s</span>;
}

<span class=hljs-selector-tag>svg</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-tag>line</span> {
    <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>0</span>;
}</code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/arrow_ani_1.gif alt="arrow animation"><p>再对头部做个延时处理，修改一下虚线移动的方向，动效看起来会更顺眼一些。这个时候，SVG 可以分路径编辑的优势就体现出来了。对每个 <code>line</code> 添加一个类，我们就能对每条路径进行差异化处理（<a href=http://codepen.io/lyxuncle/pen/KNaJad>Codepen</a>）。<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"360"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"52"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 89.4 12.4"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"arrow-line"</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"6.2"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"59.6"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"6.2"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"arrow-head"</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"54.7"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"0.7"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"60.5"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"6.5"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"arrow-head"</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"54.7"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"11.7"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"60.5"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"5.8"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><pre class=nust-code><code class="hljs css"><span class=hljs-selector-tag>svg</span> <span class=hljs-selector-tag>line</span> {
  <span class=hljs-attribute>fill</span>: <span class=hljs-number>#000</span>;
  <span class=hljs-attribute>stroke</span>: <span class=hljs-number>#000</span>;
  <span class=hljs-attribute>stroke-width</span>: <span class=hljs-number>1px</span>;
}
<span class=hljs-selector-class>.arrow-line</span> {
  <span class=hljs-attribute>stroke-dasharray</span>: <span class=hljs-number>60</span>;
  <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>60</span>;
  <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>5s</span> .<span class=hljs-number>2s</span>;
}
<span class=hljs-selector-class>.arrow-head</span> {
  <span class=hljs-attribute>stroke-dasharray</span>: <span class=hljs-number>9</span>;
  <span class=hljs-attribute>stroke-dashoffset</span>: -<span class=hljs-number>9</span>;
  <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>2s</span>;
}
<span class=hljs-selector-tag>svg</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-tag>line</span> {
  <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>0</span>;
}
<span class=hljs-selector-tag>svg</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-class>.arrow-line</span> {
  <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>5s</span>;
}
<span class=hljs-selector-tag>svg</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-class>.arrow-head</span> {
  <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>2s</span> .<span class=hljs-number>5s</span>;
}</code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/arrow_ani_2.gif alt="arrow animation"><p>了解了这两个重点属性，动效剩下的重担，就落在了 dasharray 与 dashoffset 值的计算上了。这个步骤或许没有什么捷径，简单的直线、弧线之类的或许还能口算口算，其余的不规则图形也就只有多试这条傻路可走，如果你是图形高手就当我没说。<p>另外三个描边属性：<code>stroke-linecap</code>、<code>stroke-linejoin</code>、<code>stroke-miterlimit</code> 由于暂时用不上惨遭抛弃，具体可参考<a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes>MDN-SVG Tutorial-Fills and Strokes</a>，<code>stroke-miterlimit</code> 详解<a href=http://www.oxxostudio.tw/articles/201409/svg-16-storke-miterlimit.html>SVG 研究之路（16）- Stroke-miterlimit</a>。<h3 id=图形绘制>图形绘制</h3><p>箭头的绘制只用到了路径中最简单的直线路径 <code>line</code>，SVG 中还有矩形 <code>rect</code>、圆形 <code>circle</code>、椭圆 <code>ellipse</code>、折线 <code>polyline</code>、多边形 <code>polygon</code> 以及万能的路径 <code>path</code>。之所以将一些规整的图形单独出标签，是为了代码的可读性更强些，毕竟 SVG 的可读性已经没那么强了……<p>规整图形的属性较好理解（具体可参考<a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths>MDN-SVG Tutorial-Path</a>），这里深入讲解一下如何阅读路径 <code>path</code> 的代码。<h4 id=绝对坐标绘制指令>绝对坐标绘制指令</h4><blockquote><p>这组指令的参数代表的是绝对坐标。假设当前画笔所在的位置为(x0,y0)，则下面的绝对坐标指令代表的含义如下所示：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/1479654445931.png alt="Alt text"><p>移动画笔指令 <code>M</code>，画直线指令：<code>L</code>，<code>H</code>，<code>V</code>，闭合指令 <code>Z</code> 都比较简单；下面重点看看绘制曲线的几个指令。</blockquote><h5 id=绘制圆弧指令-code-a-code-rx-ry-x-axis-rotation-large-arc-flag-sweep-flag-x-y>绘制圆弧指令：<code>A</code> rx ry x-axis-rotation large-arc-flag sweep-flag x y</h5><blockquote><p>用圆弧连接2个点比较复杂，情况也很多，所以这个命令有7个参数，分别控制曲线的的各个属性。下面解释一下数值的含义： rx,ry 是弧所在的椭圆的半长轴、半短轴长度，rx 为 x 轴上的轴长，ry 为 y 轴上的周长。 x-axis-rotation 是此段弧的顺时针旋转角度，负数代表逆时针转动的角度。 large-arc-flag 两个值：<code>1</code>或<code>0</code>。<code>1</code>表示大角度弧线，<code>0</code>代表小角度弧线。 sweep-flag 两个值：<code>1</code>或<code>0</code>。<code>1</code>代表从起点到终点弧线绕中心顺时针方向，<code>0</code>代表逆时针方向。 x,y 是弧终端坐标。</blockquote><p>为了更好的理解圆弧的绘制，我们来试试手动画一下 <a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Arcs>MDN 上的范例</a>：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"320px"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"320px"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 320 320"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>path</span> <span class=hljs-attr>d</span>=<span class=hljs-string>"M10 315
           L 110 215
           A 30 50 0 0 1 162.55 162.45
           L 172.55 152.45
           A 30 50 -45 0 1 215.1 109.9
           L 315 10"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"black"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"green"</span> <span class=hljs-attr>stroke-width</span>=<span class=hljs-string>"2"</span> <span class=hljs-attr>fill-opacity</span>=<span class=hljs-string>"0.5"</span>/></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/SVGArcs_XAxisRotation_with_grid.png alt="SVG Arcs XAxisRotation with grid"><p>首先是 <code>M</code> 和 <code>L</code> 指令：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-first-step.png alt="path d first step"><p>然后是 <code>A</code> 指令的绘制，在这一步可以看到 large-arc-flag（大小弧）与 sweep-flag（弧度方向）值的影响。<p>在本例中，弧度标记值为<code>0</code>，意味着选择小弧；弧度方向标记值为<code>1</code>，意味着选择起点到终点为顺时针方向的那条弧（别眨眼）：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-step-3.gif alt="path d arcs"><p>接下来我们省略掉 <code>L</code> 指令的绘制，来看看下一个圆弧。这个圆弧的旋转角度（x-axis-rotation）发生了变化，体会一下差异：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-last-step.png alt="path d last step"><p>看了这么久，是不是挺纳闷这么难看的东西为什么一定要读懂？其实也不是强求各位看官能成为脑补 SVG 图形的天才，只是大概读懂这些难看的数字，在做动画的时候才会心里有底手上有劲点，至少大概知道这条东西画出来是什么样，而后再针对它写写动效。所以，我们继续看看图形界的万金油——<a href=https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A>贝塞尔曲线</a>吧～！<blockquote><p>……贝塞尔曲线被广泛地在计算机图形中用来为平滑曲线建立模型。贝塞尔曲线是矢量图形文件和相应软件（如 PostScript、PDF 等）能够处理的唯一曲线，用于光滑地近似其他曲线。二次和三次贝塞尔曲线最为常用。 引用来源：<a href=https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A#.E6.87.89.E7.94.A8>维基百科——贝塞尔曲线——应用</a></blockquote><p><a href=https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A#.E5.BB.BA.E6.A7.8B.E8.B2.9D.E8.8C.B2.E6.9B.B2.E7.B7.9A>维基上</a>有详细的贝塞尔曲线绘制公式与动图展示，这里就不做展开。<p><code>path</code> 中的贝塞尔曲线指令共有四个：<code>C</code>，<code>S</code>，<code>Q</code>，<code>T</code>。SVG 只提供了最高阶到三次的贝塞尔曲线绘制指令，事实上大部分绘图软件也是如此。<h5 id=三次贝塞尔曲线-code-c-code-x1-y1-x2-y2-x-y-或者-code-c-code-dx1-dy1-dx2-dy2-dx-dy->三次贝塞尔曲线：<code>C</code> x1 y1, x2 y2, x y （或者 <code>c</code> dx1, dy1, dx2, dy2, dx dy）</h5><blockquote><p>三次贝塞尔曲线有两个控制点，就是(x1,y1)和(x2,y2)，最后面(x,y)代表曲线的终点。</blockquote><p>这个时候还是上动图比较省心。以下面的代码段为例：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"300"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"100"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 60 30"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>path</span> <span class=hljs-attr>d</span>=<span class=hljs-string>"M10 10 C 20 20, 40 20, 50 10"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"#000"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"transparent"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>path</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p>绘制过程如下：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-bezier.gif alt="path d bezier"><p>（手残，顺滑绘制过程请还是参考<a href=https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A#.E5.BB.BA.E6.A7.8B.E8.B2.9D.E8.8C.B2.E6.9B.B2.E7.B7.9A>维基君</a>。）<p>借助 PS 中的钢笔工具根据辅助线能迅速画出路径，可以免去那抽象的计算过程。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-bezier-ps.gif alt="draw bezier curve with ps"><h5 id=简化版三次贝塞尔曲线-code-s-code-x2-y2-x-y-或者-code-s-code-dx2-dy2-dx-dy->简化版三次贝塞尔曲线：<code>S</code> x2 y2, x y （或者 <code>s</code> dx2 dy2, dx dy）</h5><p>很多时候，曲线不止一个弧，为了平滑过渡，第二个曲线的控制点常常是第一个曲线控制点在曲线另外一边的映射点。这个时候可以使用这个简化版本。<blockquote><p>这里要注意的是，如果 <code>S</code> 指令前面没有其他的 <code>S</code> 指令或 <code>C</code> 指令，这个时候会认为两个控制点是一样的，退化成二次贝塞尔曲线的样子；如果 <code>S</code> 指令是用在另外一个 <code>S</code> 指令或者 <code>C</code> 指令后面，这个时候后面这个 <code>S</code> 指令的第一个控制点会默认设置为前面的这个曲线的第二个控制点的一个映射点。——<a href=http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html>《突袭 HTML5 之 SVG 2D 入门2 - 图形绘制》</a></blockquote><p>这里重点讲解一下 <code>S</code> 指令中每个点对应的位置。同样借用 MDN 上的示例：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"190"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"160"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>path</span> <span class=hljs-attr>d</span>=<span class=hljs-string>"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"black"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"transparent"</span>/></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-bezier-s.gif alt="S command"><h5 id=二次贝塞尔曲线-code-q-code-x1-y1-x-y-或者-code-q-code-dx1-dy1-dx-dy->二次贝塞尔曲线：<code>Q</code> x1 y1, x y （或者 <code>q</code> dx1 dy1, dx dy）</h5><p>经历了三次贝塞尔曲线的洗礼，二次贝塞尔曲线看起来真是亲切。<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"190"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"160"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>path</span> <span class=hljs-attr>d</span>=<span class=hljs-string>"M10 80 Q 95 10, 180 80"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"black"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"transparent"</span>/></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/path-d-bezier-q.gif alt="Q command"><p>注：PS 中的钢笔工具绘制二次贝塞尔曲线只能通过三次贝塞尔曲线进行模拟，或许二次贝塞尔曲线最准确的绘制方法就是通过代码了吧。这里有一个可视化 Canvas 绘制贝塞尔曲线的网站——<a href=http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html>Canvas Quadratic Curve Example</a>，实现方式比 SVG 还复杂[抠鼻]。<h5 id=简化版二次贝塞尔曲线-code-t-code-x-y-或者-code-t-code-dx-dy->简化版二次贝塞尔曲线：<code>T</code> x y（或者 <code>t</code> dx dy）</h5><p>与 <code>S</code> 指令类似，为了更顺滑的多弧曲线，<code>T</code> 指令直接指定曲线终点，控制点自动计算。<p>同时，如果 <code>T</code> 指令只在上一个指令为 <code>Q</code> 或者 <code>T</code> 指令的情况下有效，否则当作 <code>L</code> 指令执行。<p>终于把贝塞尔讲完了……<h2 id=第二个神奇的动效>第二个神奇的动效</h2><p>偷偷用一个箭头把 SVG 的填色、描边、路径都给讲完了，然而，SVG 能用到的还不止这些。开玩笑，Web 界的猪——浑身都是宝——可不是吹的。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/play_btn_hover-svg.gif alt="play button hover animation"><p>首先，我们观察一下这个播放键的结构的实现方法（<a href=http://codepen.io/lyxuncle/pen/rWmdMG>Codepen</a>）（注：为了能直观地看到效果，我将 .play-icon-blend 的填充与描边改为了黑色，<a href=http://codepen.io/lyxuncle/pen/qqbopp>原例子</a>中为白色）：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"play-icon-vector"</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"50"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"50"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 50 50"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>defs</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>circle</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"play-circle-template"</span> <span class=hljs-attr>cx</span>=<span class=hljs-string>"25"</span> <span class=hljs-attr>cy</span>=<span class=hljs-string>"25"</span> <span class=hljs-attr>r</span>=<span class=hljs-string>"25"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>circle</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>defs</span>></span>

    <span class=hljs-tag>&lt;<span class=hljs-name>use</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"play-icon-blend"</span> <span class=hljs-attr>xlink:href</span>=<span class=hljs-string>"#play-circle-template"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"#000"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"#000"</span> <span class=hljs-attr>stroke-width</span>=<span class=hljs-string>"4px"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>use</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>use</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"play-icon-circle"</span> <span class=hljs-attr>xlink:href</span>=<span class=hljs-string>"#play-circle-template"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"#fff"</span> <span class=hljs-attr>stroke</span>=<span class=hljs-string>"#fff"</span> <span class=hljs-attr>stroke-width</span>=<span class=hljs-string>"2px"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>use</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>path</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"play-icon-polygon"</span> <span class=hljs-attr>d</span>=<span class=hljs-string>"M31.49,24.31a0.73,0.73,0,0,1,0,1.38l-8.27,5.64A0.74,0.74,0,0,1,22,30.64V19.36a0.74,0.74,0,0,1,1.22-.69Z"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"#fff"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>path</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.play-icon-vector</span> {
  <span class=hljs-attribute>overflow</span>: visible;
}
<span class=hljs-selector-class>.play-icon-circle</span> ,
<span class=hljs-selector-class>.play-icon-polygon</span> {
  <span class=hljs-attribute>mix-blend-mode</span>: exclusion;
  <span class=hljs-attribute>transition</span>: opacity .<span class=hljs-number>3s</span> <span class=hljs-built_in>cubic-bezier</span>(.08,.03,.22,.87);
}
<span class=hljs-selector-class>.play-icon-blend</span> {
  <span class=hljs-attribute>transform-origin</span>: center;
  <span class=hljs-attribute>transform</span>: <span class=hljs-built_in>scale</span>(0);
  <span class=hljs-attribute>transition</span>: transform .<span class=hljs-number>25s</span> <span class=hljs-built_in>cubic-bezier</span>(.08,.03,.22,.87);
}
<span class=hljs-selector-class>.play-icon-vector</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-class>.play-icon-blend</span> {
  <span class=hljs-attribute>transform</span>: <span class=hljs-built_in>scale</span>(1.1);
}</code></pre><p>这里顺带用了一下下 <a href=https://css-tricks.com/almanac/properties/m/mix-blend-mode/ >CSS3 的滤镜</a> <code>mix-blend-mode</code>（SVG 也有滤镜功能，这里不做介绍，感兴趣的可以移步<a href=http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html>《突袭 HTML5 之 SVG 2D 入门10 - 滤镜》</a>）。这里用到的值 <code>exclusion</code> 的效果，是在叠加区域只显示亮色，下面是使用了同样滤镜的图片与正常图片的对比图，感受一下：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/exclusion.jpg alt=exclusion><p>图片来源：<a href=https://css-tricks.com/almanac/properties/m/mix-blend-mode/ >CSS-Tricks-mix-blend-mode</a><p>可以看到代码里还出现了一些了不得的标签—— <code>&lt;defs></code>、<code>&lt;use></code>。接下来，我们就来了解一下它们。<p>首先我们知道，通过中间圆圈的缩放，再加上外围圆圈与中心三角的叠加效果，完成了这个 hover 效果。也就意味着，圆圈在这里用到两次。这个时候就可以使用 SVG 里路径的重用与引用功能。<h3 id=svg-的重用与引用>SVG 的重用与引用</h3><p>三种集合标签：<code>&lt;g></code>、<code>&lt;symbol></code>、<code>&lt;defs></code>，都是用于将零散的图形组合成一个整体。区别在于：<ul><li><code>&lt;g></code>：组合标签。添加 <code>id</code> 属性来作为引用的钩子，可在 <code>&lt;g></code> 标签上设置这组元素的相关属性（填色、描边等等）。<li><code>&lt;symbol></code>：模板标签。与 <code>&lt;g></code> 标签一样，通过 <code>id</code> 进行引用。不同点在于，<code>symbol</code> 元素本身不会被渲染；<code>symbol</code> 元素拥有属性 <code>viewBox</code> 和 <code>preserveAspectRatio</code>，这些允许 <code>symbol</code> 缩放图形。<li><code>&lt;defs></code>：定义标签。不仅仅是图形对象的合集，还可以是渐变效果、蒙版、滤镜等等，设置好 <code>id</code>，在对应的属性（例如渐变就是 <code>fill</code>、蒙版就是 <code>mask</code>、滤镜就是 <code>filter</code>）中引用即可，引用格式为“<code>url(#id)</code>”。具体例子参看<a href=http://www.oxxostudio.tw/articles/201409/svg-18-defs.html>《SVG 研究之路 (18) - 再談 defs》</a>。</ul><p>更详细的区别见<a href=http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html>《突袭 HTML5 之 SVG 2D 入门7 - 重用与引用》</a>。<p>以上三种集合的引用统一使用 <code>&lt;use></code> 标签。<code>xlink:href</code> 属性指定引用的 <code>id</code>。<blockquote><p><code>use</code> 元素的作用过程就相当于把被引用的对象深拷贝一份到独立的非公开的 DOM 树中；这棵树的父节点是 <code>use</code> 元素。虽然是非公开的DOM节点，但是本质上还是 DOM 节点，所以被引用对象的所有属性值、动画、事件、 CSS 的相关设置等都会拷贝多来并都还是会起作用，而且这些节点也会继承 <code>use</code> 元素和 <code>use</code> 祖先的相关属性（注意引用元素是深拷贝，这些拷贝过来的元素与原来的元素已经无关系了，所以这里不会继承被引用元素祖先节点的属性），如果这些节点本身有相关（CSS）属性，还会覆盖继承来的属性，这些与普通的DOM节点是一致的，所以对use元素使用“<code>visibility:hidden</code>”时要小心，并不一定会起作用。但是由于这部分节点是非公开的，在 DOM 操作中，也只能看到 <code>use</code> 元素，所以也只能操作到 <code>use</code> 元素。</blockquote><p>在 SVG Sprite 中，<code>&lt;use></code> 的使用比较猖狂（<a href=https://aotu.io/notes/2016/07/09/SVG-Symbol-component-practice/ >《拥抱 Web 设计新趋势：SVG Sprites 实践应用》</a>，同时也提到了 SVG 的兼容情况），而当 SVG 图形代码与引用部分分离开时，想针对图形中的某一部分进行处理就会显得特别麻烦（只能看到 <code>use</code> 结点），这个时候，打开 shadow DOM 的显示，包你一览无余（具体操作方法见<a href=https://aotu.io/notes/2016/06/24/Shadow-DOM/ >《神奇的 Shadow DOM》</a>）。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/shadow-root.png alt="svg shadow root"><p>打开了 shadow DOM 显示的 <code>use</code> 标签<p>下面就来看一个非图形引用的例子。在前面我们知道了，如果要描边动效，那修改 <code>stroke-dashoffset</code> 就可以达到效果。然而这种方法本身就是利用了虚线的 hack，如果我们想要做一个虚线的描线动效呢？比如：<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/grid_icon_hover.gif alt="grid icon hover"><p>这个时候 <code>stroke-dasharray</code> 与 <code>stroke-offset</code> 的合作是无法完成的，因为他俩动起来本身就是虚线在移动。所以我们需要换个思路，描线动画还是那个描线动画，只是虚线的绘制需要使用另一个 hack —— 蒙版。<h3 id=蒙版>蒙版</h3><p>SVG 中的蒙版有两种——剪裁cliping <code>&lt;clipPath></code> 与遮罩mask <code>&lt;mask></code>，都需要在 <code>&lt;defs></code> 中定义，然后通过对应的属性进行引用。<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>defs</span>></span>
    <span class=hljs-comment>&lt;!-- 剪裁的定义 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>clipPath</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"cliping"</span>></span>...<span class=hljs-tag>&lt;/<span class=hljs-name>clipPath</span>></span>
    <span class=hljs-comment>&lt;!-- 遮罩的定义 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>mask</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"mask"</span>></span>...<span class=hljs-tag>&lt;/<span class=hljs-name>mask</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>defs</span>></span>

  <span class=hljs-comment>&lt;!-- 剪裁的引用 --></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>circle</span> <span class=hljs-attr>clip-path</span>=<span class=hljs-string>"url(#cliping)"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>circle</span>></span>
  <span class=hljs-comment>&lt;!-- 遮罩的引用 --></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>circle</span> <span class=hljs-attr>clip-path</span>=<span class=hljs-string>"url(#mask)"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>circle</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><p>注：以上代码为了直观体现两者的使用方法，已剔除其余不相干代码，不可直接运行。<p>剪裁与遮罩的区别在于，剪裁是按照定义的形状界限分明地进行图像的展示与隐藏：<p>而遮罩相较于剪裁，多了渐变显示图像的功能，只要在 <code>&lt;mask></code> 中包裹渐变的定义即可。遮罩的展示策略是：<blockquote><p>越黑越透明，越白越不透明，而遮色片（注：即遮罩）只有黑到白的灰階分布，所以如果作為遮色片的顏色是灰階以外的顏色，都會被轉換為灰階。——引用来源<a href=http://www.oxxostudio.tw/articles/201406/svg-09-clipping-masking.html>《SVG 研究之路 (9) - Clipping and Masking》</a></blockquote><p>因此遮罩的功能其实是包含剪裁的，当遮罩使用的是纯黑的图像时，功能等同于剪裁。<p><img src=https://misc.aotu.io/lyxuncle/20161125_SVG_Web_Animation/cliping_mask_2.jpg alt="cliping and mask"><p>虚线的描线动效结合剪裁或者遮罩即可以完成（<a href=http://codepen.io/lyxuncle/pen/PbmdxO>Codepen</a>）：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>svg</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"300"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"100"</span> <span class=hljs-attr>viewBox</span>=<span class=hljs-string>"0 0 300 100"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>defs</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>clipPath</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"dash"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"dash"</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"40"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"60"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"80"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>clipPath</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>mask</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"mask-dash"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"mask_dash"</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"40"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"60"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"80"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"20"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"10"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"34"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>mask</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>defs</span>></span>

  <span class=hljs-tag>&lt;<span class=hljs-name>g</span> <span class=hljs-attr>clip-path</span>=<span class=hljs-string>"url(#dash)"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"line"</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"28"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"100"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"28"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>g</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>g</span> <span class=hljs-attr>mask</span>=<span class=hljs-string>"url(#mask-dash)"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>rect</span> <span class=hljs-attr>x</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y</span>=<span class=hljs-string>"36"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"100"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"8"</span> <span class=hljs-attr>fill</span>=<span class=hljs-string>"#eee"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>rect</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>line</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"line"</span> <span class=hljs-attr>x1</span>=<span class=hljs-string>"0"</span> <span class=hljs-attr>y1</span>=<span class=hljs-string>"40"</span> <span class=hljs-attr>x2</span>=<span class=hljs-string>"100"</span> <span class=hljs-attr>y2</span>=<span class=hljs-string>"40"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>line</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>g</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>svg</span>></span></code></pre><pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.mask_dash</span> <span class=hljs-selector-tag>rect</span>{
  <span class=hljs-attribute>fill</span>: <span class=hljs-number>#fff</span>;
}
<span class=hljs-selector-class>.line</span> {
  <span class=hljs-attribute>stroke</span>: <span class=hljs-number>#000</span>;
  <span class=hljs-attribute>stroke-width</span>: <span class=hljs-number>8px</span>;
  <span class=hljs-attribute>stroke-dasharray</span>: <span class=hljs-number>100</span>;
  <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>100</span>;
  <span class=hljs-attribute>transition</span>: stroke-dashoffset ease-in .<span class=hljs-number>5s</span>;
}
<span class=hljs-selector-tag>svg</span><span class=hljs-selector-pseudo>:hover</span> <span class=hljs-selector-class>.line</span> {
  <span class=hljs-attribute>stroke-dashoffset</span>: <span class=hljs-number>0</span>;
}</code></pre><p>注意到上方使用了遮罩的集合里多了一个方形图像，是因为遮罩对于图形尺寸的要求更加严苛，<code>line</code> 在它的眼里不是东西，不提供任何效果支持，但是一旦加个方形垫背，<code>line</code> 就被接受了[翻白眼]。所以涉及到切割的蒙版，请尽量使用 <code>clipPath</code>。<h3 id=总结>总结</h3><p>写到这里，阿婆主气数已尽，SVG 是个深坑，这里也只能借着三个例子扯扯若干特性，等下回心情好了，阿婆主再拎几个出来说说（也是任性，人的 SVG 笔记都是一个属性一篇的）。下面我们来给这篇凌乱的文章做个梳理：<ul><li>今天我们实现了三个动效——<ul><li><a href=http://codepen.io/lyxuncle/pen/wozzrV><strong>箭头</strong>描线动效</a><li><a href=http://codepen.io/lyxuncle/pen/qqbopp><strong>播放按钮</strong>滤镜动效</a><li><a href=http://codepen.io/lyxuncle/pen/bBejZZ><strong>虚线</strong>描线动效</a></ul><li>动效来源于 <a href=http://www.welikesmall.com/work/adobe/ >WLS-Adobe</a><li>聊到了 SVG 的几个标签<ul><li><code>&lt;path></code><li><code>&lt;g></code><li><code>&lt;symbol></code><li><code>&lt;defs></code><li><code>&lt;use></code><li><code>&lt;clipPath></code><li><code>&lt;mask></code></ul><li>以及属性<ul><li><code>viewBox</code><li><code>preserveAspectRatio</code><li><code>fill</code><li><code>stroke</code><li><code>stroke-dasharray</code><li><code>stroke-dashoffset</code><li><code>d</code><li><code>clip-path</code><li><code>mask</code></ul><li>动效实现对应的关键点<ul><li><strong>箭头</strong>——<code>stroke-dasharray</code>、<code>stroke-dashoffset</code><li><strong>播放按钮</strong>——<code>&lt;defs></code>、<code>&lt;use></code><li><strong>虚线</strong>——<code>&lt;clipPath></code>、<code>&lt;mask></code>、<code>clip-path</code>、<code>mask</code>、<code>stroke-dasharray</code>、<code>stroke-dashoffset</code></ul></ul><p>文中引用到的资料（前方高能预警）：<ul><li><a href=http://www.cnblogs.com/dxy1982/tag/svg/ >《突袭 HTML5 之 SVG 2D 入门》</a>，沙场秋点兵<ul><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html>2.图形绘制</a><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html>4.笔画与填充</a><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html>6.坐标与变换</a><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html>7.重用与引用</a><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/06/01/2395742.html>9.蒙板</a><li><a href=http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html>10.滤镜</a></ul><li>《SVG 研究之路》，<a href=http://www.oxxostudio.tw/ >Oxxo Studio</a><ul><li><a href=http://www.oxxostudio.tw/articles/201406/svg-09-clipping-masking.html>9.Clipping and Masking</a><li><a href=http://www.oxxostudio.tw/articles/201409/svg-16-storke-miterlimit.html>16.Stroke-miterlimit</a><li><a href=http://www.oxxostudio.tw/articles/201409/svg-18-defs.html>18.再談 defs</a><li><a href=http://www.oxxostudio.tw/articles/201409/svg-23-viewpoint-viewBox.html>23.理解 viewport 與 viewbox</a></ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial>SVG Tutorial</a>，<a href=https://developer.mozilla.org/en-US/ >MDN</a><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Positions>Positions</a><li><a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes>Fills and Strokes</a><li><a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths>Path</a></ul><li><a href=https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A>贝塞尔曲线</a>，维基百科<li><a href=https://css-tricks.com/almanac/properties/m/mix-blend-mode/ >mix-blend-mode</a>，<a href=https://css-tricks.com/author/robinrendle/ >Robin Rendle</a>，<a href=https://css-tricks.com/ >CSS-Tricks</a><li><a href=https://aotu.io/notes/2016/07/09/SVG-Symbol-component-practice/ >《拥抱 Web 设计新趋势：SVG Sprites 实践应用》</a>，高大师，<a href=https://aotu.io/ >凹凸实验室</a><li><a href=https://aotu.io/notes/2016/06/24/Shadow-DOM/ >《神奇的 Shadow DOM》</a>，暖暖，<a href=https://aotu.io/ >凹凸实验室</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>「塔罗牌」 - 轻氧 V1.4 尝鲜体验邀请</title>
      <link>https://aotu.io/notes/2016-11-21/liteo2-app-tarots</link>
      <guid>https://aotu.io/notes/2016-11-21/liteo2-app-tarots</guid>
      <pubDate>2016-11-21T13:21:43.000Z</pubDate>
      <description>
      
        「轻氧」是一款专门为互联网从业人士打造的资讯应用，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一次把业界最优质的文章读完。
      
      </description>
      
      <content:encoded><![CDATA[<p>今天要介绍的是<a href=//app.aotu.io>轻氧1.4版本</a>，Code Name「塔罗牌」，这是一个玩儿的版本。<p>如果你还不知道轻氧是什么鬼，那末可以先移步这里：<a href=https://aotu.io/notes/2016/11/09/liteo2-app/ >轻氧 - 2016年末最新款互联网专业资讯 APP</a>，或者直接关注「凹凸实验室」的公众号以获取更多轻氧APP的最新讯息。<p>在轻氧上一个版本（响尾蛇）推出的时候，我们在实验室的公众号做了一次小范围的推广，总用户数虽然谈不上惊喜，但也超出了一开始的期望，且每日俱增。<p>朋友们所给的评论和意见，不管褒贬我们都有记录，而其中呼声最高的安卓版本，我们已优先列入开发计划，技术选型上我们决定尝试使用阿里的<a href=https://github.com/alibaba/weex>weex</a>，支持国货，人人有责。<h2 id=塔罗牌-tarots->塔罗牌（Tarots)</h2><p>「看看资讯，玩玩牌」，我们其实就是想给「轻氧」加一个神秘好玩的功能，类似远古时代的「占卜」，通过用户主动给予它的一些交互引出一些未知的功能，这个版本叫「塔罗牌」，打开APP，相信你们就知道怎么玩。<h2 id=玩法>玩法</h2><p>实在不会玩的童鞋可以看下玩法流程：<p><img src=//misc.aotu.io/o2/img/app/v1-4-flow.png alt=玩法><p>APP将玩法最终呈现给用户的是一张张卡片UI，所以我们把每次推送给用户的活动称为「卡牌」。每个卡牌具有不一样的玩法功能和营销意义。<p>卡牌的出现可以增加一些有趣的逻辑，例如带频道限制的卡牌 - 适用于在不同频道摇出不同的卡片；带时间段限制的卡片 - 可以在不同的时间段、节日摇出不一样的卡片。。。<p>而至于卡牌内容的设计，嘿嘿，我们可以很乖巧，也可以很邪恶，可以很文艺清新，也可以风骚YD，可以很地方随意，也可以很官方严肃，总之我们努力满足各方要求，不管你是宅男还是欲女！<p>在1.4.0版本中，我们只准备了有限的3张卡牌，大伙儿先提前尝尝鲜吧。<p>成熟性感与完美，需要多给我们一点调教的时间。<h2 id=尝鲜下载体验>尝鲜下载体验</h2><blockquote><p>目前仅提供ios版本 基于 Weex 的 Android 版与网页版正在紧急开发中，敬请期待。</blockquote><p>官网地址： <a href=https://app.aotu.io target=_blank>https://app.aotu.io</a><p>下载地址： <a href="https://jdc.jd.com/lab/redirect_app.html?ADTAG=o2.site.app"title=下载试用 class="btn btn-greyline btn-mobile-full"><img src=http://storage.360buyimg.com/mtd/home/appstorelogo1478670585078.jpg alt=下载试用「轻氧」 width=250px></a><p>扫二维码：<p><a href="https://jdc.jd.com/lab/redirect_app.html?ADTAG=o2.site.app"title=轻氧二维码 class="btn btn-greyline btn-mobile-full"><img src=https://misc.aotu.io/o2/img/app/qrcode.png alt=轻氧二维码 width=250px></a><p>问题反馈：<ul><li>「凹凸实验室」公众号 (AOTULabs)<li>APP 个人中心 -> 设置 -> 意见反馈</ul><p>希望在这个信息爆炸的时代，「轻氧」能够帮助你<strong>聚焦更优质的资讯内容</strong>。 也让你更加专注于用心被创造出来的文章，和其创造者。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>正则表达式理论篇</title>
      <link>https://aotu.io/notes/2016-11-17/regexp-theory</link>
      <guid>https://aotu.io/notes/2016-11-17/regexp-theory</guid>
      <pubDate>2016-11-17T09:29:38.000Z</pubDate>
      <description>
      
        总是记不住正则表达式的语法？我这就来加深你们的印象。
      
      </description>
      
      <content:encoded><![CDATA[<p>学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。<h2 id=首先你要记住它的名字>首先你要记住它的名字</h2><p>正则表达式 regular expression 缩写 regexp 、regex 、egrep。<h2 id=正则表达式可以干嘛>正则表达式可以干嘛</h2><ul><li>数据验证。<li>复杂的字符串搜寻、替换。<li>基于模式匹配从字符串中提取子字符串。</ul><h2 id=概述>概述</h2><p>正则表达式包括<strong>普通字符</strong>（例如，a 到 z 之间的字母）和<strong>特殊字符</strong>（称为“元字符”）。<p>若要匹配这些特殊字符，必须首先<strong>转义字符</strong>，即，在字符前面加反斜杠字符 <code>\</code>**。 例如，若要搜索 “+”文本字符，可使用表达式 <code>\+</code>。 但是大多数 特殊字符 在中括号表达式内出现时失去本来的意义，并恢复为普通字符。<h2 id=构造函数-四种写法->构造函数（四种写法）</h2><pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> regex = <span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(<span class=hljs-string>'xyz'</span>, <span class=hljs-string>'i'</span>);  
<span class=hljs-keyword>var</span> regex = <span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(<span class=hljs-regexp>/xyz/i</span>); 
<span class=hljs-keyword>var</span> regex = <span class=hljs-regexp>/xyz/i</span>; 

<span class=hljs-comment>// ES6的写法。ES5在第一个参数是正则时，不允许此时使用第二个参数，会报错。 </span>
<span class=hljs-comment>// 返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</span>
<span class=hljs-comment>// 下面代码返回”i”。</span>
<span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(<span class=hljs-regexp>/abc/ig</span>, <span class=hljs-string>'i'</span>).flags</code></pre><h2 id=用于模式匹配的string方法>用于模式匹配的String方法</h2><ul><li>String.search() 参数：要搜索的子字符串，或者一个正则表达式。 返回：<strong>第一个与参数匹配的子串的起始位置，如果找不到，返回-1</strong>。 说明：不支持全局搜索，如果参数是字符串，会先通过RegExp构造函数转换成正则表达式。</ul><ul><li>String.replace() 作用：查找并替换字符串。<br>第一个参数：字符串或正则表达式， 第二个参数：要进行替换的字符串，也可以是函数。 用法：</ul><p>替换文本中的$字符有特殊含义：<pre class=nust-code><code class="hljs shell"><span class=hljs-meta>$</span><span class=bash>1、<span class=hljs-variable>$2</span>、...、<span class=hljs-variable>$99</span> 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</span>
<span class=hljs-meta>$</span><span class=bash>&    与 regexp 相匹配的子串。</span>
<span class=hljs-meta>$</span><span class=bash>`    位于匹配子串左侧的文本。</span>
<span class=hljs-meta>$</span><span class=bash><span class=hljs-string>'    位于匹配子串右侧的文本。</span></span>
<span class=hljs-meta>$</span><span class=bash><span class=hljs-string>$    普通字符$。</span></span></code></pre><p>如：<pre class=nust-code><code class="hljs awk"><span class=hljs-string>'abc'</span>.replace(<span class=hljs-regexp>/b/g</span>, <span class=hljs-string>"{$$$`$&$'}"</span>)
<span class=hljs-regexp>//</span> 结果为 <span class=hljs-string>"a{$abc}c"</span>，即把b换成了{<span class=hljs-variable>$abc</span>}</code></pre><ul><li>String.match() 参数：要搜索的子字符串，或者一个正则表达式。 返回：<strong>一个由匹配结果组成的数组</strong>。</ul><p><strong>非全局检索</strong>：如果没有找到任何匹配的文本返回null；否则数组的第一个元素是匹配的字符串，剩下的是小括号中的子表达式，即a[n]中存放的是$n的内容。非全局检索返回三个属性：length 属性；index 属性声明的是匹配文本的第一个字符的位置；input 属性则存放的是被检索的字符串 string。<p><strong>全局检索</strong>：设置标志g则返回所有匹配子字符串，即不提供与子表达式相关的信息。没有 index 属性或 input 属性。<p><img src=//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/match.png alt=match><ul><li>String.split() 作用：把一个字符串分割成字符串数组。<br>参数：正则表达式或字符串。 返回：子串组成的数组。</ul><h2 id=regexp的方法>RegExp的方法</h2><ul><li>RegExpObject.exec() 参数：字符串。 返回：</ul><p><strong>非全局检索</strong>：与String.macth()非全局检索相同，返回一个数组或null。<p><strong>全局检索</strong>：尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配。但是可以反复调用来实现全局检索。在 RegExpObject 的lastIndex 属性指定的字符处开始检索字符串；匹配后，将更新lastIndex为匹配文本的最后一个字符的下一个位置；再也找不到匹配的文本时，将返回null，并把 lastIndex 属性重置为 0。<p>如：<p><img src=//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/exec_g.png alt=exec全局检索><ul><li><p>RegExpObject.test()<br>参数：字符串。 返回：true或false。<li><p>RegExpObject.toString()<br>返回：字符串</ul><h2 id=字符>字符</h2><p><code>|</code> 指示在两个或多个项之间进行选择。类似js中的或，又称<strong>分支条件</strong>。 <code>/</code> 正则表达式模式的开始或结尾。 <code>\</code> 反斜杠字符，用来转义。 <code>-</code> 连字符 <strong>当且仅当在字符组[]的内部表示一个范围</strong>，比如[A-Z]就是表示范围从A到Z；如果需要在字符组里面表示普通字符-，放在字符组的开头或者尾部即可。<p><code>.</code> 匹配除换行符 \n 之外的任何单个字符。 <code>\d</code> 等价[0-9]，匹配0到9字符。 <code>\D</code> 等价[^0-9]，与<code>\d</code>相反。 <code>\w</code> 与以下任意字符匹配：A-Z、a-z、0-9 和下划线，等价于 [A-Za-z0-9<em>]。 <code>\W</code> 与\w相反，即 [^A-Za-z0-9</em>]<h2 id=限定符-量词字符->限定符（量词字符）</h2><p><strong>显示限定符</strong>位于大括号 {} 中，并包含指示出现次数上下限的数值；<code>*+?</code> 这三个字符属于<strong>单字符限定符</strong>：<p><code>{n}</code> 正好匹配 n 次。 <code>{n,}</code> 至少匹配 n 次。 <code>{n,m}</code> 匹配至少 n 次，至多 m 次。 <code>*</code> 等价{0,} <code>+</code> 等价{1,} <code>?</code> 等价{0,1}<p>注意：<ul><li>显示限定符中，逗号和数字之间不能有空格，否则返回null！<li><strong>贪婪量词<code>*</code>和<code>+</code></strong>：javascript默认是贪婪匹配，也就是说匹配重复字符是尽可能多地匹配。<li><strong>惰性（最少重复匹配）量词<code>?</code></strong>：当进行非贪婪匹配，只需要在待匹配的字符后面跟随一个<code>?</code>即可。</ul><pre class=nust-code><code class="hljs stata"><span class=hljs-keyword>var</span> <span class=hljs-keyword>reg</span> = /a+/;
<span class=hljs-keyword>var</span> reg2 = /a+?/;
<span class=hljs-keyword>var</span> str = 'aaab';

str.<span class=hljs-built_in>match</span>(<span class=hljs-keyword>reg</span>); <span class=hljs-comment>// ["aaa"]</span>
str.<span class=hljs-built_in>match</span>(reg2); <span class=hljs-comment>// ["a"]</span></code></pre><h2 id=定位点-锚字符-边界->定位点（锚字符、边界）</h2><p><code>^</code> 匹配开始的位置。将 <code>^</code> 用作括号<code>[]</code>表达式中的第一个字符，则会对字符集求反。 <code>$</code> 匹配结尾的位置。 <code>\b</code> 与一个字边界匹配，如er\b 与“never”中的“er”匹配，但与“verb”中的“er”不匹配。 <code>\B</code> 非边界字匹配。<h2 id=标记>标记</h2><ul><li><p>中括号<code>[]</code> 字符组；标记括号表达式的开始和结尾，起到的作用是匹配这个或者匹配那个。 <code>[...]</code> 匹配方括号内<strong>任意字符</strong>。很多字符在<code>[]</code>都会失去本来的意义：<code>[^...]</code>匹配不在方括号内的任意字符；<code>[?.]</code>匹配普通的问号和点号。 注意：反斜杠字符 <code>\</code> 在<code>[]</code>中仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 <code>\\</code>。 <strong>另外不要滥用字符组这个失去意义的特性，比如不要使用<code>[.]</code>来代替<code>\:</code>转义点号，因为需要付出处理字符组的代价</strong>。<li><p>大括号<code>{}</code> 标记限定符表达式的开始和结尾。<li><p>小括号<code>()</code> 标记子表达式的开始和结尾，主要作用是分组，对内容进行区分。</ul><p><code>(模式)</code> 可以记住和这个模式匹配的匹配项（捕获分组）。<strong>不要滥用括号，如果不需要保存子表达式，可使用非捕获型括号<code>(?:)</code>来进行性能优化</strong>。 <code>(?:模式)</code> 与模式 匹配，但不保存匹配项(非捕获分组)。 <code>(?=模式)</code> 零宽正向先行断言，要求匹配与模式 匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项；但不会保存匹配项。 <code>(?!模式)</code> 零宽负向先行断言，要求匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项；但不会保存匹配项。<p>有点晕？ 好，换个说法。。。<p>先行断言<code>(?=模式)</code>：x只有在y前面才匹配，必须写成<code>/x(?=y)/</code>。 解释：找一个x，那个x的后面有y。 先行否定断言<code>(?!模式)</code>： x只有不在y前面才匹配，必须写成<code>/x(?!y)/</code>。 解释：找一个x，那个x的后面没有y。<p>稳住，又来了两个断言，来自ES7提案：<p>后行断言<code>(?&lt;=模式)</code>：与"先行断言”相反， x只有在y后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。解释：找一个x，那个x的前面要有y。 后行否定断言<code>(?&lt;!模式)</code>： 与”先行否定断言“相反，x只有不在y后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。 解释：找一个x，那个x的前面没有y。<p>可以看出，后行断言先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分，即先右后左"的执行顺序。<p>零宽负向先行断言的例子：<pre class=nust-code><code class="hljs coffeescript">var str=`<span class=javascript>&lt;div <span class=hljs-class><span class=hljs-keyword>class</span></span>=<span class=hljs-string>"o2"</span>>
            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"o2_team"</span>></span>
                <span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"img/logo.jpg"</span> /></span>
            <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></span></span>`;
<span class=hljs-regexp>//</span> &lt;(?!img) 表示找一个左尖括号&lt;，而且左尖括号&lt;的后面没有img字符；
<span class=hljs-regexp>//</span> (?:.|\r|\n)*? 表示匹配左右尖括号&lt;>里面的.或\r或\n，而且匹配次数为*?；(?:)不保存匹配项，提高性能；
<span class=hljs-regexp>//</span> *后面加个? 表示非贪婪匹配。
var reg = <span class=hljs-regexp>/&lt;(?!img)(?:.|\r|\n)*?>/gi</span>;
str.match(reg);
<span class=hljs-regexp>//</span> 返回结果 [<span class=hljs-string>"&lt;div class="</span>o2<span class=hljs-string>">"</span>, <span class=hljs-string>"&lt;div class="</span>o2_team<span class=hljs-string>">"</span>, <span class=hljs-string>"&lt;/div>"</span>, <span class=hljs-string>"&lt;/div>"</span>]</code></pre><ul><li>反向引用：主要作用是给分组加上标识符\n。 <code>\n</code> 表示引用字符，与第n个子表达式第一次匹配的字符相匹配。</ul><p>反向引用的例子，给MikeMike字符后加个单引号：<pre class=nust-code><code class="hljs stata"><span class=hljs-keyword>var</span> <span class=hljs-keyword>reg</span> = /(Mike)(\1)(s)/;
<span class=hljs-keyword>var</span> str = <span class=hljs-string>"MikeMikes"</span>;
console.<span class=hljs-built_in>log</span>(str.<span class=hljs-keyword>replace</span>(<span class=hljs-keyword>reg</span>,<span class=hljs-string>"$1$2'$3"</span>));
<span class=hljs-comment>// 返回结果 MikeMike's</span></code></pre><h2 id=非打印字符>非打印字符</h2><p><code>\s</code> 任何空白字符。即<code>[ \f\n\r\t\v]</code> <code>\S</code> 任何非空白字符。 <code>\t</code> Tab 字符(\u0009)。 <code>\n</code> 换行符(\u000A) <code>\v</code> 垂直制表符(\u000B)。 <code>\f</code> 换页符(\u000C) <code>\r</code> 回车符(\u000D)。<p>注意：<code>\n</code>和<code>\r</code>一起使用，即 <code>/[\r\n]/g</code>来匹配换行，因为unix扩展的系统以<code>\n</code>标志结尾，window以<code>\r\n</code>标志结尾。<h2 id=其他>其他</h2><p><code>\cx</code> 匹配 x 指示的<strong>控制字符</strong>，要求x 的值必须在 A-Z 或 a-z 范围内。 <code>\xn</code> 匹配n，n 是一个十六进制转义码，两位数长。 <code>\un</code> 匹配 n，其中n 是以四位十六进制数表示的 Unicode 字符。<p><code>\nm</code> 或 \n 先尝试<strong>反向引用</strong>，不可则再尝试标识为一个八进制转义码。 <code>\nml</code> 当n 是八进制数字 (0-3)，m 和 l 是八进制数字 (0-7) 时，匹配八进制转义码 nml。<h2 id=修饰符>修饰符</h2><ul><li><code>i</code> 执行不区分大小写的匹配。<li><code>g</code> 执行一个全局匹配，简而言之，即找到所有的匹配，而不是在找到第一个之后就停止。<li><code>m</code> 多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束。</ul><p>ES6新增u和y修饰符：<ul><li><code>u</code>修饰符</ul><p>含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。<pre class=nust-code><code class="hljs taggerscript">// 加u修饰符以后，ES6就会识别<span class=hljs-symbol>\u</span>D83D<span class=hljs-symbol>\u</span>DC2A为一个字符，返回false。
/^<span class=hljs-symbol>\u</span>D83D/u.test('<span class=hljs-symbol>\u</span>D83D<span class=hljs-symbol>\u</span>DC2A')  // false
/^<span class=hljs-symbol>\u</span>D83D/.test('<span class=hljs-symbol>\u</span>D83D<span class=hljs-symbol>\u</span>DC2A') // true</code></pre><ul><li><code>y</code>修饰符</ul><p>与g修饰符都是全局匹配，不同之处在于：lastIndex属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止；但是<code>y</code>修饰符要求必须在lastIndex指定的位置发现匹配，即<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也是“粘连”的涵义。<pre class=nust-code><code class="hljs awk"><span class=hljs-regexp>/b/y</span>.exec(<span class=hljs-string>'aba'</span>)  <span class=hljs-regexp>//</span> null 
<span class=hljs-regexp>/b/</span>.exec(<span class=hljs-string>'aba'</span>)  <span class=hljs-regexp>//</span> [<span class=hljs-string>"b"</span>]</code></pre><h2 id=优先级顺序->优先级顺序：</h2><ol><li><code>\</code> 转义符<li><code>(), (?:), (?=), []</code> 括号和中括号<li><code>*、+、?、{n}、{n,}、{n,m}</code> 限定符<li>任何元字符<code>^、$、\</code> 定位点和序列<li><code>|</code> 替换</ol><h2 id=关于引擎>关于引擎</h2><p>JS 是 NFA 引擎。<p>NFA 引擎的特点：<ul><li><strong>以贪婪方式进行，尽可能匹配更多字符</strong>。<li><strong>急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果（多选条件分支的情况）</strong>。</ul><pre class=nust-code><code class="hljs ada"><span class=hljs-symbol>'nfa</span> <span class=hljs-keyword>not</span>'.match(/nfa|nfa <span class=hljs-keyword>not</span>/)
//  返回[<span class=hljs-string>"nfa"</span>]</code></pre><ul><li><strong>回溯（backtracking），导致速度慢</strong>。</ul><p>举个贪婪与回溯结合的例子：<pre class=nust-code><code class="hljs awk"><span class=hljs-string>"AB01CD23CD45CEff"</span>.match(<span class=hljs-string>'AB.*CD'</span>)
<span class=hljs-regexp>//</span> 返回 [<span class=hljs-string>"AB01CD23CD"</span>]</code></pre><p>匹配顺序如图所示：<p><img src=//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/backtracking.png alt=match><h2 id=参考>参考</h2><p>MDN w3school <a href=http://es6.ruanyifeng.com/#docs/regex>http://es6.ruanyifeng.com/#docs/regex</a> <a href=http://imweb.io/topic/56e804ef1a5f05dc50643106>http://imweb.io/topic/56e804ef1a5f05dc50643106</a> <a href=http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html>http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html</a> <a href=http://www.cnblogs.com/hustskyking/p/how-regular-expressions-work.html>http://www.cnblogs.com/hustskyking/p/how-regular-expressions-work.html</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>XCel 项目总结 - Electron 与 Vue 的性能优化</title>
      <link>https://aotu.io/notes/2016-11-16/xcel</link>
      <guid>https://aotu.io/notes/2016-11-16/xcel</guid>
      <pubDate>2016-11-15T23:23:23.000Z</pubDate>
      <description>
      
        XCel 是一款基于用研组需求的 Excel 数据过滤工具，本文将分享 Electron、Vue 等相关涉及技术的基本知识和性能优化经验。这也许是Jc的2016年最后一篇文章，且看且不珍惜。
      
      </description>
      
      <content:encoded><![CDATA[<p>XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。<p>XCEL 基于 Electron 和 Vue 2.0 进行开发，充分利用 Electron 多进程任务处理等功能，使其拥有高性能、跨平台（windows 7+、Mac 和 Linux）的特性。<p>落地页：<a href=https://xcel.aotu.io/ >https://xcel.aotu.io/</a> ✨✨✨<br>项目地址：<a href=https://github.com/o2team/xcel>https://github.com/o2team/xcel</a> ✨✨✨<h2 id=项目背景>项目背景</h2><p>用户研究的定量研究和轻量级数据处理中，均需对数据进行清洗处理，用以剔除异常数据，保证数据结果的信度和效度。目前因调研数据和轻量级数据的多变性，对轻量级数据清洗往往采取人工清洗，缺少统一、标准的清洗流程，但对于调研和轻量级的数据往往是需要保证数据稳定性的，因此，在对数据进行清洗的时候最好有可以标准化的清洗方式。<h2 id=特性一览>特性一览</h2><ul><li>基于 Electron 研发并打包成为原生应用，用户体验良好；<li>可视化操作 Excel 数据，支持文件的导入导出；<li>拥有单列运算逻辑、多列运算逻辑和双列范围逻辑三种筛选方式，并且可通过“且”、“或”和“编组”的方式任意组合。</ul><h2 id=思路与实现>思路与实现</h2><p>结合用研组的需求，我们利用 Electron 和 Vue 的特性对该工具进行开发。<h3 id=技术选型>技术选型</h3><ul><li>Electron：桌面端跨平台框架，为 Web 提供了原生接口的权限。打包后的程序兼容 Windows 7 及以上、Mac、Linux 的 32 / 64 位系统。<a href=http://electron.atom.io/ >详情>></a><li>Vue 全家桶：Vue 拥有数据驱动视图的特性，适合重数据交互的应用。<a href=http://vuejs.org/ >详情>></a><li>js-xlsx：各种电子表格格式的解析器和生成器。纯 JavaScript 实现，适用于 Node.js 和 Web 前端。<a href=https://github.com/SheetJS/js-xlsx>详情>></a></ul><h3 id=实现思路>实现思路</h3><ol><li>通过 js-xlsx 解析 Excel 文件生成 JSON 格式<li>根据筛选条件对 JSON 数据进行筛选过滤<li>将过滤后的 JSON 数据生成 js-xlsx 指定的数据结构<li>利用 js-xlsx 对转换后的数据生成 Excel 文件</ol><hr><p><strong>纸上得来终觉浅，绝知此事要躬行</strong><h2 id=相关技术>相关技术</h2><p>如果对某项技术比较熟悉可略读/跳过。<h3 id=electron>Electron</h3><h4 id=electron-是什么->Electron 是什么？</h4><p>Electron 是一个能让你通过 <strong>JavaScript、HTML 和 CSS</strong> 构建桌面应用的<strong>框架</strong>。这些应用能打包到 Mac、Windows 和 Linux 电脑上运行，当然它们也能上架到 Mac 和 Windows 的 app stores。<ul><li><strong>JavaScript、HTML 和 CSS</strong> 都是 Web 语言，这就意味着它们都是组成网站的一部分，浏览器（如 Chrome）能将这些代码转为可视化图像。<li><strong>Electron 是一个框架</strong>：Electron 对底层代码进行抽象和封装，让开发者能在此之上构建项目。</ul><h4 id=为什么它如此重要->为什么它如此重要？</h4><p>通常来说，桌面应用都需要用每个操作系统对应的原生语言进行开发。这意味着需要拥有 3 个团队为这个应用编写 3 个相应的版本。Electron 则允许你通过 web 语言编写一次即可。<ul><li><strong>原生（操作系统）语言</strong>：用于开发主流操作系统的应用的原生语言如下（大多数情况下）：Mac 对应 Objective C、Linux 对应 C、Windows 对应 C++。</ul><h4 id=它由什么组成->它由什么组成？</h4><p>Electron 结合了 <strong>Chromium</strong>、<strong>Node.js</strong> 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。<ul><li><strong>Chromium</strong>：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。<li><strong>Node.js（Node）</strong>：一个用于在服务器运行 JavaScript 的运行时（runtime），它拥有文件系统和网络的权限（你的电脑也可以是一台服务器！）。</ul><p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/components.jpg alt="Electron 的组成"><h4 id=开发体验如何->开发体验如何？</h4><p>基于 Electron 的开发，就好像开发一个网页一样，而且能够无缝地 <strong>使用 Node</strong>。或者说：就好像构建一个 Node app，并通过 HTML 和 CSS 构建界面。另外，你只需为一个浏览器（<strong>最新的 Chrome</strong>）进行设计（即无需考虑兼容性）。<ul><li><strong>使用内置的 Node</strong>：这还不是全部！除了 Node API，你还可以使用托管在 npm 上，超过 350,000 个的模块。<li><strong>一个浏览器</strong>：并非所有浏览器都提供一致的样式，因此 web 设计师和开发者时常不得不花费更多的精力去让一个网站在不同的浏览器上看起来一致。<li><strong>最新的 Chrome</strong>：可使用超过 90% 的 ES2015 特性和其它很酷的特性（如 CSS 变量）。</ul><h4 id=两个进程-重点->两个进程（重点）</h4><p>Electron 有两个种进程：『主进程』和『渲染进程』。有些模块只能工作在其中一个进程上，而有些则能工作在两个进程上。主进程更多地充当幕后角色，而渲染进程则是应用的每个窗口。<br>PS：可通过任务管理器（PC）/活动监视器（Mac）查看进程的相关信息。<ul><li><strong>模块</strong>：Electron 的 API 是根据它们的功能进行分组。例如：<code>dialog</code> 模块拥有所有原生 dialog 的 API，如打开文件、保存文件和弹窗。</ul><h4 id=主进程>主进程</h4><p>主进程，通常是一个命名为 <code>main.js</code> 的文件，该文件是每个 Electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它能<strong>调用原生元素</strong>和创建新的（多个）渲染进程，而且整个 Node API 是内置其中的。<ul><li><strong>调用原生元素</strong>：打开 diglog 和其它操作系统交互均是资源密集型操作（注：出于安全考虑，渲染进程是不能直接调用本地资源的），因此都需要在主进程完成。</ul><p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/main.jpg alt=主进程><h4 id=渲染进程>渲染进程</h4><p>渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 Electron 应用只能有一个主进程）并且是<strong>相互独立的</strong>。它们也能是<strong>隐藏的</strong>。它通常被命名为 <code>index.html</code>。它们就像典型的 HTML 文件，但在 Electron 中，它们能获取完整的 Node API 特性。因此，这也是它与其它浏览器不同的地方。<ul><li><strong>相互独立</strong>：每个渲染进程都是独立的，这意味着就算它们某个崩溃了，也不会影响其余的渲染进程。<li><strong>隐藏的</strong>：你可以设置一个窗口是隐藏的，然后让它只在背后执行代码（👍）。</ul><p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/renderer.jpg alt=渲染进程><h4 id=把它们想象成这样>把它们想象成这样</h4><p>在 Chrome（或其它浏览器）中的每个标签页（tab） 和其内的页面，就好比 Electron 中的一个单独渲染进程。如果你关闭所有标签页，Chrome 依然存在，这好比 Electron 的主进程，而且你能打开一个新的窗口或关闭这个应用。<blockquote><p>注：一般情况下，在 Chrome 浏览器中，一个标签页（tab）中的页面（即除了浏览器本身部分，如搜索框、工具栏等）就是一个渲染进程。</blockquote><p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/like-this.jpg alt=把它们想象成这样><h4 id=相互通讯>相互通讯</h4><p>尽管主进程和渲染进程都有各自的任务，但它们之间也有需要协同完成的任务。因此它们之间需要通讯。<strong>IPC</strong>就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息。<ul><li><strong>IPC</strong>：主进程和渲染进程都有一个 IPC 模块。</ul><p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/ipc.jpg alt=此处输入图片的描述><h4 id=汇成一句话>汇成一句话</h4><p>Electron 应用就像 Node 应用，它也依赖一个 <code>package.json</code> 文件。该文件定义了哪个文件作为主进程，并因此让 Electron 知道从何启动你的应用。然后主进程能创建渲染进程，并能使用 IPC 让两者间进行消息传递。<p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/app-files.jpg alt=汇成一句话><p>至此，Electron 的基础部分介绍完毕。该部分是基于我之前翻译的一篇文章<a href=http://jlord.us/essential-electron/ >《Essential Electron》</a>，译文可点击 <a href=https://segmentfault.com/a/1190000007503495>这里</a>。<hr><h3 id=vue-全家桶>Vue 全家桶</h3><p>目前，该工具应用了 Vue、Vuex、Vuex-router。在工具基本定型阶段，由 1.x 升级到了 2.0 （Vuex 暂未升级）。<h4 id=为什么选择-vue>为什么选择 Vue</h4><p>对于我来说：<ul><li>简单易用，一般使用只需看官方文档。<li>数据驱动视图，所以基本不用操作 DOM 了。<li>框架的存在是为了帮助我们应对复杂度。<li>全家桶的好处是：对于一般场景，我就不需要考虑用哪些个库（插件）。</ul><p>Vue 1.x -> Vue 2.0 的版本迁移用 <a href=https://github.com/vuejs/vue-migration-helper>vue-migration-helper</a> 即可分析出大部分需要更改的地方。<p>网上已经有很多关于 Vue 的信息了。至此，Vue 部分介绍完毕。<hr><h3 id=js-xlsx>js-xlsx</h3><p>该库支持各种电子表格格式的解析和生成。它由纯 JavaScript 实现，适用于前端和 Node。<a href=https://github.com/SheetJS/js-xlsx>详情>></a><p>支持读入的格式有：<ul><li>Excel 2007+ XML Formats (XLSX/XLSM)<li>Excel 2007+ Binary Format (XLSB)<li>Excel 2003-2004 XML Format (XML "SpreadsheetML")<li>Excel 97-2004 (XLS BIFF8)<li>Excel 5.0/95 (XLS BIFF5)<li>OpenDocument Spreadsheet (ODS)</ul><p>支持写的格式有：<ul><li>XLSX<li>CSV (and general DSV)<li>JSON and JS objects (various styles)</ul><p>只要能提供读（解析）和写，剩下的就是靠 JavaScript 处理解析出来的数据（JSON）了。目前该库提供了 <code>sheet_to_json</code> 方法，该方法能将读入的 Excel 数据转为 JSON 格式。由于导出时需要提供特定的 JSON 格式，因此这部分需要我们自己实现。<p>更多关于 Excel 在 JavaScript 中处理的知识可关注：凹凸实验室的<a href=https://aotu.io/notes/2016/04/07/node-excel/ >《Node读写Excel文件探究实践》</a>。但该文章存在两处问题（均在 js-xlsx 实战的导出表格部分）：<ol><li>生成头部时，Excel 的列信息简单地通过 <code>String.fromCharCode(65+j)</code> 生成，但列大于 26 时就会出现问题。这个问题会在后面章节中给出解决方案；<li>转换成 worksheet 需要的结构处，出现逻辑性错误，并且会导致严重的性能问题。逻辑问题在此不讲述，我们讲下性能问题： ECMAScript 的不断更新，让 JavaScript 更加强大和易用。尽管如此，我们还是要做到『物尽所用』，而不要『大材小用』，否则会得到反效果。这里导致性能问题的正是 <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign>Object.assign()</a> 方法，该方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。由于该方法自身的实现机制，会在这里产生大量的冗余操作。而这里的单元格信息是唯一的，所以直接通过 forEach 为一个空对象赋值即可。提升 N 倍性能的同时，也把逻辑性错误解决了。</ol><p>原来的：<pre class=nust-code><code class="hljs moonscript">var result = 某数组.reduce(<span class=hljs-function><span class=hljs-params>(prev, <span class=hljs-built_in>next</span>)</span> =></span> Object.assign({}, prev, {[<span class=hljs-built_in>next</span>.position]: {<span class=hljs-name>v</span>: <span class=hljs-built_in>next</span>.v}}), {});</code></pre><p>改为：<pre class=nust-code><code class="hljs coffeescript">var result = 某数组.forEach(<span class=hljs-function><span class=hljs-params>(v, i)</span> =></span> data[v.position]= {v: v.v})</code></pre><hr><p><strong>实践是检验真理的唯一标准</strong> 在理解上述知识的前提下，下面就谈谈一些在实践中总结出来的<strong>技巧、难点和重点</strong>。<h2 id=css-javascript-和-electron-相关的知识和技巧>CSS、JavaScript 和 Electron 相关的知识和技巧</h2><h3 id=高亮-table-的列>高亮 table 的列</h3><p>Excel 单元格采用 <code>table</code> 展示。在 Excel 中，被选中的单元格会高亮相应的『行』和『列』，以提醒用户。在该应用中也有做相应处理，横向高亮采用 <code>tr:hover</code> 实现，而纵向呢？这里所采用的一个技巧是：<p>假设 HTML 结构如下：<pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-tag>div</span><span class=hljs-selector-class>.container</span>
  <span class=hljs-selector-tag>table</span>
    <span class=hljs-selector-tag>tr</span>
      td</code></pre><p>CSS 代码如下：<pre class=nust-code><code class="hljs scss"><span class=hljs-selector-class>.container</span> { <span class=hljs-attribute>overflow</span>:hidden; }
<span class=hljs-selector-tag>td</span> { <span class=hljs-attribute>position</span>: relative; }
<span class=hljs-selector-tag>td</span>:hover::after { 
  <span class=hljs-attribute>position</span>: absolute; 
  <span class=hljs-attribute>left</span>: <span class=hljs-number>0</span>; 
  <span class=hljs-attribute>right</span>: <span class=hljs-number>0</span>; 
  <span class=hljs-attribute>top</span>: -<span class=hljs-number>1</span>个亿px; <span class=hljs-comment>// 小目标达成，不过是负的😭</span>
  <span class=hljs-attribute>bottom</span>: -<span class=hljs-number>1</span>个亿px; 
  <span class=hljs-attribute>z-index</span>: -<span class=hljs-number>1</span>; <span class=hljs-comment>// 避免遮住自身和同列 td 的内容、border 等</span>
}</code></pre><h3 id=斜分割线>斜分割线</h3><p>如图：<img src=//misc.aotu.io/JChehe/2016-11-15-xcel/fenge.jpg alt=斜分割线><p>分割线可以通过 <code>::after/::before</code> 伪类元素实现一条直线，然后通过 <code>transform:rotate();</code> 旋转特定角度实现。但这种实现的一个问题是：由于宽度是不定的，因此需要通过 JavaScript 运算才能得到准确的对角分割线。<p>因此，这里可以通过 CSS 线性渐变 <code>linear-gradient(to top right, transparent, transparent calc(50% - .5px), #d3d6db calc(50% - .5px), #d3d6db calc(50% + .5px), transparent calc(50% + .5px))</code> 实现。无论宽高如何变，依然妥妥地自适应。<h3 id=excel-的列转换>Excel 的列转换</h3><ul><li>Excel 的列需要用『字母』表示，但不能简单地通过 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode>String.fromCharCode()</a> 实现，因为当超出 <code>26列</code> 时会产生问题（如：第 <code>27</code> 列，<code>String.fromCharCode(65+26)</code> 得到的是 <code>[</code>，而不是 <code>AA</code>）。因此，这需要通过『十进制和26进制转换』算法来实现。</ul><pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// 将指定的自然数转换为26进制表示。映射关系：[0-25] -> [A-Z]。</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getCharCol</span>(<span class=hljs-params>n</span>) </span>{
  <span class=hljs-keyword>let</span> temCol = <span class=hljs-string>''</span>,
    s = <span class=hljs-string>''</span>,
    m = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> (n > <span class=hljs-number>0</span>) {
    m = n % <span class=hljs-number>26</span> + <span class=hljs-number>1</span>
    s = <span class=hljs-built_in>String</span>.fromCharCode(m + <span class=hljs-number>64</span>) + s
    n = (n - m) / <span class=hljs-number>26</span>
  }
  <span class=hljs-keyword>return</span> s
}</code></pre><pre class=nust-code><code class="hljs javascript"><span class=hljs-comment>// 将指定的26进制转换为自然数。映射关系：[A-Z] ->[0-25]。</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getNumCol</span>(<span class=hljs-params>s</span>) </span>{
  <span class=hljs-keyword>if</span> (!s) <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>
  <span class=hljs-keyword>let</span> n = <span class=hljs-number>0</span>
  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = s.length - <span class=hljs-number>1</span>, j = <span class=hljs-number>1</span>; i >= <span class=hljs-number>0</span>; i--, j *= <span class=hljs-number>26</span>) {
    <span class=hljs-keyword>let</span> c = s[i].toUpperCase()
    <span class=hljs-keyword>if</span> (c &lt; <span class=hljs-string>'A'</span> || c > <span class=hljs-string>'Z'</span>) <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>
    n += (c.charCodeAt() - <span class=hljs-number>64</span>) * j - <span class=hljs-number>1</span>
  }
  <span class=hljs-keyword>return</span> n
}</code></pre><h3 id=为-dom-的-file-对象增加了-path-属性>为 DOM 的 File 对象增加了 path 属性</h3><p>Electron 为 File 对象额外增了 path 属性，该属性可得到文件在文件系统上的真实路径。因此，你可以利用 Node 为所欲为😈。应用场景有：拖拽文件后，通过 Node 提供的 File API 读取文件等。<h3 id=支持常见的编辑功能-如粘贴和复制>支持常见的编辑功能，如粘贴和复制</h3><p>Electron 应用在 MacOS 中默认不支持『复制』『粘贴』等常见编辑功能，因此需要为 MacOS 显式地设置复制粘贴等编辑功能的菜单栏，并为此设置相应的快捷键。<pre class=nust-code><code class="hljs dockerfile">// darwin 就是 MacOS
if (process.platform === <span class=hljs-string>'darwin'</span>) {
    var template = [{
      <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'FromScratch'</span>,
</span>      submenu: [{
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Quit'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+Q'</span>,
        click: function() { app.quit(); }
      }]
    }, {
      <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Edit'</span>,
</span>      submenu: [{
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Undo'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+Z'</span>,
        selector: <span class=hljs-string>'undo:'</span>
      }, {
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Redo'</span>,
</span>        accelerator: <span class=hljs-string>'Shift+CmdOrCtrl+Z'</span>,
        selector: <span class=hljs-string>'redo:'</span>
      }, {
        type: <span class=hljs-string>'separator'</span>
      }, {
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Cut'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+X'</span>,
        selector: <span class=hljs-string>'cut:'</span>
      }, {
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Copy'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+C'</span>,
        selector: <span class=hljs-string>'copy:'</span>
      }, {
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Paste'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+V'</span>,
        selector: <span class=hljs-string>'paste:'</span>
      }, {
        <span class=hljs-keyword>label</span><span class=bash>: <span class=hljs-string>'Select All'</span>,
</span>        accelerator: <span class=hljs-string>'CmdOrCtrl+A'</span>,
        selector: <span class=hljs-string>'selectAll:'</span>
      }]
    }];
    var osxMenu = menu.buildFromTemplate(template);
    menu.setApplicationMenu(osxMenu);
}</code></pre><h3 id=更贴近原生应用>更贴近原生应用</h3><p>Electron 的一个缺点是：即使你的应用是一个简单的时钟，但它也不得不包含完整的基础设施（如 Chromium、Node 等）。因此，一般情况，打包后的程序至少会达到几十兆（根据系统类型进行浮动）。当你的应用越复杂，就越可以忽略这部分了。<p>众所周知，页面的渲染难免会导致『白屏』，而且这里采用了 Vue 框架，情况就更加糟糕了。另外，Electron 应用也避免不了『先打开浏览器，再渲染页面』的步骤。下面提供几种方法来减轻这种情况，以让程序更贴近原生应用。<ol><li>指定 BrowserWindow 的背景颜色；<li>先隐藏窗口，直到页面加载后再显示；<li>保存窗口的尺寸和位置，以让程序下次被打开时，依然保留的同样大小和出现在同样的位置上。</ol><p>对于第一点，若程序的背景不是纯白（#fff）的，那么可指定窗口的背景颜色与其一致，以避免突变。<pre class=nust-code><code class="hljs ebnf"><span class=hljs-attribute>mainWindow</span> = new BrowserWindow({
    title: <span class=hljs-string>'XCel'</span>,
    backgroundColor: <span class=hljs-string>'#f5f5f5'</span>,
};</code></pre><p>对于第二点，由于 Electron 本质是一个浏览器，需要加载非网页部分的资源。因此，我们可以先隐藏窗口。<pre class=nust-code><code class="hljs maxima"><span class=hljs-built_in>var</span> mainWindow = <span class=hljs-built_in>new</span> BrowserWindow({
    <span class=hljs-built_in>title</span>: 'ElectronApp',
    <span class=hljs-built_in>show</span>: <span class=hljs-literal>false</span>,
};</code></pre><p>等到渲染进程开始渲染页面的那一刻，在 <code>ready-to-show</code> 的回调函数中显示窗口。<pre class=nust-code><code class="hljs delphi">mainWindow.<span class=hljs-keyword>on</span>(<span class=hljs-string>'ready-to-show'</span>, <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span> <span class=hljs-comment>{
    mainWindow.show();
    mainWindow.focus();
}</span>);</span></code></pre><p>对于第三点，我并没有实现，原因如下：<ol><li>用户一般是根据当时的情况对程序的尺寸和位置进行调整，即视情况而定。<li>以上是我个人臆测，主要是我懒🐶。</ol><p>其实现方式，可参考<a href=https://blog.avocode.com/blog/4-must-know-tips-for-building-cross-platform-electron-apps>《4 must-know tips for building cross platform Electron apps》</a>。<h3 id=如何在渲染进程调用原生弹框->如何在渲染进程调用原生弹框？</h3><p>在渲染进程中调用原本专属于主进程中的 API （如弹框）的方式有两种：<ol><li>IPC 通讯模块：先在主进程通过 ipcMain 进行监听，然后在渲染进程通过 ipcRenderer 进行触发；<li><p>remote 模块：该模块提供了一种在渲染进程（网页）和主进程之间进行进程间通讯（IPC）的简便途径。<ul><li>对于第一种，有需要就在评论区留言；<li><p>对于第二种， 在渲染进程中，运行以下代码即可：<pre class=nust-code><code class="hljs stylus">const remote = require(<span class=hljs-string>'electron'</span>)<span class=hljs-selector-class>.remote</span>

remote<span class=hljs-selector-class>.dialog</span><span class=hljs-selector-class>.showMessageBox</span>({
   type: <span class=hljs-string>'question'</span>,
   buttons: [<span class=hljs-string>'不告诉你'</span>, <span class=hljs-string>'没有梦想'</span>],
   defaultId: <span class=hljs-number>0</span>,
   title: <span class=hljs-string>'XCel'</span>,
   message: <span class=hljs-string>'你的梦想是什么？'</span>
}</code></pre></ul></ol><h3 id=自动更新>自动更新</h3><p>如果 Electron 应用没有了自动更新的功能，那么意味着用户想体验你新开发的功能或用上修复 Bug 后的新版本，只能靠自己主动地去官网下载，这无疑是糟糕的体验。Electron 提供的 <a href=http://electron.atom.io/docs/api/auto-updater/ >autoUpdater</a> 模块可实现自动更新功能，该模块提供了第三方框架 <a href=https://github.com/Squirrel>Squirrel</a> 的接口，但 Electron 目前只内置了 <a href=https://github.com/Squirrel/Squirrel.Mac>Squirrel.Mac</a>，且它与 <a href=https://github.com/Squirrel/Squirrel.Windows>Squirrel.Windows</a>（需要额外引入）的处理方式也不一致（在客户端与服务器端两方面），因此如果刚接触该模块，会发现处理起来相对比较繁琐。具体可以参考我的一篇译文<a href=https://segmentfault.com/a/1190000007616641>《Electron 自动更新的完整教程（Windows 和 OSX）》</a>。<blockquote><p>目前 Electron 的 autoUpdater 模块不支持 Linux 系统。</blockquote><p>另外，XCel 目前并没有采用 autoUpdater 模块实现自动更新功能，而是利用 Electron 的 <a href=http://electron.atom.io/docs/api/download-item/ >DownloadItem</a> 模块实现。而服务器端则采用 <a href=https://nuts.gitbook.com/ >Nuts</a>。<h3 id=为-electron-应用生成-windows-安装包>为 Electron 应用生成 Windows 安装包</h3><p>通过 electron-builder 即可直接生成常见的 MacOS 安装包，但它生成的 Windows 的安装包却略显简洁。<p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/macos-installer.png alt="常见的MacOS 安装包"><br>Mac 常见的安装模式，将“左侧的应用图标”拖拽到“右侧的 Applications”即可<p>通过 electron-builder 生成的 Windows 安装包与我们在 Windows 上常见的软件安装界面不太一样，它没有安装向导和点击“下一步”的按钮，只有一个安装时的 gif 动画（默认的 gif 动画如下图，当然你也可以指定特定的 gif 动画），因此也就没有让用户选择安装路径等权利。<p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/install-spinner.gif alt="Windows 安装时默认的动画"><br>Windows 安装时 <a href=https://github.com/electron/windows-installer/blob/master/resources/install-spinner.gif>默认显示的 gif 动画</a><p>如果你想为打包后的 Electron 应用（即通过 electron-packager/electron-builder 生成的 、可直接运行的程序目录）生成需要点击“下一步”和可让用户指定安装路径的常见安装包，可以通过 NSIS 程序，具体可看这篇教程 <a href=http://seesawworld.blogspot.com/2016/02/1-nsis.html>《[教學]只要10分鐘學會使用 NSIS 包裝您的桌面軟體–安裝程式打包。完全免費。》</a>。<blockquote><p>NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序。它提供了安装、卸载、系统设置、文件解压缩等功能。这如其名字所指出的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的。NSIS 的脚本语言和通常的编程语言有类似的结构和语法，但它是为安装程序这类应用所设计的。</blockquote><p>至此，CSS、JavaScript 和 Electron 相关的知识和技巧 部分阐述完毕。<hr><h2 id=性能优化>性能优化</h2><p>下面谈谈『性能优化』，这部分涉及到<strong>运行效率</strong>和<strong>内存占用量</strong>。<br>注：以下内容均基于 Excel 样例文件（数据量为：1913 行 x 180 列）得出的结论。<h3 id=执行效率和渲染的优化>执行效率和渲染的优化</h3><h4 id=vue-性能真的好->Vue 性能真的好？</h4><p>Vue 一直标榜着自己性能优异，但当数据量上升到一定量级时（如 1913 x 180 ≈ 34 万个数据单元），会出现严重的性能问题（不做相应优化的前提下）。<p>如直接通过列表渲染 <code>v-for</code> 渲染数据时，会导致程序卡死。<br>答：通过查阅相关资料可得（猜测）， <code>v-for</code> 是通过一条条数据在构建后插入 DOM 的，这对于数据量较大时，无疑会造成严重的性能问题。<p>当时，我想到了两种解决思路：<ol><li>Vue 是数据驱动视图的，对数据分段 push，即将一个庞大的任务分割为 N 份。<li>自己拼接 HTML 字符串，再通过 innerHTML 一次性插入。</ol><p>最终，我选择了第二条，理由是：<ol><li>性能最佳，因为每次执行数据过滤时，Vue 都要进行 diff，性能不佳。<li>更符合当前应用的需求：纯展示且无需动画过渡等。<li>实现更简单</ol><p>将原本繁重的 DOM 操作转移到了 JavaScript 的拼接字符串后，性能得到了很大提升（不会导致程序卡死而渲染不出视图）。这种实现原理难道不就是 Vue、React 等框架解决的问题之一吗？只不过框架考虑的场景更广，有些地方需要我们自己根据实际情况进行优化而已。<blockquote><p>在浏览器当中，JavaScript 的运算在现代的引擎中非常快，但 DOM 本身是非常缓慢的东西。当你调用原生 DOM API 的时候，浏览器需要在 JavaScript 引擎的语境下去接触原生的 DOM 的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实 DOM 的操作是最少的。 —— <a href=http://www.infoq.com/cn/articles/vue-2-progressive-front-end-solution>《Vue 2.0——渐进式前端解决方案》</a></blockquote><p>当然，由于 JavaScript 天生单线程，即使执行数速度再快，也会导致页面有短暂的时间拒绝用户的输入。此处可通过 Web Worker 或其它方式解决，这也将是我们后续讲到的问题。<p>也有网友提供了优化大量列表的方法：<a href=https://clusterize.js.org/。>https://clusterize.js.org/。</a> 但在这里我并没有采用此方式。<h4 id=强大的-gpu-加速>强大的 GPU 加速</h4><p>插入 DOM 后，又会出现了另外一个问题：滚动会很卡。猜想这是渲染问题，毕竟 34 万个单元格同时存在于界面中。<p>添加 <code>transform: translate3d(0, 0, 0) / translateZ(0)</code> 属性启动 GPU 渲染，即可解决这个渲染性能问题。再次感叹该属性的强大。🐂<p>后来，考虑到用户并不需要查看全部数据，只需展示部分数据让用户进行参考即可。我们对此只渲染前 30/50 行数据。这样即可提升用户体验，也能进一步优化性能（又是纯属臆测）。<h4 id=记得关闭-vuex-的严格模式>记得关闭 Vuex 的严格模式</h4><p>另外，由于自己学艺不精和粗心大意，忘记在生产环境关闭 Vuex 的『严格模式』。 Vuex 的严格模式要<strong>在生产中关闭</strong>，否则会对 state 树进行一个深观察 (deep watch)，产生不必要的性能损耗。也许在数据量少时，不会注意到这个问题。<p>我当时的情况是：导入 Excel 数据后，再进行交互（涉及 Vuex 的读写操作），则需要等几秒才会响应，而直接通过纯 DOM 监听的事件则无此问题。由此，判断出是 Vuex 问题。<pre class=nust-code><code class="hljs arduino"><span class=hljs-keyword>const</span> store = <span class=hljs-keyword>new</span> Vuex.Store({
  <span class=hljs-comment>// ...</span>
  strict: <span class=hljs-built_in>process</span>.env.NODE_ENV !== <span class=hljs-string>'production'</span>
})</code></pre><h2 id=多进程->多进程！！！</h2><p>前面说道，JavaScript 天生单线程，即使再快，对于需要处理数据量较大的情况，也会出现拒绝响应的问题。因此需要 Web Worker 或类似的方案去解决。<p>在这里我不选择 Web worker 的原因有如下几点：<ol><li>有其它更好的替代方案：一个主进程能创建多个渲染进程，通过 IPC 即可进行数据交互；<li>Electron 不支持 Web Worker！</ol><p>Electron 作者在 2014.11.7 在《state of web worker support?》 issue 中回复了以下这一段：<blockquote><p>Node integration doesn't work in web workers, and there is no plan to do. Workers in Chromium are implemented by starting a new thread, and Node is not thread safe. Back in past we had tried to add node integration to web workers in Atom, but it crashed too easily so we gave up on it.</blockquote><p>因此，我们最终采用了创建一个新的渲染进程 <code>background process</code> 进行处理数据。由 Electron 章节可知，每个 Electron 渲染进程是独立的，因此它们不会互相影响。但这也带来了一个问题：它们不能相互通讯？<p>错！下面有 3 种方式进行通讯：<ol><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/Storage>Storage API</a>：对某个标签页的 localStorage/sessionStorage 对象进行增删改时，其他标签页能通过 window.storage 事件监听到。<li><a href=https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API>IndexedDB</a>：IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。<li>通过主进程作为中转站：设主界面的渲染进程是 A，<code>background process</code> 是 B，那么 A 先将 Excel 数据传递到主进程，然后主进程再转发到 B。B 处理完后再原路返回，具体如下图。当然，也可以将数据存储在主进程中，然后在多个渲染进程中使用 remote 模块来访问它。</ol><p>该工具采用了第三种方式的第一种情况：<br><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/multiprocess.jpg alt=Multiprocessing><p>1、主页面渲染进程 A 的代码如下：<pre class=nust-code><code class="hljs stylus"><span class=hljs-comment>//①</span>
ipcRenderer.send(<span class=hljs-string>'filter-start'</span>, {
    filterTagList: this<span class=hljs-selector-class>.filterTagList</span>,
    filterWay: this<span class=hljs-selector-class>.filterWay</span>,
    curActiveSheetName: this<span class=hljs-selector-class>.activeSheet</span><span class=hljs-selector-class>.name</span>
})

<span class=hljs-comment>// ⑥ 在某处接收 filter-response 事件</span>
ipcRenderer.on(<span class=hljs-string>"filter-response"</span>, (arg) => {
    <span class=hljs-comment>// 得到处理数据</span>
})</code></pre><p>2、作为中转站的主进程的代码如下：<pre class=nust-code><code class="hljs stylus"><span class=hljs-comment>//②</span>
ipcMain.on(<span class=hljs-string>"filter-start"</span>, (event, arg) => {
    <span class=hljs-comment>// webContents 用于渲染和控制 web page</span>
    backgroundWindow<span class=hljs-selector-class>.webContents</span><span class=hljs-selector-class>.send</span>(<span class=hljs-string>"filter-start"</span>, arg)
})

<span class=hljs-comment>// ⑤ 用于接收返回事件</span>
ipcMain.on(<span class=hljs-string>"filter-response"</span>, (event, arg) => {
    mainWindow<span class=hljs-selector-class>.webContents</span><span class=hljs-selector-class>.send</span>(<span class=hljs-string>"filter-response"</span>, arg)
})</code></pre><p>3、处理繁重数据的 <code>background process</code> 渲染进程 B 的代码如下：<pre class=nust-code><code class="hljs less"><span class=hljs-comment>// ③</span>
<span class=hljs-selector-tag>ipcRenderer</span><span class=hljs-selector-class>.on</span>(<span class=hljs-string>'filter-start'</span>, (event, arg) => {
    <span class=hljs-comment>// 进行运算</span>
    ... 

    <span class=hljs-comment>// ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件</span>
    <span class=hljs-selector-tag>ipcRenderer</span><span class=hljs-selector-class>.send</span>(<span class=hljs-string>'filter-response'</span>, {
        <span class=hljs-attribute>filRow</span>: tempFilRow
    })
})</code></pre><p>至此，我们将『读取文件』、『过滤数据』和『导出文件』三大耗时的数据操作均转移到了 <code>background process</code> 中处理。<p>这里，我们只创建了一个 <code>background process</code>，如果想要做得更极致，我们可以新建『CPU 线程数- 1 』 个的 <code>background process</code> 同时对数据进行处理，然后在主进程对处理后数据进行拼接，最后再将拼接后的数据返回到主页面的渲染进程。这样就可以充分榨干 CPU 了。当然，在此我不会进行这个优化。<blockquote><p>不要为了优化而优化，否则得不偿失。 —— 某网友</blockquote><h3 id=内存占有量过大>内存占有量过大</h3><p>解决了执行效率和渲染的问题，发现也存在内存占用量过大的问题。当时猜测是以下几个原因：<ol><li>三大耗时操作均放置在 <code>background process</code> 处理。在通讯传递数据的过程中，由于不是共享内存（因为 IPC 是基于 Socket 的），导致出现多份数据副本（在写该篇文章时才有了这相对确切的答案）。<li>Vuex 是以一个全局单例的模式进行管理，但它会是不是对数据做了某些封装，而导致性能的损耗呢？<li>由于 JavaScript 目前不具有主动回收资源的能力，所以只能主动对闲置对象设置为 <code>null</code>，然后等待 GC 回收。</ol><blockquote><p>由于 Chromium 采用多进程架构，因此会涉及到进程间通信问题。Browser 进程在启动 Render 进程的过程中会建立一个以 UNIX Socket 为基础的 IPC 通道。有了 IPC 通道之后，接下来 Browser 进程与 Render 进程就以消息的形式进行通信。我们将这种消息称为 IPC 消息，以区别于线程消息循环中的消息。 ——<a href=http://blog.csdn.net/luoshengyang/article/details/47822689>《Chromium的IPC消息发送、接收和分发机制分析》</a></blockquote><p>定义：为了易于理解，以下『Excel 数据』均指 Excel 的全部有效单元格转为 JSON 格式后的数据。<p>最容易处理的无疑是第三点，手动将不再需要的变量及时设置为 <code>null</code>。但这效果并不明显。<p>后来，通过系统的『活动监视器』对该工具的每阶段（打开时、导入文件时、筛选时和导出时）进行粗略的内存分析，得到以下报告（之前分析的、未作修改）：<p>---------------- S：报告分割线 ---------------- 经观察，主要耗内存的是<strong>页面进程</strong>。下面通过截图说明：<br><code>PID 15243</code> 是主进程<br><code>PID 15246</code> 是页面渲染进程<br><code>PID 15248</code> 是 background 渲染进程<p>a、首次启动程序时（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）<p><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/neicun1.png alt=启动程序时><p>b、导入文件（第 5 行是主进程；第 2 行是页面渲染进程；第 4 行是 background 渲染进程 ）<br><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/neicun2.png alt=导入文件时><p>c、筛选数据（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）<br><img src=//misc.aotu.io/JChehe/2016-11-15-xcel/neicun3.png alt=筛选数据时><p>由于 JS 目前不具有主动回收资源的功能，所以只能主动将对象设置为 <code>null</code>，然后等待 GC 回收。<p>因此，经过一段时间等待后，内存占用如下：<br>d、一段时间后（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） <img src=//misc.aotu.io/JChehe/2016-11-15-xcel/neicun4.png alt=一段时间后><p>由上述可得，页面渲染进程由于页面元素和 Vue 等 UI 相关资源是固定的，占用内存较大且不能回收。主进程占用资源也不能得到很好释放，暂时不知道原因，而 background 渲染进程则较好地释放资源。<p>---------------- E：报告分割线 ----------------<p>根据报告，初步得出的结论是 Vue 和通讯时占用资源较大。<p>根据该工具的实际应用场景：由于 Excel 数据只在『导入』和『过滤后』两个阶段需要展示，而且展示的只是通过 JavaScript 拼接的 HTML 字符串构成的 DOM 而已。因此将表格数据放置在 Vuex 中，有点滥用资源的嫌疑。<p>另外，在 <code>background process</code> 中也有存有一份 Excel 数据副本。因此，索性只在 <code>background process</code> 存储一份 Excel 数据，然后每当数据变化时，通过 IPC 让 <code>background process</code> 返回拼接好的 HTML 字符串即可。这样一来，内存占有量立刻下降许多。而且这也是一个一举多得的优化：<ol><li>字符串拼接操作也转移到了 <code>background process</code>，页面的渲染进程进一步减少耗时的操作；<li>内存占有量大大减小，响应速度也得到了提升。</ol><p>其实，这也有点像 Vuex 的『全局单例模式管理』，一份数据就好。<p>当然，对于 Excel 的基本信息，如行列数、SheetName、标题组等均依然保存在 Vuex。<p>优化后的内存占有量如下图。与上述报告的第三张图相比（同一阶段），内存占有量下降了 44.419%： <img src=//misc.aotu.io/JChehe/2016-11-15-xcel/neicun5.png alt=优化后内存占有量><br>另外，对于不需要响应的数据，可通过 <code>Object.freeze()</code> 冻结起来。这也是一种优化手段。但该工具目前并没有应用到。<p>至此，优化部分也阐述完毕了！<hr><p>该工具目前是开源的，欢迎大家使用或推荐给用研组等有需要的人。<p>你们的反馈（可提交 <a href=https://github.com/o2team/xcel/issues>issues</a> / <a href=https://github.com/o2team/xcel/pulls>pull request</a>）能让这个工具在使用和功能上不断完善。<p>最后，感谢 <a href=https://github.com/mamboer>LV</a> 的产品规划、界面设计和优化上的强力支持。全文完！]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>漫漫编程路上必读的7本书</title>
      <link>https://aotu.io/notes/2016-11-15/booklist-for-every-programmer</link>
      <guid>https://aotu.io/notes/2016-11-15/booklist-for-every-programmer</guid>
      <pubDate>2016-11-14T16:21:43.000Z</pubDate>
      <description>
      
        7本对提升程序员编程思想、软件工程理论大有裨益的通用读物，不分专业，不分语言，不分排名先后。
      
      </description>
      
      <content:encoded><![CDATA[<p>7本对提升程序员编程思想、软件工程理论大有裨益的通用读物，不分专业，不分语言，不分排名先后。<h2 id=code-complete>Code Complete</h2><p>中文版叫『代码大全』，两届SoftwareJolt Award震撼大奖得主，一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。<p><a href=http://item.jd.com/11902952.html><img src=//misc.aotu.io/o2/img/books/code-complete-2.jpg alt="Code Complete"></a><p>谷歌度娘搜关键字「程序员必读书本」的结果统计，这本书是最多人推荐的，近年宣称为「最值得程序员阅读的首本书，也是建议程序员推荐给身边小伙伴的首本书」。<p>想读的朋友可以到我东东家购买，<ol><li><a href=http://item.jd.com/11902952.html>代码大全（第2版 英文版）</a><li><a href=http://item.jd.com/10875285.html>代码大全（第2版 中文版）</a></ol><h2 id=the-pragmatic-programmer-from-journeyman-to-master>The Pragmatic Programmer - From Journeyman to Master</h2><p>中文版叫『程序员修炼之道-从小工到专家』。<p><a href=http://item.jd.com/1092761685.html><img src=//misc.aotu.io/o2/img/books/pragmatic.jpg alt="The Pragmatic Programmer"></a><p>原版略贵但绝对值的一读，它充满了关于如何改进程序员本身和代码本身的实用建议。<p>想读的朋友依然可以到我东东家购买，原版有<code>每满100减30</code>的活动。<ol><li><a href=http://item.jd.com/19735922.html>程序员修炼之道 英文版）</a><li><a href=http://item.jd.com/10393278.html>程序员修炼之道（第2版 中文版）</a></ol><h2 id=the-mythical-man-month-essays-on-software-engineering>The Mythical Man-Month: Essays on Software Engineering</h2><p>有一个好的中文名叫『人月神话』。<p><a href=http://item.jd.com/1098651569.html><img src=//misc.aotu.io/o2/img/books/mythical-man-month.jpg alt="The Mythical Man-Month: Essays on Software Engineering"></a><p>引用东东家的一段广告语吧：<blockquote><p>图灵奖得主，IBM 360系统之父，作者Brooks颠覆了项目管理领域，长久不衰传奇著作！软件开发人员、软件项目经理、系统分析师等IT从业者必藏之软工圣经，畅销40年！赠国内实战体验精华册</blockquote><p>然后摘其中的两句经典：<blockquote><p>生一个孩子总是需要九个月的时间，不管安排多少个女性。 一个煎蛋，承诺在两分钟内完成，但如果两分钟后还是没有准备好，那么客户有两种选择——等待或吃半熟品，软件客户也只能这样选择。</blockquote><p>正从标题中所说的那样，这是一本关于软件工程的散文集，文辞优美。唯一的缺点就是引用了年迈的古老技术，但是，这并不影响这本书的魅力。<p>是时候入手一本经典书籍了：<ol><li><a href=http://item.jd.com/1098651569.html>人月神话 英文版）</a><li><a href=http://item.jd.com/11671959.html>人月神话（40周年中文纪念版）</a></ol><h2 id=structure-and-interpretation-of-computer-programs>Structure and Interpretation of Computer Programs</h2><p>中文名叫『计算机程序的构造和解释』，目测应该是一本计算机科学的科普读物。<p><a href=http://item.jd.com/1092771266.html><img src=//misc.aotu.io/o2/img/books/StructureandInterpretationofComputerPrograms.jpg alt="Structure and Interpretation of Computer Programs"></a><p>京东购买地址：<ol><li><a href=http://item.jd.com/1092771266.html>计算机程序的构造和解释 英文版）</a><li><a href=http://item.jd.com/10057478.html>计算机程序的构造和解释 原书第2版</a></ol><h2 id=head-first-design-patterns>Head First Design Patterns</h2><p>看着封面的妹子就想读的一本书，中文名叫『Head Frirst 设计模式』。<p><a href=http://item.jd.com/1105635805.html><img src=//misc.aotu.io/o2/img/books/head_first_design_pattern.jpg alt="Head First Design Patterns"></a><p>看上去最不像技术的编程书籍！<p>每个页面都包含涂鸦、图片以及其他一些吸引眼球的东西。<p>可能给人的印象是一本阅读起来很轻松的书，但事实上它会讨论编程的一些核心主题 —— 设计模式。<p>设计模式就是编程世界里的各种抽象的定理，而这本书有把它们画出来、具体化了的感觉。<p>畅销十年，累计印刷30余次，荣获2005年第十五届Jolt通用类图书震撼大奖！买买买！<ol><li><a href=http://item.jd.com/1105635805.html>Head Frirst 设计模式 英文版）</a><li><a href=http://item.jd.com/10100236.html>O'Reilly：Head First设计模式（中文版）</a></ol><h2 id=introduction-to-algorithms>Introduction to Algorithms</h2><p>中文名叫『算法导论』，这是今天介绍的几本书里面唯一一本关于「算法」的。<p><a href=http://item.jd.com/1092771686.html><img src=//misc.aotu.io/o2/img/books/algorithm.jpg alt="Introduction to Algorithms"></a><blockquote><p>超过50万人阅读的算法圣经！算法标准教材，国内外1000余所高校采用!</blockquote><p>京东购买地址：<ol><li><a href=http://item.jd.com/1092771686.html>算法导论 英文版）</a><li><a href=http://item.jd.com/11144230.html>算法导论（中文版）</a></ol><h2 id=the-clean-coder>The Clean Coder</h2><p>最后一本是关于程序员职业素养的书，中文名为『程序员的职业素养』。<p><a href=http://item.jd.com/1098533768.html><img src=//misc.aotu.io/o2/img/books/the-clean-coder.jpg alt="The Clean Coder"></a><p>该书探讨了一些程序员经常忽视的主题。<ul><li>成为专业的程序员意味着什么？<li>如何打磨自己成为一个真正的软件工匠？<li>冲突和紧张的日程处理<li>如何管理你的时间？如何扩张技能？<li>何时说“不”<li>避免倦怠<li>..以及更多。</ul><p>你可能并不总是同意作者的观点，但它提供了良好的精神食粮。这可能并非你所期望的，但可能正是你所需要的。<p>京东购买地址：<ol><li><a href=http://item.jd.com/1098533768.html>程序员的职业素养 英文版）</a><li><a href=http://item.jd.com/11083858.html>程序员的职业素养 中文版</a></ol><h2 id=参考资料>参考资料</h2><ol><li><a href=http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read>Stackoverflow: What is the single most influential book every programmer should read?</a><li><a href=https://blog.codinghorror.com/recommended-reading-for-developers/ >Recommended Reading for Developers</a><li><a href=https://jasonroell.com/2015/03/16/12-most-infuential-books-every-software-engineer-needs-to-read/ >12 Most Influential Books Every Software Engineer Needs to Read</a><li><a href=https://dzone.com/articles/must-read-book-list-for-programmers>10 Classic Books Every Serious Developer Should Read</a><li><a href=http://developer.51cto.com/art/201602/506510.htm>每个程序员应该阅读的10本经典书籍</a></ol>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>Webpack 实用配置技巧</title>
      <link>https://aotu.io/notes/2016-11-15/webpack-tips</link>
      <guid>https://aotu.io/notes/2016-11-15/webpack-tips</guid>
      <pubDate>2016-11-14T16:16:31.000Z</pubDate>
      <description>
      
        如果你准备在自己的生产项目中使用Webpack，本文肯定会对你有所帮助！
      
      </description>
      
      <content:encoded><![CDATA[<h3 id=前言>前言</h3><p><strong>Webpack做了什么</strong><p>一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。<p><strong>为什么选Webpack</strong><p>模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。<blockquote><p>例如：我在项目中使用Vue框架，在配置官方提供的loader后，就可以直接在js中依赖.vue后缀的单文件组件了。</blockquote><h3 id=上手>上手</h3><p><strong>安装</strong><ol><li>使用npm init命令来创建一个package.json文件<li><p>安装Webpack，推荐只安装在当前项目中作为依赖<p>npm install webpack --save</ol><p><strong>添加一个配置文件 webpack.config.js</strong><pre class=nust-code><code class="hljs dts">module.exports = {
<span class=hljs-symbol>    entry:</span> <span class=hljs-string>"./entry.js"</span>,
<span class=hljs-symbol>    output:</span> {
<span class=hljs-symbol>        path:</span> __dirname,
<span class=hljs-symbol>        filename:</span> <span class=hljs-string>"bundle.js"</span>
    },
<span class=hljs-symbol>    module:</span> {
<span class=hljs-symbol>        loaders:</span> [
            { test: /\.css$/, loader: <span class=hljs-string>"style!css"</span> }
        ]
    }
};</code></pre><p><strong>执行webpack命令</strong><blockquote><p>如果全局安装了Webpack的话,那么直接在当前项目执行webpack命令就可以依赖上述webpack.config.js文件中的配置，分析entry.js中的依赖，打包输出bundle.js</blockquote><p>我使用npm scripts来启动任务，在package.json中添加：<pre class=nust-code><code class="hljs clean">{
    ...
    <span class=hljs-string>"scripts"</span>: {
        <span class=hljs-string>"build"</span>: <span class=hljs-string>"NODE_ENV=production webpack --watch"</span>
    }
    ...
}</code></pre><p>执行npm run build。其中--watch参数表示持续的监听文件变化进行打包。<h3 id=入口文件配置>入口文件配置</h3><p><strong>配置多个入口文件</strong><pre class=nust-code><code class="hljs dts">module.exports = {
<span class=hljs-symbol>    entry:</span> {
<span class=hljs-symbol>        entry1_bundle:</span> <span class=hljs-string>"./entry1.js"</span>,
<span class=hljs-symbol>        entry2_bundle:</span> <span class=hljs-string>"./entry2.js"</span>
    },
<span class=hljs-symbol>    output:</span> {
<span class=hljs-symbol>        path:</span> __dirname,
<span class=hljs-symbol>        filename:</span> <span class=hljs-string>"[name].js"</span>
    },
<span class=hljs-symbol>    module:</span> {
<span class=hljs-symbol>        loaders:</span> [
            { test: /\.css$/, loader: <span class=hljs-string>"style!css"</span> }
        ]
    }
};</code></pre><p>在这个配置文件中有两个入口文件，输出的时候[name]会被替换为入口中配置的entry1_bundle和entry2_bundle<p><strong>使用glob方式配置</strong><pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>'path'</span>),
      glob = <span class=hljs-built_in>require</span>(<span class=hljs-string>'glob'</span>)  <span class=hljs-comment>//需安装glob模块依赖</span>

  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getEntries</span> (<span class=hljs-params>globPath</span>) </span>{
  <span class=hljs-keyword>var</span> files = glob.sync(globPath);
  <span class=hljs-keyword>var</span> _entries = {}, entry, dirname, basename;

  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; files.length; i++) {
      entry = files[i];
      dirname = path.dirname(entry);
      basename = path.basename(entry, <span class=hljs-string>'.js'</span>);
      _entries[path.join(dirname, basename)] = <span class=hljs-string>'./'</span> + entry;
  }
  <span class=hljs-keyword>return</span> _entries;
  }</code></pre><p>执行getEntries('*.js')就会遍历到目录下全部的js文件做为入口文件配置。<h3 id=使用插件>使用插件</h3><p>目前我有用到三个插件：CommonsChunkPlugin，UglifyJsPlugin，以及一个我自己定义的插件<pre class=nust-code><code class="hljs java"><span class=hljs-keyword>module</span>.<span class=hljs-keyword>exports</span> = {
    <span class=hljs-comment>// plugins 字段传入一个数组，里面是实例化后的各种插件</span>
    plugins: [<span class=hljs-keyword>new</span> webpack.optimize.CommonsChunkPlugin({
          name: <span class=hljs-string>'vendor'</span>,
          minChunks: <span class=hljs-number>3</span>
    }),
    <span class=hljs-keyword>new</span> webpack.optimize.UglifyJsPlugin([options]),

    ...
    ],
    entry: {
        entry1_bundle: <span class=hljs-string>"./entry1.js"</span>,
        entry2_bundle: <span class=hljs-string>"./entry2.js"</span>
    },
    ...
};</code></pre><p><strong>提取公用资源</strong><p>为了便于使用缓存，我通过CommonsChunkPlugin这个插件将公用部分提取出来。<p>上述配置会自动的将被3个及以上入口文件引用的资源提取出来到一个新的文件vendor.js中。我们通常不希望公用的内容发生不预知的变化，这样配置就可以将希望提取出来的内容显性的配置在config文件中：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-tag>entry</span>: {
  <span class=hljs-attribute>vendor</span>: [<span class=hljs-string>"vue"</span>, <span class=hljs-string>"other-lib"</span>],
  ...
}
<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>CommonsChunkPlugin</span>({
  <span class=hljs-attribute>name</span>: <span class=hljs-string>"vendor"</span>,
  // 将minChunks设置为无穷大，就不会有不期望的内容进入vendor了
  minChunks: Infinity,

})</code></pre><p><strong>只在生产环境下启用UglifyJs插件</strong><pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-tag>var</span> plugins = [new webpack<span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>([options])]
<span class=hljs-comment>// npm scripts 配置的参数可以用上了</span>
<span class=hljs-function><span class=hljs-title>if</span><span class=hljs-params>(process.env.NODE_ENV == <span class=hljs-string>'production'</span>)</span></span>{
  plugins.push(new webpack<span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.UglifyJsPlugin</span>({
    compress: {
      warnings: false
    }
  }))
}</code></pre><p>关于UglifyJs的使用就不介绍了，参考<a href=https://github.com/mishoo/UglifyJS2#usage>UglifyJS2</a>。<p><strong>自定义插件</strong><p>Webpack提供的插件已足够使用，不过针对不同的业务，我们可能需要定制一些功能，例如我所定制的功能就是在编译资源的同时生成一份用于上传到服务器的md5版本号配置文件。<p>来一个简单的小栗子，如何开始写一个Webpack插件：<pre class=nust-code><code class="hljs actionscript">  <span class=hljs-keyword>var</span> chunkCombo = <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span></span>{};
      chunkCombo.prototype.apply = <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>(compiler, callback)</span></span>{
    compiler.plugin(<span class=hljs-string>"emit"</span>, <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>(compilation, callback)</span></span>{
        compilation.chunks.map(<span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>(chunk, key)</span></span>{

          <span class=hljs-keyword>var</span> filename = chunk.name + <span class=hljs-string>'.shtml'</span>;
          <span class=hljs-keyword>var</span> content = chunk.hash.slice(<span class=hljs-number>0</span>,<span class=hljs-number>8</span>);

          <span class=hljs-comment>// 生成一个对应的新文件存储md5值</span>
          compilation.assets[filename] = {
            source: <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span> </span>{
                <span class=hljs-keyword>return</span> content;
              },
              size: <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span> </span>{
                <span class=hljs-keyword>return</span> Buffer.byteLength(content, <span class=hljs-string>'utf8'</span>) 
              }
          };
        })
        callback();
    });
      }</code></pre><p>随着项目的深度定制和优化，我们可能需要开发更多的插件。<h3 id=配置loaders>配置loaders</h3><p>有了无所不能的加载器，Webpack可以处理任何类型的静态文件<pre class=nust-code><code class="hljs groovy">module.exports = {
<span class=hljs-symbol>  entry:</span> {
<span class=hljs-symbol>    entry1_bundle:</span> <span class=hljs-string>"./entry1.js"</span>,
<span class=hljs-symbol>    entry2_bundle:</span> <span class=hljs-string>"./entry2.js"</span>
  },
<span class=hljs-symbol>  output:</span> {
<span class=hljs-symbol>      path:</span> __dirname,
<span class=hljs-symbol>      filename:</span> <span class=hljs-string>"[name].js"</span>
  },
<span class=hljs-symbol>  module:</span> {
<span class=hljs-symbol>      loaders:</span> [
        { <span class=hljs-string>test:</span> <span class=hljs-regexp>/\.vue$/</span>, <span class=hljs-string>loader:</span> <span class=hljs-string>'vue-loader'</span> },
        { <span class=hljs-string>test:</span> <span class=hljs-regexp>/\.css$/</span>, <span class=hljs-string>loader:</span> <span class=hljs-string>'style-loader!css-loader'</span> },
        { <span class=hljs-string>test:</span> <span class=hljs-regexp>/\.js$/</span>, <span class=hljs-string>exclude:</span> <span class=hljs-regexp>/node_modules/</span>, <span class=hljs-string>loader:</span> <span class=hljs-string>"babel-loader"</span>},
        <span class=hljs-comment>//加载器之间用！连接，-loader可以省略不写</span>
        { <span class=hljs-string>test:</span> <span class=hljs-regexp>/\.scss$/</span>, <span class=hljs-string>loader:</span> <span class=hljs-string>'style!css!sass?sourceMap'</span>},
        { <span class=hljs-string>test:</span> <span class=hljs-regexp>/\.(png|jpg)$/</span>, <span class=hljs-string>loader:</span> <span class=hljs-string>'url-loader?limit=8192'</span>}
      ]
  }
  };</code></pre><p>加载器使用前记得先通过npm安装对应的模块，并将依赖添加到package.json文件中，例如：<pre class=nust-code><code class="hljs sql">    npm <span class=hljs-keyword>install</span> vue-loader <span class=hljs-comment>--save</span></code></pre><ul><li>vue-loader用于解析.vue单文件组件。<li>有了babel-loader就可以直接使用新的语法特性了。Babel的配置参见<a href=http://babeljs.io/docs/setup/#installation>Using Babel</a></ul><h3 id=使用webpack-dev-server>使用webpack-dev-server</h3><p>webpack-dev-server是一个轻量的node.js Express服务，通过Socket.IO来实时的通知客户端Webpack编译状态。 安装webpack-dev-server模块，此处不再重复，直接看配置文件：<pre class=nust-code><code class="hljs dts">module.exports = {
<span class=hljs-symbol>  entry:</span> {
<span class=hljs-symbol>    entry1_bundle:</span> <span class=hljs-string>"./entry1.js"</span>,
<span class=hljs-symbol>    entry2_bundle:</span> <span class=hljs-string>"./entry2.js"</span>
  },
<span class=hljs-symbol>  output:</span> {
<span class=hljs-symbol>        path:</span> __dirname,
<span class=hljs-symbol>        filename:</span> <span class=hljs-string>"bundle.js"</span>
    },
  ...
<span class=hljs-symbol>  devServer:</span> {
      <span class=hljs-comment>// serve 的根目录</span>
<span class=hljs-symbol>    contentBase:</span> _contentBase,
<span class=hljs-symbol>    port:</span> <span class=hljs-number>9000</span>,
    <span class=hljs-comment>// iframe模式和inline模式可选</span>
<span class=hljs-symbol>    inline:</span> true，
    ...
  }
  };</code></pre><p>在package.json中添加：<pre class=nust-code><code class="hljs clean">{
      ...
      <span class=hljs-string>"scripts"</span>: {
        <span class=hljs-string>"dev"</span>: <span class=hljs-string>"NODE_ENV=dev webpack-dev-server"</span>
      }
      ...
}</code></pre><p>执行npm run dev 命令后，服务就启动了。访问<a href="">http://localhost:9000</a>，就可以看到你的应用了。<p><strong>定制Express路由</strong><p>在inline模式下，需要手动的将用于更新的的脚本引入到页面中：<pre class=nust-code><code class="hljs javascript"><span class=hljs-built_in>module</span>.exports = {
  <span class=hljs-attr>entry</span>: {
    <span class=hljs-attr>entry1_bundle</span>: <span class=hljs-string>"./entry1.js"</span>,
    <span class=hljs-attr>entry2_bundle</span>: <span class=hljs-string>"./entry2.js"</span>
  },
  <span class=hljs-attr>output</span>: {
        <span class=hljs-attr>path</span>: __dirname,
        <span class=hljs-attr>filename</span>: <span class=hljs-string>"bundle.js"</span>
    },
  ...
  devServer: {
      <span class=hljs-comment>// serve 的根目录</span>
    contentBase: _contentBase,
    <span class=hljs-attr>port</span>: <span class=hljs-number>9000</span>,
    <span class=hljs-comment>// iframe模式和inline模式可选</span>
    inline: <span class=hljs-literal>true</span>,
    <span class=hljs-attr>setup</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>app</span>) </span>{
      app.use(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>req, res, next</span>) </span>{
        <span class=hljs-comment>//...</span>
        <span class=hljs-keyword>return</span> next();
      });
      app.get([<span class=hljs-string>'*.shtml'</span>,<span class=hljs-string>'*.html'</span>], <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>req, res, next</span>) </span>{
        <span class=hljs-comment>//...</span>

        <span class=hljs-comment>//将实时更新的脚本引入到页面中</span>
        res.end(<span class=hljs-string>'&lt;script src="http://localhost:9000/webpack-dev-server.js">&lt;/script>'</span>)
      })
    }
  }
  };</code></pre><p>关于Express路由的使用，参考<a href=http://expressjs.com/en/guide/routing.html>Express Routing</a><p>在我的项目中，我希望HTML页面在开发环境下和服务器环境下保持一致，因此我在devServer中配置了对HTML页面的解析。<p><strong>以上，希望我的Webpack项目配置能对你解决相关问题的时候有所帮助和启发。</strong><h3 id=参考资料>参考资料</h3><ul><li><a href=http://webpack.github.io/docs/ >Webpack docs</a><li><a href=http://expressjs.com/en/guide/routing.html>Express Routing</a><li><a href="https://aotu.io/notes/2016/02/26/use-npm-script-instead-of-gulp/?utm_source=tuicool&utm_medium=referral">使用npm scripts替代gulp</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>WeUI for 小程序 - 为微信小程序量身设计</title>
      <link>https://aotu.io/notes/2016-11-11/weui-wxss</link>
      <guid>https://aotu.io/notes/2016-11-11/weui-wxss</guid>
      <pubDate>2016-11-10T17:21:43.000Z</pubDate>
      <description>
      
        WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>官人你没有走错地方，「WeUI」正式开始支持小程序啦，这是新鲜火辣的、微信官方设计团队为微信小程序量身设计的「WeUI-WXSS」。</blockquote><h2 id=概述>概述</h2><p><a href=https://github.com/weui/weui>WeUI</a> 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含<code>button</code>、<code>cell</code>、<code>dialog</code>、 <code>progress</code>、 <code>toast</code>、<code>article</code>、<code>actionsheet</code>、<code>icon</code>等各式元素。<h2 id=视觉标准>视觉标准</h2><p><a href=https://github.com/weui/weui-design>weui-design</a><h2 id=预览>预览</h2><p>用微信web开发者工具打开dist目录<p><a href=https://weui.io/ target=_blank><img src=https://misc.aotu.io/o2/img/weui-demo.png alt=preview></a><h2 id=使用>使用</h2><ul><li>组件的wxml结构请看<code>dist/example/</code>下的组件<li>样式文件可直接引用<code>dist/style/weui.wxss</code>，或者单独引用<code>dist/style/widget</code>下的组件的<code>wxss</code></ul><h2 id=license>License</h2><p>The MIT License(<a href=http://opensource.org/licenses/MIT>http://opensource.org/licenses/MIT</a>)<p>请自由地享受和参与开源<h2 id=贡献>贡献</h2><p>如果你有好的意见或建议，欢迎给我们提<a href=https://github.com/weui/weui-wxss/issues>issue</a>或pull request，为提升微信web体验贡献力量。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>轻氧 - 2016年末最新款互联网专业资讯 APP</title>
      <link>https://aotu.io/notes/2016-11-09/liteo2-app</link>
      <guid>https://aotu.io/notes/2016-11-09/liteo2-app</guid>
      <pubDate>2016-11-09T14:21:43.000Z</pubDate>
      <description>
      
        「轻氧」是一款专门为互联网从业人士打造的资讯应用，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一次把业界最优质的文章读完。凹凸实验室出品。
      
      </description>
      
      <content:encoded><![CDATA[<p>又是一年的双11，大家都在割肾剁手<code>买买买</code>，我们凹凸实验室「阿尔法APP突击队」在抖腿<code>码码码</code>。 抬价而后打折促销的商家都TMD是<a href=https://movie.douban.com/subject/1438652/ target=_blank>《无耻的混蛋》<sup>昆丁.2009</sup></a>，而我们只做良心的促销：<h2 id=一款免费实用开源的app>一款免费实用开源的APP</h2><p><a href=//app.aotu.io>轻氧</a> 是 <a href=//aotu.io>凹凸实验室</a> 一不留神上架了的一款<strong>互联网技术资讯APP</strong>，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的文章读完，只要你愿意。<p>其实市面上互联网技术资讯这块领域已经有非常多优秀的产品了，例如<a href=https://toutiao.io/ >开发者头条</a>，又如后来居上者 <a href=http://gold.xitu.io/ >掘金</a>，类似产品之间的竞争异常剧烈，举步唯艰，再做一款类似内容的APP的意义到底有多少，而成功的概率又有多少？<p>我们曾经纠结过这些问题，但后来觉得这些纠结有点傻~ 做轻氧的『初心』本来就不是超越，而是在积累和探索。<p>从业务的层面来看，是为团队积累和探索一款APP从零到设计到上架的整个流程，为下一次（如果有的话）APP研发需求做好流程和技术上的准备。<p>从专业技术的层面来看，我们是在努力拓宽自己的专业范畴，要知道凹凸这个团队的前身是前端团队，相对匮乏原生应用开发经验，如果团队技术的努力方向是多终端技术体系，是全栈，那末轻氧APP则是印证我们朝这个方向发展、具备全栈开发综合能力的结果。<p>我们像是在练武，轻氧是我们自创的一门渐进式的武学，谁都无法断言它的厉害与否，因为主创们在不断的努力摸索和改进。<p>我们没有忘记O2的口号是：Open Oriented，所以「轻氧」年后将会开源，并配套一本总结整个APP项目从零到上架的书籍，记录着轻氧从无到有的套路和心法。希望能帮助到那些想了解和掌握Swift编程、Sketch设计、以及数据库架构及设计相关技能的同学们。<p>授之以鱼不如授之以渔，为「轻氧」存在的最大意义。<blockquote><p>源码届时将托管在<a href=https://github.com/o2team/app>github.com/o2team/app</a>，欢迎抢先点赞订阅更新。</blockquote><h2 id=致潜在的用户>致潜在的用户</h2><p>「轻氧」适合什么样的你呢？<p>如果你是辣么专情的：<p><strong>程序员、设计师、产品经理、运营、用研。</strong><p>但又不失滥情的闷骚：<p><strong>喜欢搞搞数码搞机、喜欢新鲜应用、脑袋发热准备创业。</strong><p><strong>那么，这款资讯 App 就是专门为你设计的。</strong><p>我们为互联网人士准备了多个专业资讯频道，将优质资讯分类呈现。<p>你可以根据需要选择你喜欢的频道来定制APP的内容。<p>目前已开通 <strong>11 个资讯频道</strong> （一些好玩的频道正在筹备中）：<p><img src=http://storage.360buyimg.com/mtd/home/artboard-copy1478671835326.png width=700px><p>总之，「轻氧」旨在帮你严肃地提升学术、视界的同时，也可以让你开个小差去猎奇酷玩，嘿嘿。<h2 id=丰富的资讯源>丰富的资讯源</h2><p>关于APP的内容源，除了凹凸实验室原创资讯外，<p>我们精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。<p>我们搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。<p>经过一段时间的耕耘，目前已有超过 <strong>4k 篇资讯</strong>，来自于 <strong>40+ 资讯来源</strong>：<p><img src=http://storage.360buyimg.com/mtd/home/origins_2-1-1478676025006.png width=450px><p>未来，我们还将在保证高质量文章的基础上，聚合更多的来源。<h2 id=看你喜欢看的>看你喜欢看的</h2><p>就像其它资讯平台一样，「轻氧」的每篇文章也被打上了标签。 用户可以根据标签或者来源，能筛选出自己喜欢的内容，定制个性化的时间线。<p><img src=https://storage.360buyimg.com/mtd/home/21478279294465.jpeg width=375px><h2 id=技术驱动研发>技术驱动研发</h2><p>与一般的资讯 APP 不同的是，这是一款「技术驱动」的APP，它的诞生源于「工科男」心底纯粹的技术欲望，尽管主创之一是兽医出身。<p>于是两三个技术工程师包揽了从产品构思、基于 Flinto 的原型交互、基于 Sketch 的视觉设计（除了LOGO为一个视觉美眉支持外）、基于 Swift3.x 的编码实现，当然还有 LeanCloud 数据服务的应用，Linux 服务器运维，以及应用上架部署的所有工作。<p>这肯定不是一款完美的产品，但我们在不停的迭代完善。<p>为了进一步提升APP的整体体验、提升我们工程师在跨专业领域的专业度，下一个大版本计划会邀请专业的交互设计师、视觉设计师参与进来。<h2 id=实验性的ui交互>实验性的UI交互</h2><p>在「轻氧」APP里面，我们无所不能为，实验了一些我们YY觉得酷的体验，例如阅读进度记录、卡片频道。 尽管新奇不一定是最合适的，但还是期待能给使用「轻氧」的你带来不一样的资讯阅读体验。<p><img src=https://storage.360buyimg.com/mtd/home/11478278904373.jpeg width=375px><h2 id=尝鲜下载体验>尝鲜下载体验</h2><blockquote><p>目前仅提供ios版本 基于 React Native 的 Android 版与网页版正在紧急开发中，敬请期待。</blockquote><p>官网地址： <a href=https://app.aotu.io target=_blank>https://app.aotu.io</a><p>下载地址： <a href="https://jdc.jd.com/lab/redirect_app.html?ADTAG=o2.site.app"title=下载试用 class="btn btn-greyline btn-mobile-full"><img src=http://storage.360buyimg.com/mtd/home/appstorelogo1478670585078.jpg alt=下载试用「轻氧」 width=250px></a><p>扫二维码：<p><a href="https://jdc.jd.com/lab/redirect_app.html?ADTAG=o2.site.app"title=轻氧二维码 class="btn btn-greyline btn-mobile-full"><img src=https://misc.aotu.io/o2/img/app/qrcode.png alt=轻氧二维码 width=250px></a><p>问题反馈：<ul><li>「凹凸实验室」公众号 (AOTULabs)<li>APP 个人中心 -> 设置 -> 意见反馈</ul><p>希望在这个信息爆炸的时代，「轻氧」能够帮助你<strong>聚焦更优质的资讯内容</strong>。 也让你更加专注于用心被创造出来的文章，和其创造者。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>深入了解font-weight</title>
      <link>https://aotu.io/notes/2016-11-09/css3fontweight</link>
      <guid>https://aotu.io/notes/2016-11-09/css3fontweight</guid>
      <pubDate>2016-11-08T16:34:58.000Z</pubDate>
      <description>
      
        font-weight的各个属性值有什么区别？浏览器如何渲染字重？
      
      </description>
      
      <content:encoded><![CDATA[<h2 id=问题提出>问题提出</h2><p>font-weight的属性值有100、200、300、400、500、600、700、800、900和normal、bold、lighter、bolder，它们的区别是？ 另外，在实际开发中，我们应该使用数值表达还是文字表达呢？<h2 id=认识font-weight>认识font-weight</h2><p>根据<a href=https://www.w3.org/html/ig/zh/wiki/CSS3%E5%AD%97%E4%BD%93%E6%A8%A1%E5%9D%97#.E5.AD.97.E4.BD.93.E7.B2.97.E7.BB.86.EF.BC.9A.E2.80.98font-weight.E2.80.99.E5.B1.9E.E6.80.A7>W3C Fonts节章的规范标准</a>，可知：<p><img src=//misc.aotu.io/Tingglelaoo/w3c_fontWeight.jpg alt=w3c_fontWeight.jpg><p>font-weight可取值：100～900和normal、bold、bolder、lighter。<h3 id=100-900-normal-bold>100～900、normal、bold</h3><p>如果字体使用九阶有序数值100～900来划分其字重(字体的粗细度)，那么样式指定的font-weight属性值与字体的字重则一一对应。并且normal等价于400，bold等价于700。 但实际上，我们一般遇到的字体很多时候都是使用一些通用的词描述划分其字重，如下所示。<p>常见的字重数值<strong>大致对应</strong>的字重描述词语：<ul><li>100 - Thin<li>200 - Extra Light (Ultra Light)<li>300 - Light<li>400 - Regular (Normal、Book、Roman)<li>500 - Medium<li>600 - Semi Bold (Demi Bold)<li>700 - Bold<li>800 - Extra Bold (Ultra Bold)<li>900 - Black (Heavy)</ul><blockquote><p>为什么说大致对应呢？在有些字库下是有差异的，比如在<a href=https://helpx.adobe.com/typekit/using/css-selectors.html>Adobe Typekit字库</a>中对字重描述的划分列表中，它列出Heavy指的是800而不是900。另外，在我们日常使用的Photoshop和Sketch里面，Ultra Light是100，而Thin是200。</blockquote><p>并且，字体所拥有的字重的数量实际上很少存在满足有9个字重刚好跟100～900的CSS字重一一对应的情况，通常字体拥有的字重数量为4至6个。 不必担心，起码400和700对应的字重至少是每种字体必备的，譬如常见的 Arial、Helvetica、Georgia等等，只有400(normal)和700(bold)。<h3 id=bolder-lighter>bolder、lighter</h3><p>bolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。<p>其值通常是根据下表计算而得的：<table><thead><tr><th>继承值（Inherited value）<th style=text-align:center>bolder所代表的字重<th style=text-align:center>lighter所代表的字重<tbody><tr><td>100<td style=text-align:center>400<td style=text-align:center>100<tr><td>200<td style=text-align:center>400<td style=text-align:center>100<tr><td>300<td style=text-align:center>400<td style=text-align:center>100<tr><td>400<td style=text-align:center>700<td style=text-align:center>100<tr><td>500<td style=text-align:center>700<td style=text-align:center>100<tr><td>600<td style=text-align:center>900<td style=text-align:center>400<tr><td>700<td style=text-align:center>900<td style=text-align:center>400<tr><td>800<td style=text-align:center>900<td style=text-align:center>700<tr><td>900<td style=text-align:center>900<td style=text-align:center>700</table><h2 id=字体匹配算法>字体匹配算法</h2><p>在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。<p>此时，就会<strong>出现样式指定的字重数值在字体中找不到直接对应的字重</strong>，那浏览器是如何解决的呢？<p>Bingo！ 那就是<strong>要靠<a href=https://www.w3.org/TR/css-fonts-3/#font-matching-algorithm>字体匹配算法</a>来解决</strong>。其中关于font-weight部分是这么提及到的：<p><img src=//misc.aotu.io/Tingglelaoo/fontMatching.jpg alt=fontMatching.jpg><p>讲人话就是： 如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染：<ul><li>如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。<li>如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。<li>如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。<li>如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行<strong>第一条所需字重小于400的规则</strong>（感谢@浅夏莜韵的指正）。</ul><blockquote><p>感谢来自@何洋的补充： 大多数浏览器已实现font-synthesis属性，使用该属性可以控制在font-weight没有相匹配的font typeface时，会模拟计算出合适的渲染字重(与其应有的typeface有些差异)，从而忽略Font Matching Algorithm。 参考文章：<ul><li><a href=https://www.w3.org/TR/REC-CSS2/fonts.html#algorithm>Fonts－字体匹配算法第5条</a><li><a href=https://developer.mozilla.org/en/docs/Web/CSS/font-synthesis>MDN－font-synthesis</a></ul></blockquote><h3 id=理解与运用>理解与运用</h3><p>下面我们通过官方例子和实际测试来好好理解这个匹配算法规则。<h4 id=官方例子>官方例子</h4><p>W3C规范标准中给出这么一个例子：<p><img src=//misc.aotu.io/Tingglelaoo/font_matching_examples.jpg alt=font_matching_examples.jpg><p><em>注解：灰色标记的是字体中缺少的字重，而黑色则是字体拥有的字重。</em><p>基于匹配算法规则，看图理解所得： Figure 15.图指的是<table><thead><tr><th>字体库内直接匹配的字重<th style=text-align:center>填空值(即通过算法间接匹配所得字重)<tbody><tr><td>400<td style=text-align:center>300、200、100、500<tr><td>700<td style=text-align:center>600<tr><td>900<td style=text-align:center>800</table><p>拿<code>font-weight: 300;</code>来说，字体中没有可以直接匹配的字重，那么300小于400，则根据第一条规则，先降序查找匹配，但是都没有可匹配的200、100，那么升序查找为400，结果可匹配。<p>Figure 16.图指的是<table><thead><tr><th>字体库内直接映射的字重<th style=text-align:center>填空值<tbody><tr><td>300<td style=text-align:center>200、100、400、500<tr><td>600<td style=text-align:center>700、800、900</table><p>这里需要注意的是，填空值500表现的是300的字重，而不是600的字重。 为什么呢？根据规则，500优先匹配400的字重，但是此处找不到400的字重，则执行规则中第一条所需字重小于400的情况。<p>其余的，我就不多解释了，大家可以根据结果检查自己是否理解到位。<h4 id=实际测试-droid-sans>实际测试——Droid Sans</h4><p><img src=//misc.aotu.io/Tingglelaoo/googlefonts.jpg alt=googlefonts.jpg><p>根据<a href="https://fonts.google.com/?query=droid">Google Fonts API - Droid Sans</a>提供的Droid Sans字体，我们可以知道该字体拥有两种字重。<p>根据字体匹配算法规则，我们可以预测其字重匹配应该如下表所示：<table><thead><tr><th>字体库内直接映射的字重<th style=text-align:center>填空值<tbody><tr><td>400<td style=text-align:center>300、200、100、500<tr><td>700<td style=text-align:center>600、800、900</table><p>也就是100、200、300、500会表现为跟400同一种字重，600、800、900会表现为跟700同一种字重。<p>利用Google Fonts提供的Droid Sans，我们进行了实例测试－(<a href=http://jdc.jd.com/demo/ting/DroidSans.html>DroidSans.html</a>)来验证。 结果如下图，证明我们的预测结果正确，该字体匹配算法规则运行有效。<p><img src=//misc.aotu.io/Tingglelaoo/droid_sans_res.jpg alt=droid_sans_res.jpg><h2 id=总结>总结</h2><p>根据以上的研究，可以总结出三点：<ol><li><p>通常情况下，一个特定的字体仅会包含少数的可用字重。<strong>若所指定的字重不存在直接匹配，则会通过字体匹配算法规则匹配使用邻近的可用字重。</strong>这也就是为什么我们有时候使用特定字重时没有“生效”，看起来跟其它字重差不多的原因所在。<li><p>在实际中，最为常用的字重是normal和bold。<strong>我个人认为400、700是等效于normal、bold的，无论哪一种表示方法都没有关系，主要是个人习惯问题。</strong><li><p>但是，<strong>推荐使用数值替代lighter、bolder</strong>，因为这涉及到继承计算的问题，用数值的话则会更为清晰明了。</ol><blockquote><p>参考资料： <a href=https://www.w3.org/TR/CSS21/fonts.html#font-boldness>W3C－字体</a> <a href=https://www.w3.org/TR/css-fonts-3/#font-matching-algorithm>W3C－字体匹配算法</a></blockquote>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>我的第一次移动端页面制作 — 总结与思考</title>
      <link>https://aotu.io/notes/2016-11-09/first-mobile-rebuild</link>
      <guid>https://aotu.io/notes/2016-11-09/first-mobile-rebuild</guid>
      <pubDate>2016-11-08T16:22:23.000Z</pubDate>
      <description>
      
        第一次上路，学习很多...
      
      </description>
      
      <content:encoded><![CDATA[<p>最近被分配到移动端开发组，支持某活动的页面页面制作。这算是我第一次真正接触移动端页面制作，下面就谈谈个人总结和思考。<h2 id=整体流程>整体流程</h2><p>开会大体讲解、讨论与排期 -> 交互设计 -> 视觉设计 -> 页面页面制作 -> 前端开发 -> 测试<p>每个步骤环环相扣，每个职位都需要和其前后的人沟通协调。<p>测试遇到问题则会反馈到相应环节负责人。<p>当然，涉及的职位也不仅于此，还有法务同事审核内容是否符合当前法规等等。<h2 id=构建工具>构建工具</h2><h3 id=athena>Athena</h3><p>前端开发离不开构建工具，除了敲代码，其余都交给构建工具（如组件开发、CSS 兼容处理、图片 Base64、图片雪碧图和压缩处理等）。<br>在 <a href=https://athena.aotu.io/ >Athena</a> 中，文件层级结构如下：项目 project -> 模块 module（具体每个活动） -> 页面 page -> 部件 widget。<p>举例： 某项目 -> X、Y 活动 -> 预热页和高潮页 -> 头部、弹框等 widget。一般文件目录如下：<pre class=nust-code><code class="hljs haml">Xproject
    -<span class=ruby> gb (公共部分，如初始化样式和一些常用 widget)
</span>    -<span class=ruby> X活动
</span>        -<span class=ruby> page
</span>            -<span class=ruby> 预热页
</span>            -<span class=ruby> 高潮页
</span>        -<span class=ruby> widget
</span>            -<span class=ruby> header
</span>            -<span class=ruby> footer
</span>            -<span class=ruby> diglog
</span>    -<span class=ruby> Y 活动
</span>    -<span class=ruby> ...</span></code></pre><p>刚开始接触时，存在这样的一个疑惑：什么是 widget，一个不可复用的页面头部可以作为 widget 吗？<br>答：我最初的想法是：“错误地把 widget 当成 component，component 一直被强调的 特性之一是<strong>可复用性</strong>。对于不可复用的部分就不应该抽出为一个widget了？”<strong>其实对于一个相对独立的功能，我们就可把它抽出来。</strong>这无疑会增强程序的可维护性。<p>对于一个项目，一般一个模块由一个人负责。但考虑到每个模块间可能存在（或未来存在）可复用的 widget，需要规范命名以形成命名空间，防止冲突（具体会在下面的规范-命名中阐述）。<blockquote><p>Component 与 Widget 的区别<br>Component 是更加广义抽象的概念，而Widget是更加具体现实的概念。所以Component的范围要比Widget大得多，通常 Component 是由多个 Widget 组成。 举个例子，可能不是很恰当，希望帮助你的理解，比如家是由床，柜子等多个 Component 组成，柜子是由多个抽屉 Widget 组成的。 而 Component 和 Widget 的目的都是为了模块化开发。</blockquote><p>其实，在这里并没有对 widget 和 component 做这么细的区分。<h2 id=规范>规范</h2><h3 id=widget>widget</h3><p>正如上面讨论的，一个页面由多个 widget 组成。因此，一个页面看起来如下：<pre class=nust-code><code class="hljs erb"><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>body</span> <span class=hljs-attr>ontouchstart</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"wrapper"</span>></span>
    <span class=hljs-comment>&lt;!-- S 主会场头部 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_main_header"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 主会场头部 --></span>
    <span class=hljs-comment>&lt;!-- S 达人问答区 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_answer"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 达人问答区 --></span>
    <span class=hljs-comment>&lt;!-- S 优惠券 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_coupons"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 优惠券 --></span>
    <span class=hljs-comment>&lt;!-- S 达人集中营 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_camp"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 达人集中营 --></span>
    <span class=hljs-comment>&lt;!-- S 达人穿搭公式 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_collocation"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 达人穿搭公式 --></span>
    <span class=hljs-comment>&lt;!-- S 卡券相关弹框 --></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>%=</span></span></span><span class=ruby> widget.load(<span class=hljs-string>"app_market_dialog"</span>) </span><span class=xml><span class=hljs-tag>%></span>
    <span class=hljs-comment>&lt;!-- E 卡券相关弹框 --></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></span></code></pre><p>widget 一般存在可复用性。但如何控制细粒度呢？分得越细代码就越简洁，但工作量和维护难度可能会上升，因此需要权衡你当时的情况。<h3 id=css-命名>CSS 命名</h3><h4 id=命名空间>命名空间</h4><p>由于一个项目中，一个模块由某一个人负责，但模块之间的 widget 存在或未来存在可复用的可能（而且开发可能会为你的页面添加已有的组件，如页面会嵌在某 APP 内，该 APP 已有现成的一些提示框）。因此，需要命名空间将其它们进行区分以防止冲突。由于 CSS 不存在命名空间，因此只能通过类似 BEM 的方式（具体根据团队的规范），如：<code>app_market_header</code>、<code>app_market_list_item</code>。<code>app_market</code> 是模块（即某个活动）的标识，在该项目下，它是唯一的。<p>另外，还有一点：类名是否要按照 html 层级关系层层添加呢？如：<pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-tag>div</span><span class=hljs-selector-class>.app_market_header</span>
    <span class=hljs-selector-tag>div</span><span class=hljs-selector-class>.app_market_header_icon</span>
    <span class=hljs-selector-tag>div</span>.app_market_header_**</code></pre><p>对于 <code>app_market_header_icon</code>，尽管在 header 中，但 icon 并不只属于 header，而属于整个模块（活动），那么我们就可以改为 <code>app_market_icon</code>。<h4 id=命名存在的问题>命名存在的问题</h4><p>老司机 Code review 后，讲了以下内容： 反面教材：<pre class=nust-code><code class="hljs applescript">&lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer"</span>>
  &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_secheader"</span>>&lt;/<span class=hljs-keyword>div</span>>
  &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_list"</span>>
    &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_item"</span>>
      &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_item_top"</span>>&lt;/<span class=hljs-keyword>div</span>>
      &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_item_middle"</span>>&lt;/<span class=hljs-keyword>div</span>>
      &lt;a href=<span class=hljs-string>"javascript:;"</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_item_bottom"</span>>去围观&lt;/a>
    &lt;/<span class=hljs-keyword>div</span>>
&lt;/<span class=hljs-keyword>div</span>></code></pre><p>存在的问题是：嵌套层级越深，类名就越长。<p>较好的解决方案：<pre class=nust-code><code class="hljs applescript">&lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer"</span>>
  &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_secheader"</span>>&lt;/<span class=hljs-keyword>div</span>>
  &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_list"</span>>
    &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_item"</span>>
      &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_itop"</span>>&lt;/<span class=hljs-keyword>div</span>>***
      &lt;<span class=hljs-keyword>div</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_imid"</span>>&lt;/<span class=hljs-keyword>div</span>>***
      &lt;a href=<span class=hljs-string>"javascript:;"</span> <span class=hljs-built_in>class</span>=<span class=hljs-string>"app_market_answer_ibtm"</span>>去围观&lt;/a>***
    &lt;/<span class=hljs-keyword>div</span>>
&lt;/<span class=hljs-keyword>div</span>></code></pre><p>这是基于『姓名』原理进行优化的，举例：<code>app_market_answer_item</code> 是姓名（库日天），那么它的子元素只需继承它的『姓』（库姆斯） <code>app_market_answer_itop</code>，而不是它的姓名（库日天姆斯） <code>app_market_answer_item_top</code>。每当类名达到三到四个单词长时，就要考虑简化名字。<p>进一步优化，app_market 可以看成是『复姓』，有时为了书写便利，可以以两个单词的首字母结合形成一个新的『新姓』- 『am』。当然，追求便利的副作用是牺牲了代码的可读性。如果你负责的项目或页面没有太大的二次维护或者交叉维护的可能性，推荐做此简化。<p>BTW：此简化后的『姓』可以在代码中稍加注释说明，如下代码所示：<pre class=nust-code><code class="hljs xml"><span class=hljs-comment>&lt;!-- am = app_market --></span>
<span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_secheader"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer_list"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer_item"</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer_itop"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer_imid"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
      <span class=hljs-tag>&lt;<span class=hljs-name>a</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"javascript:;"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"am_answer_ibtm"</span>></span>去围观<span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><h4 id=针对类名书写样式>针对类名书写样式</h4><pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>a</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"javascript:;"</span>></span>...<span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><p>至少加一个类名，任何时候都尽量要『针对类名书写样式，而不是针对元素书写样式』，除非你能预判元素是末级元素。<br>因此对于以下 CSS：<pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-class>.app_market_coupons</span> > <span class=hljs-selector-tag>div</span> {
    ...
}</code></pre><p>可优化成：<pre class=nust-code><code class="hljs stylus"><span class=hljs-selector-class>.app_market_coupons</span> > <span class=hljs-selector-class>.xxx</span> {
    ...
}</code></pre><h2 id=技术涉及>技术涉及</h2><h3 id=rem>REM</h3><p>移动端采用 rem 布局方式。通过动态修改 html 的 font-size 实现自适应。<h4 id=实现方式>实现方式</h4><p>REM 布局有两种实现方式：CSS 媒介查询和 JavaScript 动态修改。由于 JavaScript 更为灵活，因此现在更多地采用此方式。<h5 id=javascript>JavaScript</h5><p>凹凸的实现方式是：在 <code>head</code> 标签末加入以下代码<pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"text/javascript"</span>></span><span class=javascript>
    !<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
      <span class=hljs-keyword>var</span> maxWidth=<span class=hljs-number>750</span>;
      <span class=hljs-built_in>document</span>.write(<span class=hljs-string>'&lt;style id="o2HtmlFontSize">&lt;/style>'</span>);
      <span class=hljs-keyword>var</span> o2_resize=<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
          <span class=hljs-keyword>var</span> cw,ch;
          <span class=hljs-keyword>if</span>(<span class=hljs-built_in>document</span>&&<span class=hljs-built_in>document</span>.documentElement){
              cw=<span class=hljs-built_in>document</span>.documentElement.clientWidth,ch=<span class=hljs-built_in>document</span>.documentElement.clientHeight;
          }
          <span class=hljs-keyword>if</span>(!cw||!ch){
              <span class=hljs-keyword>if</span>(<span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-cw"</span>]&&<span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-ch"</span>]){
                  cw=<span class=hljs-built_in>parseInt</span>(<span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-cw"</span>]),ch=<span class=hljs-built_in>parseInt</span>(<span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-ch"</span>]);
              }<span class=hljs-keyword>else</span>{
                  chk_cw();<span class=hljs-comment>//定时检查</span>
                  <span class=hljs-keyword>return</span> ;<span class=hljs-comment>//出错了</span>
              }
          }

          <span class=hljs-keyword>var</span> zoom=maxWidth&&maxWidth&lt;cw?maxWidth/<span class=hljs-number>375</span>:cw/<span class=hljs-number>375</span>,zoomY=ch/<span class=hljs-number>603</span>;<span class=hljs-comment>//由ip6 weChat</span>
          <span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-cw"</span>]=cw,<span class=hljs-built_in>window</span>.localStorage[<span class=hljs-string>"o2-ch"</span>]=ch;
          <span class=hljs-comment>//zoom=Math.min(zoom,zoomY);//保证ip6 wechat的显示比率</span>
          <span class=hljs-built_in>window</span>.zoom=<span class=hljs-built_in>window</span>.o2Zoom=zoom;
          <span class=hljs-built_in>document</span>.getElementById(<span class=hljs-string>"o2HtmlFontSize"</span>).innerHTML=<span class=hljs-string>'html{font-size:'</span>+(zoom*<span class=hljs-number>20</span>)+<span class=hljs-string>'px;}.o2-zoom,.zoom{zoom:'</span>+(zoom/<span class=hljs-number>2</span>)+<span class=hljs-string>';}.o2-scale{-webkit-transform: scale('</span>+zoom/<span class=hljs-number>2</span>+<span class=hljs-string>'); transform: scale('</span>+zoom/<span class=hljs-number>2</span>+<span class=hljs-string>');} .sq_sns_pic_item,.sq_sns_picmod_erea_img{-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scale('</span>+zoom/<span class=hljs-number>2</span>+<span class=hljs-string>');transform: scale('</span>+zoom/<span class=hljs-number>2</span>+<span class=hljs-string>');}'</span>;
      },
      siv,
      chk_cw=<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
          <span class=hljs-keyword>if</span>(siv)<span class=hljs-keyword>return</span> ;<span class=hljs-comment>//已经存在</span>
          siv=setInterval(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{
              <span class=hljs-comment>//定时检查</span>
              <span class=hljs-built_in>document</span>&&<span class=hljs-built_in>document</span>.documentElement&&<span class=hljs-built_in>document</span>.documentElement.clientWidth&&<span class=hljs-built_in>document</span>.documentElement.clientHeight&&(o2_resize(),clearInterval(siv),siv=<span class=hljs-literal>undefined</span>);
          },<span class=hljs-number>100</span>);
      };
      o2_resize();<span class=hljs-comment>//立即初始化</span>
      <span class=hljs-built_in>window</span>.addEventListener(<span class=hljs-string>"resize"</span>,o2_resize);
  }();
  </span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><p>从以上代码可得出以下信息：<ol><li>以 iPhone 6 为基准，iPhone 6 的缩放比 <code>zoom</code> 为 <code>1</code><li>由于只针对移动端，因此最大宽度为768（恰好等于 iPad 的竖屏宽度）<li>通过 document.documentElement.clientWidth 获取视口宽度<li>resize 事件主要考虑横竖屏切换和你在PC上调试时🙃<li>zoom 系数是 20。系数决定了在宽度 375 的 iPhone6 下，1 rem 的值是多少 px（20px）。当然如果想过渡到 vw，可以将 zoom 系数设置为 3.75，那么 100rem 就是 375px 了</ol><h4 id=为什么要用>为什么要用</h4><p>有人说 rem 布局是 <code>vw</code> 和 <code>vh</code> 的替换方案，当 <code>vw</code> 和 <code>vh</code> 成熟时，两者可能会各司其职吧。<blockquote><p><a href="http://caniuse.com/#search=vw">vw 的兼容性</a>：在安卓 4.3 及以下是不支持的。</blockquote><h5 id=哪些地方要用>哪些地方要用</h5><p>由于 rem 布局是相对于视口宽度，因此任何需要根据屏幕大小进行变化的元素（width、height、position 等）都可以用 rem 单位。<p>但 rem 也有它的缺点——不精细（在下一节阐述），其实这涉及到了浏览器渲染引擎的处理。因此，对于需要精细处理的地方（如通过 CSS 实现的 icon），可以用 px 等绝对单位，然后再通过 transform: scale() 方法等比缩放。<h5 id=字体>字体</h5><p>那 <code>font-size</code> 是否也要用 rem 单位呢？ 这也是我曾经纠结的地方。如果不等比缩放，对不起设计师，而且对于小屏幕，一些元素内的字体会换行或溢出。当然这可以通过 CSS3 媒介查询解决这种状况。<p>字体不采用 rem 的好处是：在大屏手机下，能显示更多字体。<p>看到 <a href=http://3g.163.com/ >网易新闻</a> 和 <a href=https://jhs.m.taobao.com/m/index.htm#!all>聚划算</a> 的字体大小都采用 rem 单位，我就不纠结了。当然，也有其它网站是采用绝对单位的，两者没有绝对的对与错，取决于你的实际情况。<h4 id=缺点>缺点</h4><h5 id=小数点-不精细-有间隙->小数点（不精细，有间隙）</h5><p>由于 rem 布局是基于某一设备实现的（目前一般采用 iPhone6），对于 375 倍数宽的设备无疑会拥有最佳的显示效果。而对于非 375 倍数宽的设备，zoom 就可能是拥有除不尽的小数，根元素的字体大小也相应会有小数。而浏览器对小数的处理方式不一致，导致该居中的地方没完全居中，但你又不能为此设置特定样式（如 margin-top: *px;），因为浏览器多如牛毛，这个浏览器微调居中了，而原本居中的浏览器变得不居中了。<p>对于图标 icon，rem 的不精细导致通过多个元素（伪元素）组合而成的 icon 会形成错位/偏差。因此，在这种情况下，需要权衡是否需要使用 CSS 实现了。<h3 id=sass>SASS</h3><p>SASS 无疑增强了原本声明式的 CSS，为 CSS 注入了可编程等能力。在这次项目，算是我第一次使用 SASS，由于构建工具和基础库的完善，只需通过查看/模仿已有项目的 SASS 用法，就能快速上手。后续还是要系统地学习，以更合理地使用 SASS。<p>使用 SASS 的最大问题是：层级嵌套过深，这也是对 SASS 理解不深入的原因。可以关注一下转译后的 CSS。<h3 id=兼容性>兼容性</h3><p>这次项目的 APP 采用手机自带浏览器内核，而这些浏览器内核依赖于系统版本等因素。另外，国产机也会对这些内核进行定制和修改。特别是华为、OPPO。<p>下面列出我所遇到的兼容性问题（不列具体机型，因为这些兼容性处理终会过时，不必死记硬背，遇到了能解决就好（要求基础扎实））：<ul><li>flexbox：在构建工具处理下（实现了新旧语法）可以大胆用，但个别设备不支持 flex-wrap: wrap。因此对于想使用 flex-wrap 实现自动分行的情况，建议使用其他实现。如果个数固定（如 N 行，每行 M 个），则可使用 N 个 flexbox（这样就可以使用 flexbox 的特性了）。flexbox 的其他属性也有支持不好的情况，可以通过显式声明 display、overflow、width、height 等方法解决。<li>background-size：需要单独写，否则在 <a href="http://caniuse.com/#search=background-size">安卓 4.3 及以下，IOS 6.1及以下不兼容</a>。<li>渐变：线性渐变大胆使用，径向渐变有兼容性问题。但是不建议对整体背景使用，会有性能问题（可简单地通过 1px 高的图片替代，注意，不要 background-size: 100% auto; 应该采用 background-size: 100% 1px; 因为有些浏览器（视口宽度较小）会忽略小数点【<code>auto = img.Height * (screen.Width/img.Width)</code>】，导致图片未显示）。另外，需要注意的是：透明的色标在iOS 默认是黑色的，即 transparent 等于 rgba(0,0,0,0)。因此即使是完全透明的色标，也要指定颜色。否则后果如下：<br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/linear-gradient.jpg alt=此处输入图片的描述><li>classlist.remove(String[, String])，传递多个参数时，会有不兼容的情况。建议每次写一个。add (String[, String])同理。<li><p>根节点 html font-size 渲染错误：在华为、魅族的某设备上（手Q），会出现一个非常奇葩的渲染 Bug，同一个网页，“扫一扫”打开 html 的 font-size 正常，直接点击链接会出现<strong>渲染出来的 html font-size 会比设置得值大</strong>（如：设置25.8，渲染出来是 29），因此导致整体变大，且布局错乱。<br>我的方法是：为 html font-size 重新设置大小：渲染字体大小 - (渲染与正常差值)<pre class=nust-code><code class="hljs javascript"> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getStyle</span>(<span class=hljs-params>ele, style</span>) </span>{
     <span class=hljs-keyword>return</span> <span class=hljs-built_in>document</span>.defaultView.getComputedStyle(ele, <span class=hljs-literal>null</span>)[style]
 }
 ;(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fixFontSize</span>(<span class=hljs-params></span>) </span>{
     <span class=hljs-keyword>var</span> target = <span class=hljs-built_in>window</span>.o2Zoom * <span class=hljs-number>20</span>
     <span class=hljs-keyword>var</span> cur = <span class=hljs-built_in>parseInt</span>(getStyle(<span class=hljs-built_in>document</span>.documentElement, <span class=hljs-string>"fontSize"</span>))
     <span class=hljs-keyword>while</span>(cur - target >= <span class=hljs-number>1</span>) {
         <span class=hljs-built_in>document</span>.documentElement.style[<span class=hljs-string>"fontSize"</span>] = target - (cur - target) + <span class=hljs-string>"px"</span>
         cur = <span class=hljs-built_in>parseInt</span>(getStyle(<span class=hljs-built_in>document</span>.documentElement, <span class=hljs-string>"fontSize"</span>))
     }          
 })();</code></pre></ul><p>有网友提供这个方法 <code>&lt;meta name="wap-font-scale" content="no"></code>，经测试不可行。此方法是针对 UC 浏览器的。<p>上面主要列出了对使用有影响的兼容性问题，有些由于浏览器渲染引擎导致的问题（不影响使用），若无法通过 transform、z-index 等解决，也许只能通过 JavaScript 解决或进行取舍了。<h3 id=其他一些知识点>其他一些知识点</h3><ul><li><p>图片占位元素：对于宽高比例固定的坑位（如商品列表项），通过将图片放置在占位元素中，可避免图片加载时引起的页面抖动和图片尺寸不一致而导致的页面布局错乱。代码实现：<pre class=nust-code><code class="hljs scss"> <span class=hljs-selector-class>.img_placeholder</span> {
   <span class=hljs-attribute>position</span>: relative;
   <span class=hljs-attribute>height</span>: <span class=hljs-number>0</span>;
   <span class=hljs-attribute>overflow</span>: hidden;
   <span class=hljs-attribute>padding-top</span>: placeholder 的高/宽%; <span class=hljs-comment>// padding-top/bottom: 百分比; 是基于父元素的宽度</span>
   <span class=hljs-selector-tag>img</span> {
       <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
       <span class=hljs-attribute>height</span>: auto;
       <span class=hljs-attribute>position</span>: absolute;
       <span class=hljs-attribute>left</span>: <span class=hljs-number>0</span>;
       <span class=hljs-attribute>top</span>: <span class=hljs-number>0</span>;
   }
 }</code></pre><li><p>1px：在 retina 屏幕下，1 CSS像素是用 4 个物理像素表示，为了在该屏幕下显示更精细，通过为 ::after 应用以下代码（以上边框为例）：<pre class=nust-code><code class="hljs scss"> <span class=hljs-selector-tag>div</span> {
     <span class=hljs-attribute>position</span>: relative;
     &::after {
         <span class=hljs-attribute>content</span>: <span class=hljs-string>''</span>;
         <span class=hljs-attribute>position</span>: absolute;
         <span class=hljs-attribute>z-index</span>: <span class=hljs-number>1</span>;
         <span class=hljs-attribute>pointer-events</span>: none;
         <span class=hljs-attribute>background</span>: <span class=hljs-variable>$borderColor</span>;
         <span class=hljs-attribute>height</span>: <span class=hljs-number>1px</span>;<span class=hljs-attribute>left</span>: <span class=hljs-number>0</span>;<span class=hljs-attribute>right</span>: <span class=hljs-number>0</span>;<span class=hljs-attribute>top</span>: <span class=hljs-number>0</span>;
         @<span class=hljs-keyword>media</span> only screen and (-webkit-min-device-pixel-ratio:<span class=hljs-number>2</span>) {
             &{
                 -webkit-<span class=hljs-attribute>transform</span>: scaleY(<span class=hljs-number>0.5</span>);
                 -webkit-<span class=hljs-attribute>transform-origin</span>: <span class=hljs-number>50%</span> <span class=hljs-number>0%</span>;
             }
         }
     }
 }</code></pre><li><p>根据元素个数应用特定样式：<pre class=nust-code><code class="hljs stylus"> <span class=hljs-comment>/* one item */</span>
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>1</span>) {
     <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
 }
 <span class=hljs-comment>/* two items */</span>
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>2</span>),
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>2</span>) ~ <span class=hljs-selector-tag>li</span> {
     <span class=hljs-attribute>width</span>: <span class=hljs-number>50%</span>;
 }
 <span class=hljs-comment>/* three items */</span>
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>3</span>),
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>3</span>) ~ <span class=hljs-selector-tag>li</span> {
     <span class=hljs-attribute>width</span>: <span class=hljs-number>33.3333%</span>;
 }
 <span class=hljs-comment>/* four items */</span>
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>4</span>),
 <span class=hljs-selector-tag>li</span>:first-child:nth-last-child(<span class=hljs-number>4</span>) ~ <span class=hljs-selector-tag>li</span> {
     <span class=hljs-attribute>width</span>: <span class=hljs-number>25%</span>;
 }</code></pre><p>应用样例有：根据元素个数自适应标签样式。<br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/tag1.png alt=根据元素个数自适应标签样式><br>而对于反方向标签，可先首先对整体 transform: scale(-1)，然后再对字体 transform: scale(-1) 恢复从左向右的方向。效果如下：<br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/tag2.png alt=标签反向><li>卡券：『带孔且背景是渐变的卡券』在复杂背景中的实现。由于背景是复杂的（非纯色），因此孔不能简单地通过覆盖（与背景同色）产生。这里可以应用径向渐变 <code>background-image: radial-gradient(rem(189/2) 100%, circle, transparent 0, transparent 3px, #fa2c66 3px);</code>，其中 3px 是孔的半径。另外，卡券的上下部分是线性渐变的，因此可以在上下部分分别通过伪类元素添加 <code>background-image: linear-gradient(to top, #fa2e67 0, #fb5584 100%);</code>，当然，要从离外上/下边界 3px 的地方开始。虽然这不能完美地从最边界开始，但效果还是可以的。但由于径向渐变的兼容性问题，我最终还是用图片替换了这种实现。🙄<br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/coupon.png alt=带孔且背景是渐变的卡券><li>多行文本的多行padding：让背景只出现在有文字的地方，可直接设置 <code>display: inline;</code>，但还会存在一个问题是：padding 只会出现在多行文本的首和尾，对于需要为每行文本的首尾都需要相同的 padding，可以参考这篇文章：<a href=https://css-tricks.com/multi-line-padded-text/ >《multi-line-padded-text》</a> 。该文章提供了多种实现方式，根据具体情况选择一种即可。另外，对于每行的间距，可通过设置 line-height 和 padding-top/bottom 实现，其中 line-height 要大于（字体高度+padding-top/bottom）。<br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/multi-line1.png alt=此处输入图片的描述><br><img src=//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/multi-line2.png alt=此处输入图片的描述><li>最小字体限制：PC上最小字体是 12px、移动端最小是 8px，当然可通过 transform:scale() 突破限制。</ul><h3 id=不止页面页面制作>不止页面页面制作</h3><ol><li>基础：合理运用 CSS 的威力更好地完成对设计稿的重现目的。<li>沟通：由于分工较细，只负责页面制作的同学，需要与产品和设计沟通，以达到交给开发后更少修改的目的。如哪些地方可跳转、哪些地方最多显示几行文字、超出如何处理（直接隐藏/省略号等）、坑位中的图片摆放（顶部对齐/居中等）等等。<li>代码上的沟通：HTML 注释要写好、HTML 与 CSS 代码要规范（命名等）清晰。</ol><h3 id=思考>思考</h3><p>由于工具的成熟，我不需要考虑构建工具的搭建。<br>由于发布方式的成熟，页面制作和开发能更好地分离，页面制作者负责输出 HTML、CSS，开发负责 copy html 代码和引入 CSS 页面片。CSS 页面片由页面制作者更新发布，开发无需关心。这达到了互不干扰、多线程并行的效果。<br>成熟的基础设施让我们免除了非代码相关的烦恼，但这也让我担心：假如有一天我脱离了这些基础设施，我该如何保持高效。<h4 id=延伸-页面片是什么->延伸：页面片是什么？</h4><p>CSS 页面片<pre class=nust-code><code class="hljs xml"><span class=hljs-comment>&lt;!-- #include virtual="/folder/branch.shtml" --></span>
<span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>combofile</span>=<span class=hljs-string>"/folder/branch.shtml"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"stylesheet"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"//website/folder/gb.min_1151b5b0.css,/folder/branch.min_925332fc.css"</span> /></span></code></pre><p>JS 页面片<pre class=nust-code><code class="hljs xml"><span class=hljs-comment>&lt;!-- #include virtual="/folder/branch_js.shtml" --></span>
<span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>combofile</span>=<span class=hljs-string>"/folder/branch.shtml"</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"//website/path/branch.min_8971778a.js"</span>></span><span class="undefined"></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><blockquote><p>Combo Handler是Yahoo!开发的一个Apache模块，它实现了开发人员简单方便地通过URL来合并JavaScript和CSS文件，从而大大减少文件请求数。 <a href=http://www.cnblogs.com/zhengyun_ustc/archive/2012/07/18/combo.html>http://www.cnblogs.com/zhengyun_ustc/archive/2012/07/18/combo.html</a></blockquote><hr><p>这就是我的第一次...🙈 学习很多，完！<p>以上仅是我个人完成某项目页面制作的思考和总结，不小心暴露了团队下限。🌚]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>APNG 那些事</title>
      <link>https://aotu.io/notes/2016-11-08/apng</link>
      <guid>https://aotu.io/notes/2016-11-08/apng</guid>
      <pubDate>2016-11-07T17:48:31.000Z</pubDate>
      <description>
      
        GIF 存活 29 年之久，依然大行其道的今天，有没有更合适的动画格式？
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>凹凸君：</strong> GIF 存活 29 年之久，依然大行其道的今天，有没有更合适的动画格式？<p><strong>回答：</strong> 或许，可以聊聊 APNG。<h3 id=关于-apng>关于 APNG</h3><p>APNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。<h3 id=apng-简史>APNG 简史</h3><p><strong>MNG</strong><p>在 APNG 之前它还有一个老冤家叫 MNG（Multiple-image Network Graphics）即多图像网络图形，1996 年 6 月提出 PNF（Portable Network Frame）草案，同年8月更名为 MNG ，2001 年 1 月 31 日发布 MNG 规范 1.0 版本，MNG 是出自 PNG 开发组之手，但由于结构复杂的 MNG 程序库，使用过程会占用大量的资源，早期只有较少的浏览器支持，Chrome、IE、Opera、Safari 则从未支持过。<p><strong>APNG</strong><p>2004 年，由 Mozilla 公司两位 Mozilla 程序员 Stuart Parmenter 和 Vladimir Vukićević 共同设计出 APNG，他们希望 Mozilla 社区能使用它，但提案未能通过。<p><strong>libpng程序库</strong><p>2006 年，Google Summer of Code 活动中，加拿大圣力嘉学院的学生为 libpng 程序库加入了对 APNG 支持，此后开发者再次推荐给 Mozilla 社区，不过仍然遭到拒绝。<p><strong>首次支持</strong><p>2007 年 3 月 23 日，Mozilla 后知后觉，在 Mozilla Firefox 3.0 中 首次支持 APNG 格式。<p><strong>标准化申请</strong><p>2007 年 4 月 20 日，Mozilla 希望 APNG 能成为官方标准，因此 PNG 组织发起投票，最终以8：10的票数否决了 APNG 进了官方标准，因为 PNG 组织决心继续推广 MNG，但这不并影响 Mozilla 继续支持 APNG。<h3 id=为什么-gif-能存活29年之久->为什么 GIF 能存活29年之久？</h3><p>开头讲 APNG 时提到，APNG 的出现就是为了替代 GIF，诞生于 1987 年的 GIF 为什么能存活 29 年之久？<p>主要有四个原因：<ul><li>几乎所有的主流浏览器都支持 GIF<li>早期选择不多，GIF 几乎是唯一选择（GIF - 1987、JPEG - 1992、PNG - 1996、APNG - 2004、WebP - 2010）<li>实现起来简单，制作的工具多<li>采用 LZW 数据压缩算法，使得 GIF 体积小，在早期慢速的互联网易于传播</ul><h3 id=为什么要取代它->为什么要取代它？</h3><p><strong>1、图片质量</strong></p><div style=width:100%><img style=width:20%;background:#000 src=//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif><img style=width:20%;background:#fff src=//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif><img style=width:20%;background:#dd0041 src=//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif><img style=width:20%;background:#6752b7 src=//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif><img style="width:20%;background:url(//misc.aotu.io/ONE-SUNDAY/apng_checker.png);background-size:8px 8px"src=//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif><p style=color:#bbb;text-align:center>GIF</div><div style=width:100%><img style=width:20%;background:#000 src=//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png><img style=width:20%;background:#fff src=//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png><img style=width:20%;background:#dd0041 src=//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png><img style=width:20%;background:#6752b7 src=//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png><img style="width:20%;background:url(//misc.aotu.io/ONE-SUNDAY/apng_checker.png);background-size:8px 8px"src=//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png><p style=color:#bbb;text-align:center>APNG</div><p>如果你使用的是非 Firefox、Safari 浏览器，那 APNG 格式的图片会向下兼容显示为静态图，你可以更换 Firefox、Safari 浏览器或者在 Chrome 浏览器安装 <a href=https://chrome.google.com/webstore/detail/apng/ehkepjiconegkhpodgoaeamnpckdbblp>APNG Extension for Google Chrome</a> 扩展来兼容，通过两者对比能总结出以下区别：<p><strong>GIF：</strong><ul><li>最多支持 8 位 256 色，色阶过渡糟糕，图片具有颗粒感<li>不支持 Alpha 透明通道，边缘有杂边</ul><p><strong>APNG：</strong><ul><li>支持 24 位真彩色图片<li>支持 8 位 Alpha 透明通道<li>向下兼容 PNG</ul><p><strong>2、图片体积</strong><p>如果你使用的浏览器不支持WebP，下面对比的 WebP 格式的图片将无法显示。</p><table><tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/SteamEngine.gif><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/SteamEngine.png><tr><td style=text-align:center>GIF = 43 920 bytes<td style=text-align:center>APNG = 34 210 bytes<tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/SteamEngine.webp alt=SteamEngine.webp><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/SteamEngine_lossy.webp alt=SteamEngine_lossy.webp><tr><td style=text-align:center>WebP = 41 064 bytes<td style=text-align:center>Lossy WebP = 73 774 bytes<tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/world-cup_2014_42.gif><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42.png><tr><td style=text-align:center>GIF = 43 132 bytes<td style=text-align:center>APNG = 30 823 bytes<tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42.webp alt=world_cup_2014_42.webp><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42_lossy.webp alt=world_cup_2014_42_lossy.webp><tr><td style=text-align:center>WebP = 55 968 bytes<td style=text-align:center>Lossy WebP = 114 518 bytes<tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/BladeRunner.gif><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/BladeRunner.png><tr><td style=text-align:center>GIF = 200 700 bytes<td style=text-align:center>APNG = 168 411 bytes<tr><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/BladeRunner.webp alt=BladeRunner.webp><td style=text-align:center><img src=//misc.aotu.io/ONE-SUNDAY/BladeRunner_lossy.webp alt=BladeRunner_lossy.webp><tr><td style=text-align:center>WebP = 424 752 bytes<td style=text-align:center>Lossy WebP = 394 118 bytes</table><p>从几组 GIF、APNG、WebP 的对比中可以发现，无论在纯色的图片或是多彩的图片，大部分情况下 APNG 依旧能比 GIF、WebP 以及有损的 WebP 的体积小。<h3 id=apng-的组成>APNG 的组成</h3><p>APNG 是基于 PNG 格式扩展的，首先需要了解一个简单的 PNG 文件组成结构：<table><tr><td>PNG Signature<td>IHDR<td>IDAT<td>IEND</table><p>PNG 由 4 部分组成，首先以 PNG Signature（PNG签名块）开头，紧接着一个 IHDR（图像头部块），然后是一个或多个的 IDAT（图像数据块），最终以 IEND（图像结束块）结尾。<p>APNG 规范引入了三个新大块，分别是：acTL（动画控制块）、fcTL（帧控制块）、fdAT（帧数据块），下图是三个独立的 PNG 文件组成 APNG 的示意图。<p><img src=//misc.aotu.io/ONE-SUNDAY/apng_assembling.jpg alt="APNG 的组成示意图"><ul><li>acTL 块必须在第一个 IDAT 块之前，用于告诉解析器这是一个动画 PNG，包含动画帧总数和循环次数的信息<li>fcTL 块是每一帧都必须的，出现在 IDAT 或 fdAT 之前，包含顺序号、宽高、帧位置、延时等信息<li>fdAT 块与 IDAT 块有着相同的结构，除了 fcTL 中的顺序号</ul><p>从图中可以发现第一帧与后面两帧不同，那是因为第一帧 APNG 文件存储的为一个正常的 PNG 数据块，对于不支持 APNG 的浏览器或软件，只会显示 APNG 文件的第一帧，忽略后面附加的动画块，这也是为什么 APNG 能向下兼容 PNG 的原因。<h3 id=apng-帧间优化>APNG 帧间优化</h3><p>假设使用一个 4 帧图片合成 APNG<p><img src=//misc.aotu.io/ONE-SUNDAY/png_frame.jpg alt=4帧图片><p>APNG 会通过算法计算帧之间的差异，只存储帧之前的差异，而不是存储全帧。<p><img src=//misc.aotu.io/ONE-SUNDAY/png_frame2.jpg alt=存储差异帧><p>通过 TweakPNG 软件观察 IDAT 图像数据块和 fdAT 帧数据块的大小，可以明显的看出来存储全帧与差异帧的区别，使得 APNG 文件大小有显著的减少。<p><img src=//misc.aotu.io/ONE-SUNDAY/clock_tweakpng.jpg alt=TweakPNG软件><h3 id=为什么没有普及->为什么没有普及？</h3><p><img src=//misc.aotu.io/ONE-SUNDAY/caniuse_apng.jpg alt="Can I use - APNG"><p>主要的原因是缺乏浏览器的支持，从 Can I use 查询可知 Firefox 从 3 到 49 版本自始自终支持着，Opera 早期只有三个版本支持过（10.1、11.5、12.1），后续版本则取消了对 APNG 的支持，而 Chrome、IE、Edge 则从未支持过 APNG，Chrome 和 Opera 都在推广自家的 WebP，而微软则一直是个不合群的家伙。<p>但是，重要的一点是 2014 年 9 月 17 号 Apple 向用户推送了 iOS 8，这意味着 Safari 8 新增了对 APNG 的支持，这能有效的推动 APNG 的发展，至少在移动端。<h3 id=特性检测>特性检测</h3><p>既然存在兼容问题，那就需要通过判断应用场景。<pre class=nust-code><code class="hljs javascript">(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
<span class=hljs-meta>    "use strict"</span>;
    <span class=hljs-keyword>var</span> apngTest = <span class=hljs-keyword>new</span> Image(),
    ctx = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>"canvas"</span>).getContext(<span class=hljs-string>"2d"</span>);
    apngTest.onload = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{
        ctx.drawImage(apngTest, <span class=hljs-number>0</span>, <span class=hljs-number>0</span>);
        self.apng_supported = ctx.getImageData(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, <span class=hljs-number>1</span>, <span class=hljs-number>1</span>).data[<span class=hljs-number>3</span>] === <span class=hljs-number>0</span>;
    };
    apngTest.src = <span class=hljs-string>"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg=="</span>;
}());</code></pre><p>方法与 WebP 检测相似，同样是加载一张 1x1 像素大小的 Base64 编码图片，不同在于 WebP 加载完成后是判断图片宽高是否大于 1，而 APNG 则是将其绘制到画布中，通过 getImageData() 方法去获取该图片的像素数据，主要是获取 data[3] 的 Alpha 透明通道（值的范围：0 - 255），当返回 0（0代表透明的）时则表示支持 APNG，返回 255（255 代表完全可见的）则表示不支持 APNG。<h3 id=apng-to-canvas>APNG to Canvas</h3><p>当然，目前也有用于兼容的库：<a href=https://github.com/davidmz/apng-canvas>apng-canvas</a><p>使用该库需要以下条件支持：<ul><li>Canvas<li>Typed Arrays<li>Blob URLs<li>requestAnimationFrame</ul><pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"example.png"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"apng-image"</span>></span></code></pre><pre class=nust-code><code class="hljs javascript">APNG.ifNeeded().then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
    <span class=hljs-keyword>var</span> images = <span class=hljs-built_in>document</span>.querySelectorAll(<span class=hljs-string>".apng-image"</span>);
    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; images.length; i++) {
        APNG.animateImage(images[i]);
    }
});</code></pre><p><a href=http://jdc.jd.com/demo/apng-canvas/ >DEMO 戳这里</a><h3 id=制作工具>制作工具</h3><p>在了解 APNG 后，是不是心痒痒想制作 APNG 呢？在制作工具方面，APNG 已经不像早期那样工具匮乏了，<a href=http://littlesvr.ca/apng/ >APNG Software</a> 网站上有大量的制作工具，有客户端版本（大部分只支持 Widnows）也有命令行版本，可以非常轻松的制作 APNG，比如下面这款软件。<p><strong>Windows客户端 - APNG Assembler</strong><p><img src=//misc.aotu.io/ONE-SUNDAY/windows_apng-assembler.jpg alt="APNG Assembler"><p><strong>Mac客户端 - APNGb</strong><p><img src=//misc.aotu.io/ONE-SUNDAY/mac_apngb.jpg alt=APNGb><p><strong>功能说明：</strong><ul><li>Playback Settings 可设置循环的次数，0 表示无限循环，可跳过第一帧<li>Delays - All Frames 可设置所有帧播放时所停留的时间<li>Compression Settings 可设置压缩参数，有三种压缩方式（zlib、7zip、Zopfli）以及颜色类型和调色板优化<li>Delays - Selected Frames 可设置选中帧播放时所停留的时间</ul><p>这里演示图分别是 Windows 版本和 Mac 版本，功能基本一致，将序列帧图片拖拽到指定位置，设置一些基本的参数即可生成 APNG 图，Mac 版本比 Windows 版本多出一个将 APNG 图片 Disassembly（分解）功能，可分解为多个 PNG 图片。<p><a href=https://sourceforge.net/projects/apngasm/ >下载地址戳这里</a><h3 id=投票呼吁>投票呼吁</h3><p>在最后，如果你认为 APNG 是值得被支持、被推广的，请为它投上一票和点 Stars（需科学上网）。<p>APNG support in Chrome : <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1171">issue 1171</a>、<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=437662">issue 437662</a><p><img src=//misc.aotu.io/ONE-SUNDAY/support_chrome_stars.jpg alt="APNG support in Chrome"><p>APNG support in IE : <a href=https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/6513393-apng-animated-png-images-support-firefox-and-sa>Votes</a><p><img src=//misc.aotu.io/ONE-SUNDAY/support_ie_votes.jpg alt="APNG support in IE"><p>感谢你的阅读。<h3 id=参考资料>参考资料</h3><p><a href=http://people.mozilla.org/~dolske/apng/demo.html>Animated PNG demos</a> <a href=http://littlesvr.ca/apng/gif_apng_webp.html>GIF vs APNG vs WebP</a> <a href=http://littlesvr.ca/apng/inter-frame.html>Inter-frame Optimization in APNG</a> <a href=https://github.com/davidmz/apng-canvas>davidmz/apng-canvas - Github</a> <a href=https://en.wikipedia.org/wiki/GIF>GIF - Wikipedia</a> <a href=https://en.wikipedia.org/wiki/APNG>APNG - Wikipedia</a> <a href=https://wiki.mozilla.org/APNG_Specification>APNG Specification</a> <a href="http://caniuse.com/#search=APNG">Can I use - APNG</a> <a href=https://zh.wikipedia.org/wiki/PNG>Portable Network Graphics - Wikipedia</a> <a href=https://en.wikipedia.org/wiki/Multiple-image_Network_Graphics>Multiple-image Network Graphics - Wikipedia</a> <a href=http://littlesvr.ca/apng/ >APNG Software</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>border-image 的正确用法</title>
      <link>https://aotu.io/notes/2016-11-03/border-image</link>
      <guid>https://aotu.io/notes/2016-11-03/border-image</guid>
      <pubDate>2016-11-02T21:22:23.000Z</pubDate>
      <description>
      
        尽管经常使用 border-image，但我们真的了解它的吗？
      
      </description>
      
      <content:encoded><![CDATA[<h1 id=border-image-的正解用法>border-image 的正解用法</h1><p>border-image 边框图片，顾名思义: 指定边框使用的图片。 尽管经常使用 border-image(-webkit-border-image)，但我们真的了解它的吗？<p>本文分两部分来介绍 border-image：<ol><li>border-image 简史<li>border-image 用法</ol><h2 id=1-border-image-简史>1. border-image 简史</h2><p>CSS3 border 最开始是做为一个独立模块(CSS3 module: Border)被维护，后来(2005.2.16) W3C工作组将 border 和 background 两个模块合并作为一个新模块：<strong>CSS3 Backgrounds and Borders Module</strong>，08年又将其改名为 <strong>CSS Backgrounds and Borders Module Level 3</strong>。以下是具体过程：<ul><li><strong>CSS3 module: Border</strong> <a href=https://www.w3.org/TR/2002/WD-css3-border-20021107/ >W3C Working Draft 7 November 2002</a><li><strong>CSS3 Backgrounds and Borders Module</strong> <a href=https://www.w3.org/TR/2005/WD-css3-background-20050216/ >W3C Working Draft 16 February 2005</a><li><strong>CSS Backgrounds and Borders Module Level 3</strong> <a href=https://www.w3.org/TR/2008/WD-css3-background-20080910/ >W3C Working Draft 10 September 2008</a> <a href=https://www.w3.org/TR/2009/WD-css3-background-20091015/ >W3C Working Draft 15 October 2009</a> <a href=https://www.w3.org/TR/2009/CR-css3-background-20091217/ >W3C Candidate Recommendation 17 December 2009</a> <a href=https://www.w3.org/TR/2010/WD-css3-background-20100612/ >W3C Working Draft 12 June 2010</a> <a href=https://www.w3.org/TR/2011/CR-css3-background-20110215/ >W3C Candidate Recommendation 15 February 2011</a> <a href=https://www.w3.org/TR/2012/WD-css3-background-20120214/ >W3C Working Draft 14 February 2012</a> <a href=https://www.w3.org/TR/2012/CR-css3-background-20120417/ >W3C Candidate Recommendation 17 April 2012</a> <a href=https://www.w3.org/TR/2012/CR-css3-background-20120724/ >W3C Candidate Recommendation 24 July 2012</a> <a href=https://www.w3.org/TR/2014/WD-css3-background-20140204/ >W3C Last Call Working Draft 4 February 2014</a> <a href=https://www.w3.org/TR/css3-background/ >W3C Candidate Recommendation 9 September 2014</a></ul><p>在 CSS3 border 的第一个工作草案(WD)『<a href=https://www.w3.org/TR/2002/WD-css3-border-20021107/ >W3C Working Draft 7 November 2002</a>』 定义了 border-image 的用法，经过漫长的十几年修订，border-image 经历了三次重要的演变：<h3 id=1-1-草创阶段>1.1 草创阶段</h3><blockquote><p>The border-image properties allow the author to assign images to borders. There are four groups of border image properties: Specifying border images These properties are used to specify the URI of the border image. Fitting border images These properties are used to specify how the image(s) are fitted in the border area. Transforming border images These properties are used to make the images of a side or a corner to be reflected or rotated versions of another. The border image properties override the border style properties. —— 摘录自：『<a href=https://www.w3.org/TR/2002/WD-css3-border-20021107/#the-border-image>W3C Working Draft 7 November 2002 #the-border-image</a>』。</blockquote><p>此时的 border-image 由3组属性成，分别是：<ul><li>border-image/border-corner-image<li>border-fit/border-corner-fit<li>border-transform/border-corner-transform</ul><p>(ps: W3C 文档里提到有四组属性。不过笔者只找到上述三组)<p><strong>1. border-image/border-corner-image</strong> border-image 指定四边的图像，border-corner-image 指定四个角的图像，注意这里分开指定四条边和四个角的图片即需要使用8个图像。如下：<p><img src=//misc.aotu.io/leeenx/border-image/pow.png alt=W3C示例图><p>另外，每条边都可以指定三张图片： <img src=//misc.aotu.io/leeenx/border-image/2016-10-28.png alt=W3C示例图><p><strong>2. border-fit/border-corner-fit</strong> 指定 border-image/border-corner-image 的平铺方式。<p><strong>3.border-transform/border-corner-transform</strong> 指定 border-image/border-corner-image 的变换方式。<p>具体可以参见：<a href=https://www.w3.org/TR/2002/WD-css3-border-20021107/#the-border-image>https://www.w3.org/TR/2002/WD-css3-border-20021107/#the-border-image</a><p>这个古老的版本对 bordr-image 做了全面的定义，甚至比当前(2016.11.1)的标准还要周到详细，但是这个版本过于笨重，很快被 W3C 的新标准替代。<h3 id=1-2-发展阶段>1.2 发展阶段</h3><p>『<a href=https://www.w3.org/TR/2005/WD-css3-background-20050216/ >W3C Working Draft 16 February 2005</a>』对上个版本做了极大的精简工作，并重新定义了一个简洁的 border-image ，语法如下：<pre class=nust-code><code class="hljs css">border-image: none | &lt;uri> [&lt;number> | &lt;percentage>]{4} [ / &lt;border-width>{1,4} ]? [stretch | repeat | round]{0,2}</code></pre><blockquote><p>The four numbers or percentages immediately following the<uri>specify which part of that image is used for which part of the border. They divide the image into nine parts: four corners, four edges and a middle part. The middle part is used as an extra background image. —— 摘录自：<a href=https://www.w3.org/TR/2005/WD-css3-background-20050216/#the-border-image>https://www.w3.org/TR/2005/WD-css3-background-20050216/#the-border-image</a></blockquote><p>这个版本提出了九宫格的概念(border-image的精髓)并提供了简洁的语法。 Chrome/Safari 私有的 <code>-webkit-border-image</code> 实现了这个版本的语法，并将其发扬光大。至今(2016.11.1)国内不少介绍 border-image 技术文章都是在介绍这个版本。<h3 id=1-3-成熟阶段>1.3 成熟阶段</h3><p>修订版 『<a href=https://www.w3.org/TR/2009/WD-css3-background-20091015/ >W3C Working Draft 15 October 2009</a>』在上个版本的基础上将 border-image 分拆成 border-image-<em> 家族，同时加入一个新的成员 border-image-outset。border-image-</em> 成员如下：<ul><li>border-image-source<li>border-image-slice<li>border-image-width<li>border-image-outset<li>border-image-repeat</ul><p>border-image 成为上述五个属性的简写，语法也从此稳定下来，俨然已是一个正式的 W3C 标准(REC)。<h2 id=2-border-image-的正确用法>2. border-image 的正确用法</h2><blockquote><p>Authors can specify an image to be used in place of the border styles. In this case, the border's design is taken from the sides and corners of an image specified with ‘border-image-source’, whose pieces may be sliced, scaled and stretched in various ways to fit the size of the border image area. The border-image properties do not affect layout: layout of the box, its content, and surrounding content is based on the ‘border-width’ and ‘border-style’ properties only. —— 摘录自： <a href=https://www.w3.org/TR/css3-background/#border-images>https://www.w3.org/TR/css3-background/#border-images</a></blockquote><p>border-image 通过指定一张图片来取替 border-style 定义的样式，但 <strong>border-image 生效的前提是： border-style 和 border-width 同时为有效值(即 border-style 不为 none，border-width 不为 0)。</strong><p>本章按 『<a href=https://www.w3.org/TR/css3-background/ >W3C Candidate Recommendation 9 September 2014</a>』规范来介绍 border-image 的用法。<h3 id=2-1-border-image-source>2.1 border-image-source</h3><p>语法：<pre class=nust-code><code class="hljs maxima"><span class=hljs-built_in>border</span>-<span class=hljs-built_in>image</span>: none | &lt;<span class=hljs-built_in>image</span>></code></pre><p>指定边框图片的地址。 none 表示border-image不做任何效果，边框使用 border-style 指定的样式。<h3 id=2-2-bordre-image-slice>2.2 bordre-image-slice</h3><p>语法：<pre class=nust-code><code class="hljs css">bordre-image-slice [&lt;number> | &lt;percentage>]{1,4} && fill?</code></pre><p>border-image-slice 从名字上看就很好理解：边框图像切片。指定4个值(4条分割线：top, right, bottom, left)将 border-image-source 分割成9宫格，如下：<p><img src=//misc.aotu.io/leeenx/border-image/2ia2uu.gif alt="gif 动图"><p><strong>四条分割线的值</strong><p>border-image-slice 四条线的值类型为：number | percentage。<p><code>number</code> 不带单位的数值。1 代表 1个图片像素。 <code>percentage</code> 百分比。<p>错误的写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image-slice</span>: <span class=hljs-number>27px</span> <span class=hljs-number>27px</span> <span class=hljs-number>27px</span> <span class=hljs-number>27px</span>;</code></pre><p>正确的写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image-slice</span>: <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span>;</code></pre><p><strong>关键字：fill</strong><blockquote><p>Specifies an image to use in place of the rendering specified by the ‘border-style’ properties and, if given the ‘fill’ keyword in ‘border-image-slice’, as an additional image backdrop for the element.</blockquote><p><strong>关键字fill的作用是：将border-image-source九宫格中间那一块切片作为DOM节点的背景。</strong><p>素材图片box.png:<br><img src=//misc.aotu.io/leeenx/border-image/box.png alt=box.png><p>CSS 代码：<pre class=nust-code><code class="hljs smali"><span class=hljs-keyword>.box</span> {
    width: 27px;
    height:27px;
    border: 27px solid;
    border-image: url(box.png) 27 27 27 27<span class=hljs-built_in> fill </span>repeat stretch;//fil？
}</code></pre><p>测试结果如下： <img src=//misc.aotu.io/leeenx/border-image/result.png alt=结果截图><p>线上DEMO： <img src=//misc.aotu.io/leeenx/border-image/qr.png alt=qr><h3 id=2-3-border-image-width>2.3 border-image-width</h3><p>语法：<pre class=nust-code><code class="hljs css">border-image-width: [ &lt;length> | &lt;percentage> | &lt;number> | auto ]{1,4}</code></pre><p>border-image-width 字面意思是边框图片宽度，作用是将 DOM 节点分割成九宫格。 假设 border-image-slice 分割 border-image-source 的九宫格为A， border-image-width 分割 DOM 的九宫格为 B，A 与 B 的每个格子存在一一对应关系，具体如下：<p><img src="//misc.aotu.io/leeenx/border-image/border-image-width.gif?v=4"alt=border-image-width与border-image-slice的对应关系><p><strong>border-image-width 参数的四种类型:</strong><p><code>length</code> 带 px, em, in ... 单位的尺寸值 <code>percentage</code> 百分比 <code>number</code> 不带单位的数字；它表示 border-width 的倍数 <code>auto</code> 使用 auto， border-image-width 将会使用 border-image-slice 的值<p><strong>border-image-width 的参数不能为负值</strong> <strong>border-image-width的缺省值是 number 类型：1</strong><h4 id=2-3-1-border-image-area>2.3.1 border image area</h4><p>border image area 是<strong>成熟阶段</strong>被引入用于解释 border-image-width 和 border-imaeg-out 的概念。<blockquote><p>The border image is drawn inside an area called the border image area. This is an area whose boundaries by default correspond to the border box —— 摘录自: <a href=https://www.w3.org/TR/css3-background/#border-image-width>https://www.w3.org/TR/css3-background/#border-image-width</a></blockquote><p>用于绘画 border image 的区域叫 border image area，它默认与边框盒子(border box)完全重合。简单地说，<strong>border image area 就是 border-image-width 分割出来的九宫格</strong>。<p><img src=//misc.aotu.io/leeenx/border-image/border-image-area.gif alt="border image area"><h4 id=2-3-2-border-box-与-border-image-area-的关系>2.3.2 border-box 与 border image area 的关系</h4><p>上面有提到，border image area 默认与 border-box 是重合关系。如果把标准后退到发展阶段：<pre class=nust-code><code class="hljs css">border-image: none | &lt;uri> [&lt;number> | &lt;percentage>]{4} [ / &lt;border-width>{1,4} ]? [stretch | repeat | round]{0,2}</code></pre><p>在发展阶段，DOM节点由 border-width 分割为九宫格，这个时期的 border-box 就是 border image area。<p>到了成熟阶段（即本章介绍的版本），<strong>border-box 与 border image area 是默认重合的两个空间</strong>，border-box 只负责盒子模型上的事务，border image area 则专注于边框图像空间分割。<h4 id=2-3-3-border-width-可以分割-border-image-area->2.3.3 border-width 可以分割 border image area?</h4><p>在实际使用过程中，笔者发现 border-width 也可以分割 border image area。如下：<p>测试CSS代码：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.box</span> {
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span> auto;
    <span class=hljs-attribute>width</span>: <span class=hljs-number>27px</span>;
    <span class=hljs-attribute>height</span>: <span class=hljs-number>27px</span>;
    <span class=hljs-attribute>border</span>: <span class=hljs-number>27px</span> solid <span class=hljs-built_in>rgba</span>(242,181,78,.3);
    <span class=hljs-attribute>border-image-source</span>: <span class=hljs-built_in>url</span>(http://7xv39r.com1.z0.glb.clouddn.com/box.png);
    <span class=hljs-attribute>border-image-slice</span>: <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> fill;
    <span class=hljs-attribute>border-image-repeat</span>: stretch stretch;
}</code></pre><p>截图如下：<p><img src=//misc.aotu.io/leeenx/border-image/border-width.jpg alt=border-width> <img src=//misc.aotu.io/leeenx/border-image/border-width2.jpg alt=border-width><p>如果单从上述测试结果而言，border-width 可以分割 border image area 是正确。不过，这个结论有一个前提：border-image-border 与 border-image-outset 同时缺省。如果将 CSS 代码修为：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.box</span> {
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span> auto;
    <span class=hljs-attribute>width</span>: <span class=hljs-number>27px</span>;
    <span class=hljs-attribute>height</span>: <span class=hljs-number>27px</span>;
    <span class=hljs-attribute>border</span>: <span class=hljs-number>27px</span> solid <span class=hljs-built_in>rgba</span>(242,181,78,.3);
    <span class=hljs-attribute>border-image-source</span>: <span class=hljs-built_in>url</span>(http://7xv39r.com1.z0.glb.clouddn.com/box.png);
    <span class=hljs-attribute>border-image-slice</span>: <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> fill;
    <span class=hljs-attribute>border-image-outset</span>: <span class=hljs-number>10px</span>;
    <span class=hljs-attribute>border-image-repeat</span>: stretch stretch;
}</code></pre><p>截图如下：<p><img src=//misc.aotu.io/leeenx/border-image/border-width3.jpg alt=border-width> <img src=//misc.aotu.io/leeenx/border-image/border-width4.jpg alt=border-width><p>设置了 border-image-outset 后 border-width 的分割 border image area 的假像就被揭穿了！！ border-width 分割 border image area 的假象源自 border-image-width 的缺省值1，数值1表示 border-image-width 是 1x border-width，大白话就是<strong>border-image-width 的默认值是border-width</strong>。<p><strong>尽管在最新的CSS3标准中 “border-width 分割 border image area” 只是个假像，但当前(2016.11.1)阶段，为了更多浏览器兼容建议 border-width 与 border-image-width 保持一致，即使用 border-width 暂代 border-image-width。</strong><h3 id=2-4-border-image-outset>2.4 border-image-outset</h3><p>语法：<pre class=nust-code><code class="hljs css">border-image-outset: [ &lt;length> | &lt;number> ]{1,4}</code></pre><p>border-image-outset 字面意思是边框图片开端。作用是重新指定 border image area 的边界。<blockquote><p>The values specify the amount by which the border image area extends beyond the border box. If it has four values, they set the outsets on the top, right, bottom and left sides in that order. If the left is missing, it is the same as the right; if the bottom is missing, it is the same as the top; if the right is missing, it is the same as the top. —— 摘录自：<a href=https://www.w3.org/TR/css3-background/#border-image-outset>https://www.w3.org/TR/css3-background/#border-image-outset</a></blockquote><p>通过指定 border-image-outset 的值，可以把 border image area 的区域延伸到 border-box 之外。如下：<pre class=nust-code><code class="hljs css"><span class=hljs-selector-class>.box</span> {
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span> auto;
    <span class=hljs-attribute>width</span>: <span class=hljs-number>81px</span>;
    <span class=hljs-attribute>height</span>: <span class=hljs-number>81px</span>;
    <span class=hljs-attribute>border</span>: <span class=hljs-number>27px</span> solid <span class=hljs-built_in>rgba</span>(0,0,0,.1);
    <span class=hljs-attribute>border-image-source</span>: <span class=hljs-built_in>url</span>(//misc.aotu.io/leeenx/border-image/box.png);
    <span class=hljs-attribute>border-image-slice</span>: <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span>;
    <span class=hljs-attribute>border-image-repeat</span>: repeat;
}
<span class=hljs-selector-class>.outset</span> {
    <span class=hljs-attribute>border-image-outset</span>: <span class=hljs-number>27px</span>;
}</code></pre><p>对比： <img src=//misc.aotu.io/leeenx/border-image/demo3.png alt=border-image-outset><p>二维码:<br><img src="//misc.aotu.io/leeenx/border-image/qr2.png?v=1"alt=二维码><p><strong>border-image-outset 与 border-image-width 参数的意义是一样的。</strong> <strong>border-image-outset 的值不能为负值</strong><h3 id=2-5-border-image-repeat>2.5 border-image-repeat</h3><p>语法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image-repeat</span>: [ stretch | repeat | round | space ]{<span class=hljs-number>1</span>,<span class=hljs-number>2</span>}</code></pre><p>border-image-repeat 字面意义是 边框图片平铺。作用是指定 border-image 的平铺方式。语法上最多可接收两个参数，第一个参数指定水平方向边框的平铺方式，第二个参数指定垂直方向边框的平铺方式，九宫格的中间区域受这两参数的共同影响，如下：<p><img src=//misc.aotu.io/leeenx/border-image/demo2_1.jpg alt="round round"> <img src=//misc.aotu.io/leeenx/border-image/demo2_2.jpg alt="round round"> <img src=//misc.aotu.io/leeenx/border-image/demo2_3.jpg alt="round round"> <img src=//misc.aotu.io/leeenx/border-image/demo2_4.jpg alt="round round"><p>目前只能四值可供选择：stretch, repeat, round, space。 其中，stretch 是默认值，space 目前chrome浏览器按 repeat 来渲染。这四个参数的效果如下：<p><img src=//misc.aotu.io/leeenx/border-image/stretch.png alt=border-image-outset> <img src=//misc.aotu.io/leeenx/border-image/repeat.png alt=border-image-outset> <img src=//misc.aotu.io/leeenx/border-image/round.png alt=border-image-outset> <img src=//misc.aotu.io/leeenx/border-image/space.png alt=border-image-outset><p>repeat 与 round 的区别：round 除了能平铺外还能通过伸缩使背景完整显示。 round 与 space 的区别：虽然都使背景完整显示，但是 space 在小方块之间有一定的空隙。<p>二维码:<br><img src=//misc.aotu.io/leeenx/border-image/qr4.png alt=二维码><h3 id=简写-border-image>简写：border-image</h3><p>语法：<pre class=nust-code><code class="hljs css">border-image: &lt;‘border-image-source’> || &lt;‘border-image-slice’> [ / &lt;‘border-image-width’> | / &lt;‘border-image-width’>? / &lt;‘border-image-outset’> ]? || &lt;‘border-image-repeat’></code></pre><p>简写其实没什么好说的，不过由于 border-image-slice、border-image-width 与 border-image-outset 这三者的参数相似，所以有必要说一下，这三个参数在简写里有两个注意点:<p><strong>一、 border-image-outset 参数一定要在 border-image-width 之后，假设border-image-width缺省，仍然需要在原来 border-image-width 写上 /</strong>，如下：<p>正确的写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image</span>: url(http://<span class=hljs-number>7</span>xv39r.com1.z0.glb.clouddn.com/box.png) <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> / / <span class=hljs-number>10px</span>;</code></pre><p>错误的写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image</span>: url(http://<span class=hljs-number>7</span>xv39r.com1.z0.glb.clouddn.com/box.png) <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> / <span class=hljs-number>10px</span>;<span class=hljs-comment>//这样写 10px会被当作 border-width</span></code></pre><p><strong>二、 如果有 border-image-width/ border-image-outset 属性值，border-image-slice必须指定数值，否则不合语法</strong>，如下：<p>正确的写法:<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image</span>: url(http://<span class=hljs-number>7</span>xv39r.com1.z0.glb.clouddn.com/box.png) <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> <span class=hljs-number>27</span> / <span class=hljs-number>10px</span> / <span class=hljs-number>10px</span>;</code></pre><p>错误的写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-attribute>border-image</span>: url(http://<span class=hljs-number>7</span>xv39r.com1.z0.glb.clouddn.com/box.png) / <span class=hljs-number>10px</span> / <span class=hljs-number>10px</span>;</code></pre><h3 id=后记>后记</h3><p>实践过程中遇到BUG：<p>safari浏览器下，border-color不能使用 <code>transparent</code> 与 <code>rgba(x,x,x, 0)</code>。否则，border-image 会失效。<p>补记于：2016.12.26<hr><p>参考资料：<ul><li><a href=https://www.w3.org/TR/2002/WD-css3-border-20021107/ >W3C Working Draft 7 November 2002</a><li><a href=https://www.w3.org/TR/2005/WD-css3-background-20050216/ >W3C Working Draft 16 February 2005</a><li><a href=https://www.w3.org/TR/css3-background/ >W3C Candidate Recommendation 9 September 2014</a><li><a href=http://www.tuicool.com/articles/EJZnUnm>css3：border-image边框图像详解</a><li><a href=http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/ >CSS3 border-image详解、应用及jQuery插件</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>AdobeMax 2016回顾</title>
      <link>https://aotu.io/notes/2016-11-03/AdobeMax2016</link>
      <guid>https://aotu.io/notes/2016-11-03/AdobeMax2016</guid>
      <pubDate>2016-11-02T21:22:23.000Z</pubDate>
      <description>
      
        今年AdobeMax大会有啥黑科技发布了？
      
      </description>
      
      <content:encoded><![CDATA[<p>今年的 AdobeMax 大会于美国时间 10.31-11.04 在加州第二大城市圣地亚哥举办。AdobeMax大会内容包括发布了Adobe Creative Cloud旗下一系列软件的新版本、实验性项目展示、从业人员交流等。今年的大会有什么有(hei)趣(ke)的(ji)发布了呢？让小编带你去逛一圈看看吧。<h2 id=1-photoshop-cc-2017-简称ps2017->1. Photoshop CC 2017（简称PS2017）</h2><p>首先介绍前端er每天都要接触到 Photoshop ，顺便赞一下 mac 版的安装速度，不到2min就搞定。PS2017 做了如下更新：<ol><li>扁平化 UI<li>更好的程序内搜索<li>无缝衔接 Adobe Experience Design<li>更好整合 Adobe 资源模板(Adobe stock)、云同步等等<li>更强大的抠图和液化功能<li>Apple Color Emoji，即支持了 emoji 编辑</ol><p>…………<p>大部分都和前端开发都不太沾边，小编很艰难的发现了几个沾边的：<ol><li>右键图层新菜单项“拷贝 SVG”，即可直接拷贝图层的 svg 代码<li>文件-导出-导出为（或右键图层“导出为”）面板选择保存 png 的时候可以直接勾选保存为 png8 格式</ol><p>顺便说一下 mac 下的 PS2017 的窗口用 sizeup 的快捷键调整也不会像之前那样不正确了，半屏、全屏切换正常。<h2 id=2-adobe-experience-design-cc-简称xd->2. Adobe Experience Design CC（简称XD）</h2><p>今年早些时候发布了预览版，仅支持 mac 。大会上新发布了新的 Beta 版，并且支持了 windows 。<p>XD 是一款矢量化图形设计、web & 移动 app 原型制作软件——嗯，据说就是死磕 Sketch 。特点是多种内置UI组件、各种酷炫效果、手机端实时预览效果等等。<p><img src=https://misc.aotu.io/cos2004/xd02.gif alt=xd演示><h2 id=3-character-animator-简称ch->3. Character Animator（简称Ch）</h2><p>Ch(Beta) 这是 Adobe 的一个新产品，可通过电脑摄像头来追踪用户的动作和面部表情，并将其<strong>实时应用</strong>在<strong>虚拟2D动画角色</strong>上，软件会自动完成动作之间的形变动画计算，无需软件使用者操心。大会上介绍这个软件的时候居然有一段是直播辛普森动画的，非常好玩。<p>小编并且亲自安装了 Ch 并体验了一遍内置的样例（根本停不下来），发现这个软件真的非常神奇。没了解过的同学强烈介意看一下这个视频了解一下其用途：<a href="http://www.tudou.com/programs/view/NI0b_-77LFo/?resourceId=7170904_06_02_99">点此观看</a><p>这个软件的大概工作流程是这样的：<p>Ch里新建 Puppet（new Puppet in Photoshop）——打开 PS 编辑角色(默认打开一个结构化图层的角色样例)——编辑后保存——返回 Ch 把 Puppet 拖入场景舞台——点击右上角的“set rest post”——点击场景面板的红色“录制”按钮，然后就到你尽情表演的时候啦……<p>以下是小编用样例录的一段“表演”：<p><img src=https://misc.aotu.io/cos2004/ch02.gif alt=Ch演示><p>所以以后直播网站里是不是要加上一个“二次元直播”频道？<h2 id=4-adobe-sensei>4. Adobe Sensei</h2><p>Adobe推出的智能云计算服务，Sensei并非一款单独的软件产品，而是一个可以应用于Adobe旗下各款产品的底层人工智能工具（如 Photoshop、Illustrator）。<p>该服务具体的内容是让软件明白某张照片、某张照片的一部分、某段视频以及某段文本描述的真实含义，帮助人们把一些固定、重复性的操作变得自动化和简单化。有了海量的分析数据，会让用户处理一些图像、视频、音频变得非常简单和智能，以前需要调整一堆参数才能实现的效果以后只需要几个简单的鼠标操作。下面将要提到的 ConceptCanvas、SkeyReplace 技术就是一个具体的应用方向。<h2 id=其他实验性项目>其他实验性项目</h2><p>以下介绍的技术还没正式面向用户，Adobe 每年都会在大会上推出一些实验性技术，相当一部分在接下来的几年里会推出面向大众的产品，比如XD就是2015年的实验性项目 Project Comet。<h2 id=1-conceptcanvas>1. ConceptCanvas</h2><p>先上一张图：<p><img src=https://misc.aotu.io/cos2004/conceptcanvas.jpg alt=大会上的ConceptCanvas操作照片><p>这是大会现场的一个截图，左边是PS界面，右边是一列是搜索结果。<p>可以看出这个搜索技术利用简单的<strong>图像关键字、构图、颜色、物体位置</strong>等信息进行素材搜索，素材来源由于版权原因估计短时间内只支持Adobe Stock。感觉这种搜索方式比常见的搜索引擎以图搜图更加容易被设计师接受，因为实在太简单直观了，有点佩服Adobe工程师的脑洞。<p><img src=https://misc.aotu.io/cos2004/conceptcanvas.gif alt=ConceptCanvas操作展示><p>要更直观的感受可以看一下这个演示视频：<a href="http://weibo.com/tv/v/EfXfrkIBc?fid=1034:3e9b36df345b5cc888217be00b9896cc">观看地址</a><p>很希望搜索引擎搜图也可以加入类似的技术，在海量图片的网络找图我们是不是可以更便捷、发挥更多想象力？<h2 id=2-project-voco>2. Project VoCo</h2><p>这是一个神奇的声音编辑软件，可以根据你录制好的一段音频（长度大约20分钟），系统会学习并模仿你的语气。然后输入你想说的文字，就可以根据文字内容输出一段你的声音的音频，听上去就像你真的说过这段话。<p>问题来了，以后声音造假和图像造假一样成本真的很低？你不想在朋友圈晒一段你和周杰伦的通话录音？<p><img src=https://misc.aotu.io/cos2004/voco.jpg alt=voco界面截图><p>这是VoCo现场演示的视频，<a href="http://weibo.com/tv/v/EfXwgFceZ?fid=1034:f36162fac196a13bde4953dc030f166a">点此观看</a><h2 id=3-intervector>3. InterVector</h2><p>从照片<strong>提取矢量数据</strong>的一种技术，如提取轮廓并调整、删除等，这是Illustrator目前正在开发的一部分功能。<p><img src=https://misc.aotu.io/cos2004/intervector.gif alt=InterVector操作><h2 id=4-skyreplace>4. SkyReplace</h2><p>即照片天空智能替换技术，以后婚纱照的真的一点也不怕坏天气？<p><img src=https://misc.aotu.io/cos2004/skyreplace.gif alt=skyreplace示意图><p>以上就是AdobeMax大会要介绍的主要内容，还有一些设计专业性很强的技术如Stylit、ColorChameleon、Wetbrush等，有兴趣的可以去下面的参考资料看看。<h2 id=参考资料>参考资料</h2><ol><li><a href=https://helpx.adobe.com/photoshop/using/whats-new.html>https://helpx.adobe.com/photoshop/using/whats-new.html</a><li><a href=https://twitter.com/adobemax>https://twitter.com/adobemax</a><li><a href=http://weibo.com/adobechina>http://weibo.com/adobechina</a><li><a href=https://tech.recruit-mp.co.jp/event/post-10848/ >https://tech.recruit-mp.co.jp/event/post-10848/</a><li><a href=http://web.cndesign.com/news/detail_698.html>http://web.cndesign.com/news/detail_698.html</a></ol>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>Javascript 中的装饰器</title>
      <link>https://aotu.io/notes/2016-10-25/decorator</link>
      <guid>https://aotu.io/notes/2016-10-25/decorator</guid>
      <pubDate>2016-10-24T20:49:11.000Z</pubDate>
      <description>
      
        麻麻说：写代码一定要优雅
      
      </description>
      
      <content:encoded><![CDATA[<h2 id=前言>前言</h2><p>在 ES6 中增加了对类对象的相关定义和操作（比如 <code>class</code> 和 <code>extends</code> ），这就使得我们在多个不同类之间共享或者扩展一些方法或者行为的时候，变得并不是那么优雅。这个时候，我们就需要一种更优雅的方法来帮助我们完成这些事情。<h2 id=python-中的装饰器>Python 中的装饰器</h2><p>decorators 即 装饰器，这一特性的提出来源于 python 之类的语言，如果你熟悉 python 的话，对它一定不会陌生。那么我们先来看一下 python 里的装饰器是什么样子的吧：<blockquote><p>A Python decorator is a function that takes another function, extending the behavior of the latter function without explicitly modifying it.</blockquote><p>装饰器是在 python 2.4 里增加的功能，它的主要作用是给一个已有的方法或类扩展一些新的行为，而不是去直接修改它本身。<p>听起来有点儿懵😳，“show me the code !”<pre class=nust-code><code class="hljs python"><span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>decorator</span><span class=hljs-params>(f)</span>:</span>
    <span class=hljs-keyword>print</span> <span class=hljs-string>"my decorator"</span>
    <span class=hljs-keyword>return</span> f

<span class=hljs-meta>@decorator</span>
<span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>myfunc</span><span class=hljs-params>()</span>:</span>
    <span class=hljs-keyword>print</span> <span class=hljs-string>"my function"</span>

myfunc()

<span class=hljs-comment># my decorator</span>
<span class=hljs-comment># my function</span></code></pre><p>这里的 <code>@decorator</code> 就是我们说的装饰器。在上面的代码中，我们利用装饰器给我们的目标方法执行前打印出了一行文本，并且并没有对原方法做任何的修改。代码基本等同于<pre class=nust-code><code class="hljs python"><span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>decorator</span><span class=hljs-params>(f)</span>:</span>
    <span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>wrapper</span><span class=hljs-params>()</span>:</span>
        <span class=hljs-keyword>print</span> <span class=hljs-string>"my decorator"</span>
        <span class=hljs-keyword>return</span> f()
    <span class=hljs-keyword>return</span> wrapper

<span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>myfunc</span><span class=hljs-params>()</span>:</span>
    <span class=hljs-keyword>print</span> <span class=hljs-string>"my function"</span>

myfunc = decorator(myfuc)</code></pre><p>通过代码我们也不难看出，装饰器 decorator 接收一个参数，也就是我们被装饰的目标方法，处理完扩展的内容以后再返回一个方法，供以后调用，同时也失去了对原方法对象的访问。当我们对某个应用了装饰以后，其实就改变了被装饰方法的入口引用，使其重新指向了装饰器返回的方法的入口点，从而来实现我们对原函数的扩展、修改等操作。<h2 id=引入到-javascript-中>引入到 Javascript 中</h2><p>那么我们了解到了装饰器在 python 中的表现以后，会不会觉得其实装饰器其实蛮简单的，就是一个 wrapper 嘛，对于 Javascript 这种语言来说，这种形态不是很常见吗，干嘛还要引入这么一个东西呢？<p>是的，在 ES6 之前，装饰器对于 JS 来说确实显得不太重要，你只是需要加几层 wrapper 包裹就好了（虽然也会显得不那么优雅）。但是正如文章开头所说，在 ES6 提出之后，你会发现，好像事情变得有些不同了。当我们需要在多个不同的类之间共享或者扩展一些方法或行为的时候，代码会变得错综复杂，极其不优雅，这也就是装饰器被提出的一个很重要的原因。<p>话说从装饰器被提出已经有一年多的时间了，同时期的很多其他新的特性已经随着 ES6 的推进而被大家广泛使用，而这货现在却还停留在 stage 2 的阶段，也很少被人提及和应用。那么，装饰器到底是在 Javascript 中是怎样表现的呢？我们下面来一起看一下吧！<h2 id=javascript-中的装饰器>Javascript 中的装饰器</h2><p>先来看一下装饰器在代码中是长成什么样子吧<pre class=nust-code><code class="hljs javascript">@decorator
<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Cat</span> </span>{}

<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Dog</span> </span>{
    @decorator
    run() {}
}</code></pre><p>嗯，代码中的 <code>@decorator</code> 就是 JS 中的装饰器，看起来基本和 python 中的样子一样，以 <code>@</code> 作为标识符，可以作用于类，也可以作用于类的属性。那么接下来，我们就来看看它具体的表现及运行原理吧。<h3 id=es6-中的类>ES6 中的类</h3><p>首先我们先来看一下关于 ES6 中的类吧<pre class=nust-code><code class="hljs javascript"><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Cat</span> </span>{
    say() {
        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"meow ~"</span>);
    }
}</code></pre><p>上面这段代码是 ES6 中定义一个类的写法，其实只是一个语法糖，而实际上当我们给一个类添加一个属性的时候，会调用到 <code>Object.defineProperty</code> 这个方法，它会接受三个参数：<code>target</code> 、<code>name</code> 和 <code>descriptor</code> ，所以上面的代码实际上在执行时是这样的：<pre class=nust-code><code class="hljs javascript"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Cat</span>(<span class=hljs-params></span>) </span>{}
<span class=hljs-built_in>Object</span>.defineProperty(Cat.prototype, <span class=hljs-string>"say"</span>, {
    <span class=hljs-attr>value</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{ <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"meow ~"</span>); },
    <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,
    <span class=hljs-attr>configurable</span>: <span class=hljs-literal>true</span>,
    <span class=hljs-attr>writable</span>: <span class=hljs-literal>true</span>
});</code></pre><p>好了，有了上面这段代码以后，我们再来看看装饰器在 JS 中到底是怎么样工作的吧！<h3 id=作用于类的装饰器>作用于类的装饰器</h3><p>当一个装饰器作用于类的时候，大概是这个样子的：<pre class=nust-code><code class="hljs javascript"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>isAnimal</span>(<span class=hljs-params>target</span>) </span>{
    target.isAnimal = <span class=hljs-literal>true</span>;
      <span class=hljs-keyword>return</span> target;
}

@isAnimal
<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Cat</span> </span>{
    ...
}

<span class=hljs-built_in>console</span>.log(Cat.isAnimal);    <span class=hljs-comment>// true</span></code></pre><p>是不是很像之前我们在 python 中看到的装饰器？<p>(๑•̀ㅂ•́)و✧<p>所以这段代码实际上基本等同于：<pre class=nust-code><code class="hljs javascript">Cat = isAnimal(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Cat</span>(<span class=hljs-params></span>) </span>{ ... });</code></pre><p>那么我们再来看一下作用于类的单个属性方法的装饰器<h3 id=作用于类属性的装饰器>作用于类属性的装饰器</h3><p>比如有的时候，我们希望把我们的部分属性置成只读，以避免别人对其进行修改，如果使用装饰器的话，我们可以这样来做：<pre class=nust-code><code class="hljs javascript"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>readonly</span>(<span class=hljs-params>target, name, descriptor</span>) </span>{
    discriptor.writable = <span class=hljs-literal>false</span>;
    <span class=hljs-keyword>return</span> discriptor;
}

<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Cat</span> </span>{
    @readonly
    say() {
        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"meow ~"</span>);
    }
}

<span class=hljs-keyword>var</span> kitty = <span class=hljs-keyword>new</span> Cat();

kitty.say = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"woof !"</span>);
}

kitty.say()    <span class=hljs-comment>// meow ~</span></code></pre><p>我们通过上面的代码把 <code>say</code> 方法设置成了只读，所以在我们后面再次对它赋值的时候就不会生效，调用的还是之前的方法。<p>在上面的代码中我们可以看到，我们在定义装饰器的时候，参数是有三个，<code>target</code>、<code>name</code>、<code>descriptor</code> 。<p>诶？等一下，这里怎么这么眼熟？⊙_⊙<p>没错，就是我们上文提到过的关于类的定义那一块儿的 <code>Object.defineProperty</code> 的参数，所以其实装饰器在作用于属性的时候，实际上是通过 <code>Object.defineProperty</code> 来进行扩展和封装的。<p>所以在上面的这段代码中，装饰器实际的作用形式是这样的：<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>let</span> descriptor = {
    <span class=hljs-attr>value</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"meow ~"</span>);
    },
    <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,
    <span class=hljs-attr>configurable</span>: <span class=hljs-literal>true</span>,
    <span class=hljs-attr>writable</span>: <span class=hljs-literal>true</span>
};

descriptor = readonly(Cat.prototype, <span class=hljs-string>"say"</span>, descriptor) || descriptor;

<span class=hljs-built_in>Object</span>.defineProperty(Cat.prototype, <span class=hljs-string>"say"</span>, descriptor);</code></pre><p>嗯嗯，是不是这样看就清楚很多了呢？这里也是 JS 里装饰器作用于类和作用于类的属性的不同的地方。<p>我们可以看出，当装饰器作用于类本身的时候，我们操作的对象也是这个类本身，而当装饰器作用于类的某个具体的属性的时候，我们操作的对象既不是类本身，也不是类的属性，而是它的描述符（descriptor），而描述符里记录着我们对这个属性的全部信息，所以，我们可以对它自由的进行扩展和封装，最后达到的目的呢，就和之前说过的装饰器的作用是一样的。<p>当然，如果你喜欢的话，也可以直接在 <code>target</code> 上进行扩展和封装，比如<pre class=nust-code><code class="hljs javascript"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fast</span>(<span class=hljs-params>target, name, descriptor</span>) </span>{
    target.speed = <span class=hljs-number>20</span>;

    <span class=hljs-keyword>let</span> run = descriptor.value;
    descriptor.value = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
        run();
        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>`speed <span class=hljs-subst>${<span class=hljs-keyword>this</span>.speed}</span>`</span>);
    }

    <span class=hljs-keyword>return</span> descriptor;
}

<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Rabbit</span> </span>{
    @fast
    run() {
        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"running~"</span>);
    }
}

<span class=hljs-keyword>var</span> bunny = <span class=hljs-keyword>new</span> Rabbit();

bunny.run();
<span class=hljs-comment>// running~</span>
<span class=hljs-comment>// speed 20</span>

<span class=hljs-built_in>console</span>.log(bunny.speed);   <span class=hljs-comment>// 20</span></code></pre><h2 id=小结>小结</h2><p>OK，让我们再来看一下 JS 里对于装饰器的描述吧：<blockquote><p>Decorators make it possible to annotate and modify classes and properties at design time.<p>A decorator is:<ul><li>an expression<li>that evaluates to a function<li>that takes the target, name, and decorator descriptor as arguments<li>and optionally returns a decorator descriptor to install on the target object</ul></blockquote><p>装饰器允许你在类和方法定义的时候去注释或者修改它。装饰器是一个作用于函数的表达式，它接收三个参数 <code>target</code>、 <code>name</code> 和 <code>descriptor</code> ， 然后可选性的返回被装饰之后的 <code>descriptor</code> 对象。<p>现在是不是对装饰器的作用及原理都清楚了呢？<p>最后一点就是，现在装饰器因为还在草案阶段，所以还没有被大部分环境支持，如果要用的话，需要使用 Babel 进行转码，需要用到 <code>babel-plugin-transform-decorators-legacy</code> 这个插件:<pre class=nust-code><code class="hljs bash">babel --plugins transform-decorators-legacy es6.js > es5.js</code></pre><p>如果你感兴趣的话，也可以看一下转码以后的代码，我这里就不做详细介绍了，很有帮助哦~<p>如果本文描述的有错误的地方，欢迎留言~ ヾ(o◕∀◕)ﾉ<h2 id=参考文献->参考文献:</h2><ul><li><a href=https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.cmajiy3p1>https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.cmajiy3p1</a><li><a href=https://github.com/wycats/javascript-decorators>https://github.com/wycats/javascript-decorators</a><li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a><li><a href="http://taobaofed.org/blog/2015/11/16/es7-decorator/?utm_source=tuicool&utm_medium=referral">http://taobaofed.org/blog/2015/11/16/es7-decorator/?utm_source=tuicool&utm_medium=referral</a><li><a href=https://github.com/jayphelps/core-decorators.js>https://github.com/jayphelps/core-decorators.js</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>CSS3 Mask 安利报告</title>
      <link>https://aotu.io/notes/2016-10-20/css3-mask</link>
      <guid>https://aotu.io/notes/2016-10-20/css3-mask</guid>
      <pubDate>2016-10-19T18:48:16.000Z</pubDate>
      <description>
      
        朋友，你听说过 CSS3 Mask 这个属性吗？
      
      </description>
      
      <content:encoded><![CDATA[<p>朋友，你听说过 CSS3 Mask 这个属性吗？ 没听说过？不是很了解？ 没关系，听我娓娓道来。<h2 id=1-mask-介绍>1. Mask 介绍</h2><blockquote><p>css遮罩是2008年4月由苹果公司添加到webkit引擎中的。遮罩提供一种基于像素级别的，可以控制元素透明度的能力，类似于png24位或png32位中的alpha透明通道的效果。<p>2012年11月15号，遮罩第一次出现在W3C公布的草案中。但是跟苹果公司的是不同的版本。</blockquote><p><em>摘录自: <a href=http://www.w3cplus.com/css3/css-masking.html>http://www.w3cplus.com/css3/css-masking.html</a></em><p>当前（2016.10.19）<code>mask</code> 处于 候选标准阶段（CR），还不是正式标准（REC），<strong>webkit/blink 内核加前缀 <code>-webkit-</code> 可使用</strong>。<h3 id=1-1-mask-的兼容性>1.1 Mask 的兼容性</h3><p>以下是来自 <a href="http://caniuse.com/#search=mask">caniuse</a>的统计：<p><img src=//misc.aotu.io/leeenx/1.png alt=caniuse><p>ie/edge 全面不支持，Android 和 iOS Safari 阵营几乎全线飘浅绿，意味着支持部分功能 。不过，Android 4.0 及以下版本的对 <code>mask</code> 的兼容性并不友好！多亏了近几年智能手机市场的良(e)性竞争，给移动前端制造了一个相对良好的环境，以下是 Android 各版本的市场占用率：<p><img src=//misc.aotu.io/leeenx/2.jpg alt=安卓各版本市场占有率><p>Android 4.0 以下版本的占有率不足 <strong>5%</strong>，已不在主流测试机型内可以忽略不计。<h3 id=1-2-mask-的原理>1.2 Mask 的原理</h3><p>蒙板可以是 CSS3 渐变或者半透明的PNG图片，蒙板元素的alpha值为0的时候会覆盖下面的元素，为1的时候会完全显示下面的内容。如下：<p><img src=//misc.aotu.io/leeenx/4.jpg alt="mask 原理"><h3 id=1-3-mask-的发展>1.3 Mask 的发展</h3><p>到目前为止，mask 在 W3C 上一共有6个版本（5个草案+1候选标准）,如下：<ul><li><a href=https://www.w3.org/TR/2012/WD-css-masking-20121115/ >W3C Working Draft 15 November 2012</a><li><a href=https://www.w3.org/TR/2013/WD-css-masking-20130620/ >W3C Working Draft 20 June 2013</a><li><a href=https://www.w3.org/TR/2013/WD-css-masking-1-20131029/ >W3C Last Call Working Draft, 29 October 2013</a><li><a href=https://www.w3.org/TR/2014/WD-css-masking-1-20140213/ >W3C Working Draft, 13 February 2014</a><li><a href=https://www.w3.org/TR/2014/WD-css-masking-1-20140522/ >W3C Last Call Working Draft, 22 May 2014</a><li><a href=https://www.w3.org/TR/2014/CR-css-masking-1-20140826/ >W3C Candidate Recommendation, 26 August 2014</a></ul><p>当前 <code>-webkit-mask</code> 的标准基本上等同于第一个WD（草案）。（有理由相信『<a href=https://www.w3.org/TR/2012/WD-css-masking-20121115/ >W3C Working Draft 15 November 2012</a>』参考了 webkit.org 的 『 <a href=https://webkit.org/blog/181/css-masks/ >CSS Masks</a>』）<h3 id=1-4-mask-语法>1.4 Mask 语法</h3><blockquote><p>Definitions of CSS properties and values in this specification are analogous to definitions in CSS Backgrounds and Borders [CSS3BG].</blockquote><p><em>摘录自: <a href=https://www.w3.org/TR/css-masking-1/#terminology>https://www.w3.org/TR/css-masking-1/#terminology</a></em><p>按 W3C 官网的说法，<code>mask</code> 的语法与 <code>background</code> 是相仿的。以下是 mask 与 background 属性的对照表：<table><thead><tr><th style=text-align:left>mask<th style=text-align:left>background<tbody><tr><td style=text-align:left>mask-clip<td style=text-align:left>background-clip<tr><td style=text-align:left>*mask-composite<td style=text-align:left>-<tr><td style=text-align:left>mask-image<td style=text-align:left>background-image<tr><td style=text-align:left>*mask-mode<td style=text-align:left>-<tr><td style=text-align:left>mask-origin<td style=text-align:left>background-origin<tr><td style=text-align:left>mask-position<td style=text-align:left>background-position<tr><td style=text-align:left>mask-repeat<td style=text-align:left>background-repeat<tr><td style=text-align:left>mask-size<td style=text-align:left>background-size<tr><td style=text-align:left>-<td style=text-align:left>background-attachment<tr><td style=text-align:left>-<td style=text-align:left>background-color</table><p>上表中，mask 与 background <strong>对应的六个属性在 webkit/blink 内核都能完全支持</strong>，并且与W3C的标准保持一致，语法与 <code>background</code> 相通。background 的语法不赘述。<h4 id=1-4-1-mask-mode-与-mask-composite->1.4.1 mask-mode 与 mask-composite：</h4><ul><li><code>mask-mode</code> 当前没有任何浏览器支持。<li><code>-webkit-mask-composite</code> 属性值与W3C不同， 参见：『 <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-composite>-webkit-mask-composite - CSS | MDN</a>』与 『<a href=https://developer.mozilla.org/en-US/docs/Web/CSS/mask-composite>mask-composite - CSS | MDN</a>』</ul><h4 id=1-4-2-mask-语法简写>1.4.2 mask 语法简写</h4><p>以下是 W3C 给出的标准简写：<pre class=nust-code><code class="hljs gherkin"><span class=hljs-variable>&lt;mask-layer></span> = <span class=hljs-variable>&lt;mask-reference></span> <span class=hljs-variable>&lt;masking-mode></span>? ||<span class=hljs-string> &lt;position> [ / &lt;bg-size> ]? </span>||
<span class=hljs-variable>&lt;repeat-style></span> ||<span class=hljs-string> &lt;geometry-box> </span>||<span class=hljs-string> [ &lt;geometry-box> </span>|<span class=hljs-string> no-clip ] </span>||<span class=hljs-string> &lt;compositing-operator></span></code></pre><p>对照一下 <code>background</code> 常用写法，又可以简化为：<pre class=nust-code><code class="hljs accesslog">mask: <span class=hljs-string>[mask-image]</span> <span class=hljs-string>[mask-repeat]</span> <span class=hljs-string>[mask-position]</span> / <span class=hljs-string>[ mask-size]</span>;</code></pre><p><strong>相信很多人都知道：部分安卓机型 background 简写不支持 background-size，需要单独写一个 background-size。同样的这部分安卓机也要求 mask-size 要单独写，所以 mask 的简写应该是：</strong><pre class=nust-code><code class="hljs accesslog">mask: <span class=hljs-string>[mask-image]</span> <span class=hljs-string>[mask-repeat]</span> <span class=hljs-string>[mask-position]</span>;
mask-size: <span class=hljs-string>[mask-size]</span>;</code></pre><h2 id=2-图标的一个便捷选项>2. 图标的一个便捷选项</h2><p>图标的主流方案有两种：Icon-Font 和 SVG Sprite。凹凸实验室推荐使用 SVG Sprite，具体参见 @高大师 的大作『 <a href=https://aotu.io/notes/2016/07/09/SVG-Symbol-component-practice/ >拥抱Web设计新趋势：SVG Sprites实践应用</a>』。<p>笔者看来，这两种方案存在一个前提：<strong>图标必须是矢量图</strong>。这其实是道门槛，不是所有团队/个人都跨得过去的。 本节将介绍一个低成本的方案：<strong>Mask Icon</strong><h3 id=2-1-mask-icon>2.1 Mask Icon</h3><p>素材icon.png : <img src=//misc.aotu.io/leeenx/form_sicon_select.png alt="原始png icon"><p>SASS源码：<pre class=nust-code><code class="hljs scss"><span class=hljs-comment>// 生成 黑、红、黄、蓝四个 icon。</span>
<span class=hljs-selector-class>.icon</span> {
    <span class=hljs-attribute>display</span>: inline-block;
    <span class=hljs-attribute>width</span>: <span class=hljs-number>30px</span>;
    <span class=hljs-attribute>height</span>: <span class=hljs-number>30px</span>;
    <span class=hljs-attribute>background-color</span>: black; <span class=hljs-comment>// 控制图标的颜色</span>
    -webkit-<span class=hljs-attribute>mask</span>: url(images/icon.png) <span class=hljs-number>0</span> <span class=hljs-number>0</span> no-repeat;
    -webkit-<span class=hljs-attribute>mask</span>-size: <span class=hljs-number>100%</span> <span class=hljs-number>100%</span>;
    &<span class=hljs-selector-class>.red</span> {
        <span class=hljs-attribute>background-color</span>: red;
    }
    &<span class=hljs-selector-class>.yellow</span> {
        <span class=hljs-attribute>background-color</span>: yellow;
    }
    &<span class=hljs-selector-class>.blue</span> {
        <span class=hljs-attribute>background-color</span>: blue;
    }
}</code></pre><p>HTML源码：<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon red"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon yellow"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon blue"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><p>截图如下： <img src=//misc.aotu.io/leeenx/5.jpg alt=四色icon><p>使用起来跟 Icon-Font 是很类似，不过 <code>mask</code>方案是通过 <code>background-color</code> 控制 icon 颜色，而 Icon-Font 是通过 <code>color</code>。 <code>color</code> 比 <code>background-color</code> 有优势，它可以继承当前文本的色值，而 background-color 却无法继承文本色值（因为继承当前文本的背景色等同于透明）。<h3 id=2-2-mask-icon-improve>2.2 Mask Icon improve</h3><p>能实现通过 <code>color</code> 来改变 <code>mask</code> icon 的颜色吗？<p>大神张鑫旭在『<a href=http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/ >currentColor-CSS3超高校级好用CSS变量</a>』给出了答案：currentColor。<pre class=nust-code><code class="hljs scss"><span class=hljs-selector-tag>p</span> {
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span>;
    <span class=hljs-attribute>padding</span>: <span class=hljs-number>10px</span>;
    <span class=hljs-attribute>color</span>: <span class=hljs-number>#000</span>;
    <span class=hljs-attribute>font-size</span>: <span class=hljs-number>14px</span>;
}

<span class=hljs-selector-class>.icon</span> {
    <span class=hljs-attribute>display</span>: inline-block;
    <span class=hljs-attribute>width</span>: <span class=hljs-number>15px</span>;
    <span class=hljs-attribute>height</span>: <span class=hljs-number>15px</span>;
    <span class=hljs-attribute>background-color</span>: currentColor; <span class=hljs-comment>// 控制图标的颜色 - 默认当前color值</span>
    -webkit-<span class=hljs-attribute>mask</span>: url(images/icon.png) <span class=hljs-number>0</span> <span class=hljs-number>0</span> no-repeat;
    -webkit-<span class=hljs-attribute>mask</span>-size: <span class=hljs-number>100%</span> <span class=hljs-number>100%</span>;
}

<span class=hljs-selector-class>.red</span> {
    <span class=hljs-attribute>color</span>: red;
}
<span class=hljs-selector-class>.yellow</span> {
    <span class=hljs-attribute>color</span>: yellow;
}
<span class=hljs-selector-class>.blue</span> {
    <span class=hljs-attribute>color</span>: blue;
}</code></pre><pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span>这个是黑色icon<span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>p</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"red"</span>></span>这个是红色icon<span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>p</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"yellow"</span>></span>这个是黄色icon<span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>p</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"blue"</span>></span>这个是蓝色icon<span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"icon"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span></code></pre><p><img src=//misc.aotu.io/leeenx/6.png alt=color继承图标><p>通过改进mask 图标几乎可以取代 Icon-Font。<p><strong>测试DEMO：</strong><p><img src=//misc.aotu.io/leeenx/17.jpg alt=二维码><h3 id=2-3-mask-icon-的局限>2.3 Mask Icon 的局限</h3><p>浏览器兼容是 <code>CSS3 Mask</code> 的最大局限，以 <code>mask-image</code> 为例，浏览器的支持情况如下：<p>PC端： <img src=//misc.aotu.io/leeenx/7.png alt=Desktop><p>移动端： <img src=//misc.aotu.io/leeenx/8.png alt=Desktop><p>webkit 两兄弟支持 <code>mask-image</code> ，而 firefox 和 ie/edge 需要通过 SVG Mask 来实现蒙层。<p>移动端 ≈ Android + iOS， <code>Mask Icon</code> 可当作为移动端的一个便捷方案。<h2 id=3-多蒙层介绍>3. 多蒙层介绍</h2><blockquote><p>The mask of a box can have multiple layers. The number of layers is determined by the number of comma-separated values in the ‘mask-image’ property.</blockquote><p><em>摘录自：<a href=https://www.w3.org/TR/2012/WD-css-masking-20121115/#layering>https://www.w3.org/TR/2012/WD-css-masking-20121115/#layering</a></em><p>按W3C的定义，mask 可设置多蒙层 。由于缺少多蒙层的兼容性数据，笔者做了一个简单的例子来检验多蒙层在不同机型下的表现。<p><strong>目标图形：</strong> <img src=//misc.aotu.io/leeenx/9.png alt=目标图形><p><strong>素材：</strong> <img src=//misc.aotu.io/leeenx/seckill_coupon_100px.png alt=100px> <img src=//misc.aotu.io/leeenx/seckill_coupon_ellipsis.png alt=100px><p><strong>测试用机：</strong><p>iPhone 6/6+（iOS 10）、 荣耀3c（Android 4.2.2）、 红米（Android 4.4.4 ）、魅蓝（Android 4.4.4） 三星GT-I9300（Android 4.3）、Microsoft Limia RM-1090（windows mobile）<p>测试代码如下:<pre class=nust-code><code class="hljs scss"><span class=hljs-selector-class>.seckill_coupon</span> {
    <span class=hljs-attribute>width</span>: (<span class=hljs-number>718px</span> / <span class=hljs-number>2</span>);
    <span class=hljs-attribute>height</span>: auto;
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span> auto;
    <span class=hljs-attribute>font-size</span>: <span class=hljs-number>0</span>;
    <span class=hljs-attribute>font-family</span>: Helvetica;
    &_item {
        <span class=hljs-attribute>width</span>: (<span class=hljs-number>226px</span> / <span class=hljs-number>2</span>);
        <span class=hljs-attribute>height</span>: ( <span class=hljs-number>120px</span> / <span class=hljs-number>2</span> );
        <span class=hljs-attribute>display</span>: inline-block;
        -webkit-<span class=hljs-attribute>mask</span>-image: url(images/seckill_coupon_ellipsis.png?__inline), url(images/seckill_coupon_100px.png?__inline), url(images/seckill_coupon_ellipsis.png?__inline);
        -webkit-<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>position</span>: (<span class=hljs-number>190px</span> / <span class=hljs-number>2</span>) -<span class=hljs-number>5px</span>, <span class=hljs-number>0</span> <span class=hljs-number>5px</span>, (<span class=hljs-number>190px</span> / <span class=hljs-number>2</span>) <span class=hljs-number>55px</span>;
        -webkit-<span class=hljs-attribute>mask</span>-repeat: repeat-x, no-repeat, repeat-x;
        -webkit-<span class=hljs-attribute>mask</span>-size: (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto, (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto, (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto;
        &_top {
            <span class=hljs-attribute>background</span>: <span class=hljs-number>#f2f7f7</span> linear-gradient(to bottom, <span class=hljs-number>#fafcfc</span>, <span class=hljs-number>#f2f7f7</span>);
            <span class=hljs-attribute>border-radius</span>: <span class=hljs-number>3px</span> <span class=hljs-number>3px</span> <span class=hljs-number>0</span> <span class=hljs-number>0</span>;
            <span class=hljs-attribute>height</span>: ( <span class=hljs-number>70px</span> / <span class=hljs-number>2</span> );
            <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
        }
        &_bottom {
            <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
            <span class=hljs-attribute>height</span>: ( <span class=hljs-number>50px</span> / <span class=hljs-number>2</span> );
            <span class=hljs-attribute>border-radius</span>: <span class=hljs-number>0</span> <span class=hljs-number>0</span> <span class=hljs-number>3px</span> <span class=hljs-number>3px</span>;
            <span class=hljs-attribute>background-image</span>: linear-gradient(to bottom, <span class=hljs-number>#ff9600</span>, <span class=hljs-number>#ff7c00</span>);
        }
    }
}</code></pre><pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item_top"</span>></span>

    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item_bottom"</span>></span>

    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><p><strong>测试结果：</strong><table><thead><tr><th style=text-align:center>设备<th style=text-align:center>浏览器<th style=text-align:center>支持度<th style=text-align:center>截图<tbody><tr><td style=text-align:center>iPhone 6/6+<br>(iOS 9/10)<td style=text-align:center>Safari/WeChat<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>魅蓝<br>(Android 4.4.4)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>魅蓝<br>(Android 4.4.4)<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>红米<br>(Android 4.4.4)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>红米<br>(Android 4.4.4)<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>三星GT-I9300<br>（Android 4.3）<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>三星GT-I9300<br>（Android 4.3）<td style=text-align:center>原生浏览器<td style=text-align:center>不友好<td style=text-align:center><img src="//misc.aotu.io/leeenx/11.png?v=2"alt=success><tr><td style=text-align:center>荣耀3c<br>(Android 4.2.2)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>荣耀3c<br>(Android 4.2.2)<td style=text-align:center>原生浏览器<td style=text-align:center>不友好<td style=text-align:center><img src="//misc.aotu.io/leeenx/11.png?v=2"alt=success><tr><td style=text-align:center>Lumia RM-1090<br>（windows mobile）<td style=text-align:center>ie<td style=text-align:center>不支持<td style=text-align:center><img src="//misc.aotu.io/leeenx/12.png?v=1"alt=fail></table><p><strong>测试解读：</strong><p>虽然测试的机型不多，但仍然可以看出 Android 4.3及以下版本原生浏览器对多蒙层的支持<strong>不友好</strong>，windows mobile是 <strong>不支持</strong>，而使用 <code>X5</code>内核的 WeChat 6.3.25对多蒙层的支持度是良好的。<p>将 <strong>取消多蒙层</strong> 视作 多蒙层的降级以处理<strong>不友好</strong>的机型：<p><img src=//misc.aotu.io/leeenx/10.png alt=success> <span style=position:relative;top:-55px>-- 降级 -></span> <img src="//misc.aotu.io/leeenx/12.png?v=2"alt=success><p>通过 <code>@supports</code> 来做降级处理：<pre class=nust-code><code class="hljs scss">@supports (-webkit-mask-repeat: repeat) {
    -webkit-<span class=hljs-attribute>mask</span>-image: url(images/seckill_coupon_ellipsis.png?__inline), url(images/seckill_coupon_100px.png?__inline), url(images/seckill_coupon_ellipsis.png?__inline);
    -webkit-<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>position</span>: (<span class=hljs-number>190px</span> / <span class=hljs-number>2</span>) -<span class=hljs-number>5px</span>, <span class=hljs-number>0</span> <span class=hljs-number>5px</span>, (<span class=hljs-number>190px</span> / <span class=hljs-number>2</span>) <span class=hljs-number>55px</span>;
    -webkit-<span class=hljs-attribute>mask</span>-repeat: repeat-x, no-repeat, repeat-x;
    -webkit-<span class=hljs-attribute>mask</span>-size: (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto, (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto, (<span class=hljs-number>750px</span> / <span class=hljs-number>2</span>) auto;
}</code></pre><p>不过，使用 @supports 后，（荣耀3c与三星 GT I9300的）X5内核也被降级，这并不是最理想的结果。以下是测试DEMO：<p><img src="//misc.aotu.io/leeenx/15.png?v=3"alt=二维码> （未使用 @supports 降级）<p><img src="//misc.aotu.io/leeenx/14.png?v=3"alt=二维码> （使用 @supports 降级）<p><strong>测试结论</strong><ol><li>微信手Q平台，使用多蒙层是友好的<li>非X5内核平台，目前不建议多蒙层</ol><h2 id=4-mask-border-image-介绍>4. Mask border image 介绍</h2><p>在实际项目中，笔者经常使用 <code>border-image</code> 来实现 background 没办法简单实现的需求。mask 有一个 <code>mask-border</code> 的成员与 border-image 相对应，具体可参见：<a href=https://www.w3.org/TR/css-masking/#mask-borders。>https://www.w3.org/TR/css-masking/#mask-borders。</a><p>现阶段（2016.10.19），未有任何主流浏览器直接支持 mask-border，因为在 mask 草案(WD)的漫长修改过程中，mask-border 经历了两次名称的变更，具体过程如下：<p><a href=https://www.w3.org/TR/2012/WD-css-masking-20121115/ >W3C Working Draft 15 November 2012</a> -- <strong>mask-box-image</strong> <a href=https://www.w3.org/TR/2013/WD-css-masking-20130620/ >W3C Working Draft 20 June 2013</a> -- mask-box-image <a href=https://www.w3.org/TR/2013/WD-css-masking-1-20131029/ >W3C Last Call Working Draft, 29 October 2013</a> -- mask-box-image <a href=https://www.w3.org/TR/2014/WD-css-masking-1-20140213/ >W3C Working Draft, 13 February 2014</a> -- <strong>mask-box</strong> <a href=https://www.w3.org/TR/2014/WD-css-masking-1-20140522/ >W3C Last Call Working Draft, 22 May 2014</a> -- <strong>mask-border</strong> <a href=https://www.w3.org/TR/2014/CR-css-masking-1-20140826/ >W3C Candidate Recommendation, 26 August 2014</a> -- mask-border<p>这个过程与 <code>flex</code> 是相似的。 当前 webkit/blink 内核 （Chrome/Safari）采用了第一个WD（草案）的 <code>mask-box-image</code>。不过，<code>mask-border</code>代表了未来，所以在写 css 时少不了兼容的代码，这个后面会介绍到。<h3 id=4-1-mask-border-的语法>4.1 Mask-border 的语法</h3><blockquote><p>The syntax of mask-border corresponds to the border-image property of CSS Background and Borders [CSS3BG].</blockquote><p><em>摘录自: <a href=https://www.w3.org/TR/css-masking-1/#mask-borders>https://www.w3.org/TR/css-masking-1/#mask-borders</a></em><p><strong>*为了方便描述，本章的 mask-border 都是指 mask-box-image ，读者自觉替换</strong><p>mask-border 与 border-image 的对照列表如下：<table><thead><tr><th style=text-align:left>mask-border<th style=text-align:left>border-image<tbody><tr><td style=text-align:left>mask-border-source<td style=text-align:left>border-image-source<tr><td style=text-align:left>*mask-border-mode<td style=text-align:left>-<tr><td style=text-align:left>mask-border-slice<td style=text-align:left>border-image-slice<tr><td style=text-align:left>mask-border-width<td style=text-align:left>border-image-width<tr><td style=text-align:left>mask-border-outset<td style=text-align:left>border-image-outset<tr><td style=text-align:left>mask-border-repeat<td style=text-align:left>border-image-repeat</table><p><code>mask-border-mode</code> 是在『 <a href=https://www.w3.org/TR/2014/WD-css-masking-1-20140522/ >W3C Last Call Working Draft, 22 May 2014</a> 』才出现的属性，当前没有任何浏览器支持 ，所以 mask-border 与 border-image 在语法上是完全相通！理解了 border-image就理解了 mask-border 。border-image 的具体使用可以参考MDN的『<a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image>border-image - CSS | MDN</a>』，这里也不赘述。<h3 id=4-2-mask-border-的兼容写法>4.2 Mask-border 的兼容写法</h3><p>如果是手写 css 的同学，在使用 mask-border 需要注意代码的兼容性。其实很简单如下：<pre class=nust-code><code class="hljs scss"><span class=hljs-comment>// 当下标准</span>
-webkit-<span class=hljs-attribute>mask</span>-box-image-source: url(images/seckill_coupon_half.png?__inline);
-webkit-<span class=hljs-attribute>mask</span>-box-image-slice: <span class=hljs-number>9</span> <span class=hljs-number>44</span> <span class=hljs-number>9</span> <span class=hljs-number>1</span> fill;
-webkit-<span class=hljs-attribute>mask</span>-box-image-<span class=hljs-attribute>width</span>: <span class=hljs-number>5px</span> <span class=hljs-number>23px</span> <span class=hljs-number>5px</span> <span class=hljs-number>5px</span>;
-webkit-<span class=hljs-attribute>mask</span>-box-image-repeat: stretch stretch;

<span class=hljs-comment>// 兼容未来</span>
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-source: url(images/seckill_coupon_half.png?__inline);
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-slice: <span class=hljs-number>9</span> <span class=hljs-number>44</span> <span class=hljs-number>9</span> <span class=hljs-number>1</span> fill;
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border-width</span>: <span class=hljs-number>5px</span> <span class=hljs-number>23px</span> <span class=hljs-number>5px</span> <span class=hljs-number>5px</span>;
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-repeat: stretch stretch;</code></pre><p>如果是使用 <code>sass</code>、<code>less</code> 的同学，推荐安装 autoprefixer 插件。<code>autoprefixer</code> 可以为使用者解决 css 兼容写法的烦恼，有了它，mask-border 可以直接使用<strong>兼容未来</strong>写法：<pre class=nust-code><code class="hljs scss"><span class=hljs-comment>// 在安装了 autoprefixer 后</span>
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-source: url(images/seckill_coupon_half.png?__inline);
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-slice: <span class=hljs-number>9</span> <span class=hljs-number>44</span> <span class=hljs-number>9</span> <span class=hljs-number>1</span> fill;
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border-width</span>: <span class=hljs-number>5px</span> <span class=hljs-number>23px</span> <span class=hljs-number>5px</span> <span class=hljs-number>5px</span>;
<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-repeat: stretch stretch;</code></pre><h3 id=4-3-mask-border-实例>4.3 Mask-border 实例</h3><p>上节多蒙层的例子使用 mask-border 来实现会更合适：<p><strong>目标图形：</strong> <img src=//misc.aotu.io/leeenx/9.png alt=目标图形><p><strong>素材：</strong> <img src=//misc.aotu.io/leeenx/seckill_coupon_half.png alt=素材><p><strong>测试用机：</strong><p>iPhone 6/6+（iOS 10）、 荣耀3c（Android 4.2.2）、 红米（Android 4.4.4 ）、魅蓝（Android 4.4.4） 三星GT-I9300（Android 4.3）、Microsoft Limia RM-1090（windows mobile）<p><strong>测试代码：</strong><pre class=nust-code><code class="hljs scss"><span class=hljs-selector-class>.seckill_coupon</span> {
    <span class=hljs-attribute>width</span>: (<span class=hljs-number>718px</span> / <span class=hljs-number>2</span>);
    <span class=hljs-attribute>height</span>: auto;
    <span class=hljs-attribute>margin</span>: <span class=hljs-number>0</span> auto;
    <span class=hljs-attribute>font-size</span>: <span class=hljs-number>0</span>;
    <span class=hljs-attribute>font-family</span>: Helvetica;
    &_item {
        <span class=hljs-attribute>width</span>: (<span class=hljs-number>226px</span> / <span class=hljs-number>2</span>);
        <span class=hljs-attribute>height</span>: ( <span class=hljs-number>120px</span> / <span class=hljs-number>2</span> );
        <span class=hljs-attribute>display</span>: inline-block;
        <span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-source: url(images/seckill_coupon_half.png?__inline);
        <span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-slice: <span class=hljs-number>9</span> <span class=hljs-number>44</span> <span class=hljs-number>9</span> <span class=hljs-number>1</span> fill;
        <span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border-width</span>: <span class=hljs-number>5px</span> <span class=hljs-number>23px</span> <span class=hljs-number>5px</span> <span class=hljs-number>5px</span>;
        &_top {
            <span class=hljs-attribute>background</span>: <span class=hljs-number>#f2f7f7</span> linear-gradient(to bottom, <span class=hljs-number>#fafcfc</span>, <span class=hljs-number>#f2f7f7</span>);
            <span class=hljs-attribute>border-radius</span>: <span class=hljs-number>3px</span> <span class=hljs-number>3px</span> <span class=hljs-number>0</span> <span class=hljs-number>0</span>;
            <span class=hljs-attribute>height</span>: ( <span class=hljs-number>70px</span> / <span class=hljs-number>2</span> );
            <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
        }
        &_bottom {
            <span class=hljs-attribute>width</span>: <span class=hljs-number>100%</span>;
            <span class=hljs-attribute>height</span>: ( <span class=hljs-number>50px</span> / <span class=hljs-number>2</span> );
            <span class=hljs-attribute>border-radius</span>: <span class=hljs-number>0</span> <span class=hljs-number>0</span> <span class=hljs-number>3px</span> <span class=hljs-number>3px</span>;
            <span class=hljs-attribute>background-image</span>: linear-gradient(to bottom, <span class=hljs-number>#ff9600</span>, <span class=hljs-number>#ff7c00</span>);
        }
    }
}</code></pre><pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon"</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item_top"</span>></span>

    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"seckill_coupon_item_bottom"</span>></span>

    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><p>以下是测试DEMO:<p><img src=//misc.aotu.io/leeenx/16.png alt=DEMO3><p><strong>测试结果：</strong><table><thead><tr><th style=text-align:center>设备<th style=text-align:center>浏览器<th style=text-align:center>支持度<th style=text-align:center>截图<tbody><tr><td style=text-align:center>iPhone 6/6+<br>(iOS 9/10)<td style=text-align:center>Safari/WeChat<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>魅蓝<br>(Android 4.4.4)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>魅蓝<br>(Android 4.4.4)<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>红米<br>(Android 4.4.4)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>红米<br>(Android 4.4.4)<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>三星GT-I9300<br>（Android 4.3）<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>三星GT-I9300<br>（Android 4.3）<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>荣耀3c<br>(Android 4.2.2)<td style=text-align:center>WeChat 6.3.25<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>荣耀3c<br>(Android 4.2.2)<td style=text-align:center>原生浏览器<td style=text-align:center>支持<td style=text-align:center><img src=//misc.aotu.io/leeenx/10.png alt=success><tr><td style=text-align:center>Lumia RM-1090<br>（windows mobile）<td style=text-align:center>ie<td style=text-align:center>不支持<td style=text-align:center><img src="//misc.aotu.io/leeenx/12.png?v=1"alt=fail></table><p><strong>测试结论</strong> <code>mask-border</code> 在移动端的兼容性很好，推荐使用。<h2 id=5-mask-border-image-实践补记>5. Mask border image 实践补记</h2><p>本章补录于： 2016.12.26<h3 id=5-1-安卓的一个-hack>5.1 安卓的一个 hack</h3><p>笔者在实践过程中发现 mask border image 在低端机上的表现并不如做测试那么好。例如在荣耀3C中，如果页面比较多东西 mask border image 会失效，这个时候需要有个 hack 来解决这个问题。以下是笔者写的 hack(scss):<pre class=nust-code><code class="hljs scss"><span class=hljs-comment>/*请保证应用mask border image 的元素或伪元素没使用 3d 加速*/</span>
%<span class=hljs-attribute>mask</span>-<span class=hljs-attribute>border</span>-hack {
    <span class=hljs-attribute>filter</span>: blur(<span class=hljs-number>0</span>);
    <span class=hljs-attribute>transform</span>: translate3d(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, <span class=hljs-number>0</span>);
    @supports(-webkit-mask-repeat: repeat) {
        <span class=hljs-comment>// 高端安卓 与 ios 能识别</span>
        <span class=hljs-attribute>filter</span>: none;
    }
}</code></pre><p>上述 hack 有个前提: 应用 <code>mask-border</code> 的元素/伪元素 没使用3d加速。<h3 id=5-2-安全建议>5.2 安全建议</h3><ol><li><code>mask-border</code> 目前不适合应用到复杂节点中去。<li>如果 ::before/::after 应用 <code>mask-border</code> ，建议单独新建一个 div，并使用它的 ::before/::after 来做 <code>mask-border</code>，如下：</ol><p>CSS:<pre class=nust-code><code class="hljs css">.mask {
    filter: blur(0);
    transform: translate3d(0, 0, 0);
    @supports(-webkit-mask-repeat: repeat) {
        // 高端安卓 与 ios 能识别
        filter: none;
    }
}

.mask::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100px;
    height: 100px;
    z-index: 3;
    background-color: #ff0;
    pointer-events: none;
    mask-border: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAABlBMVEUAAADxVZe4xg/eAAAAAXRSTlMAQObYZgAAAFdJREFUKM9j+H/8Pwh8YGhwYWBgYFIQwMdo/3+AgcH+nwBDi4sDA4OSEjbGf7AaoIEsYF1KDJgMuBp85rQfB6qxswPazgAGw44B9SAdAhMRccTEMjxJAACiVld1wtGnfgAAAABJRU5ErkJggg==) 18/9px stretch;
}</code></pre><p>HTML:<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>!—</span> 把<span class=hljs-attr>box</span>的<span class=hljs-attr>::after</span>转移动到 <span class=hljs-attr>mask</span> 的 <span class=hljs-attr>::after</span> 中去，再加 <span class=hljs-attr>mask</span> 加一个<span class=hljs-attr>hack</span>  <span class=hljs-attr>--</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>“box”</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>class</span>=<span class=hljs-string>“mask”</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></code></pre><hr><h2 id=参考资料>参考资料</h2><p><a href=https://webkit.org/blog/181/css-masks/ >CSS Masks</a> <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-composite>-webkit-mask-composite - CSS | MDN</a> <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/mask-composite>mask-composite - CSS | MDN</a> <a href=https://www.w3.org/TR/css-masking-1/ >CSS Masking Module Level 1</a> <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/mask>mask - CSS | MDN</a> <a href=https://aotu.io/notes/2016/07/09/SVG-Symbol-component-practice/ >拥抱Web设计新趋势：SVG Sprites实践应用</a> <a href=http://edu.yjbys.com/B658165160951/news/nres5691.html>ICON-FONT图标字体的四类制作方法</a> <a href=http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/ >currentColor-CSS3超高校级好用CSS变量</a> <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image>-webkit-mask-box-image - CSS | MDN</a> <a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image>border-image - CSS | MDN</a>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>Vue2.0 新手完全填坑攻略——从环境搭建到展示豆瓣的电影列表</title>
      <link>https://aotu.io/notes/2016-10-13/vue2</link>
      <guid>https://aotu.io/notes/2016-10-13/vue2</guid>
      <pubDate>2016-10-13T10:31:35.000Z</pubDate>
      <description>
      
        这是一篇基于Vue2.0的新手入门文章，通过Demo实例介绍了Vue2.0的环境搭建及展示豆瓣的电影列表的过程。
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Jinkey原创 感谢 <a href=https://github.com/showonne>showonne</a>、<a href=https://github.com/yubang>yubang</a> 技术指导 <strong>Demo 地址:</strong> <a href=http://demo.jinkey.io/vue2>http://demo.jinkey.io/vue2</a> <strong>源码:</strong> <a href=https://github.com/Jinkeycode/vue2-example>https://github.com/Jinkeycode/vue2-example</a></blockquote><h2 id=什么是-vue>什么是 Vue</h2><p>Vue 是一个前端框架，特点是<p><strong>数据绑定</strong><blockquote><p>比如你改变一个输入框 Input 标签的值，会<strong>自动同步</strong>更新到页面上其他绑定该输入框的组件的值 ￼ <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-17-43.png alt=数据绑定></blockquote><p><strong>组件化</strong><blockquote><p>页面上小到一个按钮都可以是一个单独的文件.vue，这些小组件直接可以像乐高积木一样通过互相引用而组装起来</blockquote><p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-10-59-15.jpg alt=组件化> ￼<h2 id=vue2-0-推荐开发环境>Vue2.0 推荐开发环境</h2><p>￼ <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-36-06.png alt=开发环境解释><p>Homebrew 1.0.6(Mac)、Node.js 6.7.0、npm 3.10.3、webpack 1.13.2、vue-cli 2.4.0、Atom 1.10.2<h2 id=安装环境>安装环境</h2><p>打开终端运行以下命令<h3 id=安装brew>安装brew</h3><pre class=nust-code><code class="hljs awk"><span class=hljs-regexp>/usr/</span>bin<span class=hljs-regexp>/ruby -e "$(curl -fsSL https:/</span><span class=hljs-regexp>/raw.githubusercontent.com/</span>Homebrew<span class=hljs-regexp>/install/m</span>aster<span class=hljs-regexp>/install)"</span></code></pre><h3 id=安装-nodejs>安装 nodejs</h3><blockquote><p>brew install nodejs</blockquote><p>用 npm install npm@3.10.3 更新 npm 版本报错:<blockquote><p>(node:42) fs: re-evaluating native module sources is not supported.</blockquote><p>解决办法:<p>在官网下载6.70的安装包再安装一次(刚刚相当于帮你配置好环境变量，现在再安装一次升级到最新的 npm)<blockquote><ul><li>好像以前官网的安装包不会自动配置环境变量的，由于我电脑上之前安装过 nodejs 所以环境变量已经配置好了，不知道现在的安装包会不会自动配置环境变量。</ul></blockquote><p>Windows 下直接下载安装包即可<h3 id=获取nodejs模块安装目录访问权限>获取nodejs模块安装目录访问权限</h3><pre class=nust-code><code class="hljs crystal">sudo chmod -R <span class=hljs-number>777</span> /usr/local/<span class=hljs-class><span class=hljs-keyword>lib</span>/<span class=hljs-title>node_modules</span>/</span></code></pre><h3 id=安装淘宝镜像>安装淘宝镜像</h3><blockquote><p>npm install -g cnpm --registry=<a href=https://registry.npm.taobao.org>https://registry.npm.taobao.org</a></blockquote><h3 id=安装webpack>安装webpack</h3><blockquote><p>cnpm install webpack -g</blockquote><h3 id=安装vue脚手架>安装vue脚手架</h3><blockquote><p>npm install vue-cli -g</blockquote><h3 id=在硬盘上找一个文件夹放工程用的-在终端中进入该目录>在硬盘上找一个文件夹放工程用的，在终端中进入该目录</h3><p>Mac<blockquote><p>cd 目录路径</blockquote><h3 id=根据模板创建项目>根据模板创建项目</h3><blockquote><p>vue init webpack-simple 工程名字&lt;工程名字不能用中文></blockquote><p>或者创建 vue1.0 的项目<blockquote><p>vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文></blockquote><p>会有一些初始化的设置，如下输入:<p><code>Target directory exists. Continue? (Y/n)</code>直接回车默认(然后会下载 vue2.0模板，这里可能需要连代理) <code>Project name (vue-test)</code>直接回车默认 <code>Project description (A Vue.js project)</code> 直接回车默认 <code>Author</code> 写你自己的名字<h3 id=cd-命令进入创建的工程目录>cd 命令进入创建的工程目录</h3><p>工程目录如图所示:<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-05-21.jpg alt=""><h2 id=安装项目依赖>安装项目依赖</h2><p>一定要从官方仓库安装，npm 服务器在国外所以这一步安装速度会很慢。<blockquote><p>npm install</blockquote><p><strong>不要从国内镜像cnpm安装</strong>(会导致后面缺了很多依赖库)<blockquote><p>cnpm install</blockquote><h3 id=安装-vue-路由模块-code-vue-router-code-和网络请求模块-code-vue-resource-code->安装 vue 路由模块<code>vue-router</code>和网络请求模块<code>vue-resource</code></h3><blockquote><p>cnpm install vue-router vue-resource --save</blockquote><h3 id=启动项目>启动项目</h3><blockquote><p>npm run dev</blockquote><h4 id=-strong-填坑-以下坑可能由于-vue2-0-导致其他相关编译打包工具没更新导致的-strong-><strong>填坑(以下坑可能由于 vue2.0 导致其他相关编译打包工具没更新导致的)</strong></h4><blockquote><p><strong>【重点】后来发现这些坑是由于 npm 不是最新的版本3.10.2， 用 npm 3.9.5就会出现以下坑</strong> 解决办法: 请运行以下命令 <strong>npm update -g</strong></blockquote><p>报错<blockquote><p>Error: Cannot find module 'opn' Error: Cannot find module 'webpack-dev-middleware' Error: Cannot find module 'express' Error: Cannot find module 'compression' Error: Cannot find module 'sockjs' Error: Cannot find module 'spdy' Error: Cannot find module 'http-proxy-middleware' Error: Cannot find module 'serve-index'</blockquote><p>如果你用的是老版本的 vue-cli 还可能报其他错误，需要更新一下 vue-cli<blockquote><p>npm update vue-cli</blockquote><p>然后可以查看一下当前全局 vue-cli 的版本<blockquote><p>npm view vue-cli</blockquote><p>安装一下这个依赖到工程开发环境<blockquote><p>cnpm install opn --save-dev cnpm install webpack-dev-middleware --save-dev cnpm install express --save-dev cnpm install compression --save-dev cnpm install sockjs --save-dev cnpm install spdy --save-dev cnpm install http-proxy-middleware --save-dev cnpm install serve-index --save-dev cnpm install connect-history-api-fallback --save-dev</blockquote><p>再启动项目，报错<blockquote><p>ERROR in ./src/main.js Module build failed: Error: Cannot find module 'babel-runtime/helpers/typeof' at Function.Module._resolveFilename (module.js:440:15) at Function.Module._load (module.js:388:25) at Module.require (module.js:468:17) at require (internal/module.js:20:19) at Object.<anonymous>(/Volumes/MacStorage/Coding/Web/vue-test/node_modules/.6.17.0@babel-core/lib/transformation/file/index.js:6:16) at Module._compile (module.js:541:32) at Object.Module._extensions..js (module.js:550:10) at Module.load (module.js:458:32) at tryModuleLoad (module.js:417:12) at Function.Module._load (module.js:409:3) @ multi main ERROR in ./~/.2.1.0-beta.8@webpack-dev-server/client/socket.js Module not found: Error: Can't resolve 'sockjs-client' in '/Volumes/MacStorage/Coding/Web/vue-test/node_modules/.2.1.0-beta.8@webpack-dev-server/client' @ ./~/.2.1.0-beta.8@webpack-dev-server/client/socket.js 1:13-37 @ ./~/.2.1.0-beta.8@webpack-dev-server/client?<a href=http://localhost:8080>http://localhost:8080</a> @ multi main</blockquote><p>安装一下 babel-runtime<blockquote><p>cnpm install babel-helpers --save-dev</blockquote><p>启动项目，再次报错<blockquote><p>Module build failed: Error: Cannot find module 'babel-helpers' Module build failed: Error: Cannot find module 'babel-traverse' Module build failed: Error: Cannot find module 'json5' Module build failed: Error: Cannot find module 'babel-generator' Module build failed: Error: Cannot find module 'detect-indent' Module build failed: Error: Cannot find module 'jsesc'</blockquote><p>找不到依赖那就再安装一下<blockquote><p>cnpm install babel-helpers --save-dev cnpm install babel-traverse --save-dev cnpm install json5 --save-dev .<strong>..不写了，请把全部把旧的环境全部清除，更新到最新版本</strong></blockquote><h4 id=解决办法概述>解决办法概述</h4><p>遇到<blockquote><p>Module build failed: Error: Cannot find module '模块名'</blockquote><p>那就安装<blockquote><p>cnpm install 模块名 --save-dev(关于环境的，表现为npm run dev 启动不了) cnpm install 模块名 --save(关于项目的，比如main.js，表现为npm run dev 成功之后控制台报错) 比如escape-string-regexp、strip-ansi、has-ansi、is-finite、emojis-list</blockquote><h4 id=终于可以启动项目了>终于可以启动项目了</h4><p>输入完命令会自动启动浏览器，如果默认打开 IE 不行<blockquote><p>npm run dev</blockquote><p>自动启动浏览器就会看到这 帅帅的界面了。 <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-04-54-29.png alt=""><h2 id=开始-vue-之旅>开始 Vue 之旅</h2><h3 id=打开-ide>打开 IDE</h3><p>推荐 Atom 打开项目，需要安装 Vue 语法高亮的插件<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-15-12.jpg alt=""><h3 id=使用官网文档学习基础>使用官网文档学习基础</h3><p>我们来看官网的一个例子，(中文文档请自行上网搜索)<p>￼<img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-43-24.jpg alt=""><p>打开 工程目录下的 App.vue<p>template 写 html，script写 js，style写样式<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-44-22.jpg alt=""><p>为了方便叙述，我们把官网例子写在同一个组件内<p>这里有两个坑:<p><strong>第一</strong>。一个组件下只能有一个并列的 div，可以这么写，所以复制官网示例的时候只要复制 div 里面的内容就好。<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-48-35.jpg alt=""><p>但是不能这样写:<p>￼<img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-47-39.jpg alt=""><p><strong>第二</strong>。数据要写在 return 里面而不是像文档那样子写<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-49-05.jpg alt=""><p>错误的写法:<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-49-55.jpg alt=""><p>这样子可以自己啃完官网文档组件之前的部分了。<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-11-58-14.png alt=""><h3 id=来玩玩组件>来玩玩组件</h3><p>前面讲得基本上都是各种常用组件的数据绑定，下面还得说说的是 Vue 的组件的使用。<p>在工程目录<code>/src</code>下创建<code>component</code>文件夹，并在<code>component</code>文件夹下创建一个 <code>firstcomponent.vue</code>并写仿照 App.vue 的格式和前面学到的知识写一个组件。<pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"firstcomponent"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>h1</span>></span>I am a title.<span class=hljs-tag>&lt;/<span class=hljs-name>h1</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>a</span>></span> written by {{ author }} <span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"text/javascript"</span>></span><span class=javascript>
<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    data () {
        <span class=hljs-keyword>return</span> {
            <span class=hljs-attr>author</span>: <span class=hljs-string>"微信公众号 jinkey-love"</span>
        }
    }
}
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>style</span>></span><span class="undefined">
</span><span class=hljs-tag>&lt;/<span class=hljs-name>style</span>></span></code></pre><p>duang... 不能按官网文档那样子叫我做就做，我得先试试再告诉你，我做完效果是这样子的，希望观众做完也是这样子。(迷之微笑 )<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-12-35-12.jpg alt=""><p>然后在 App.vue 使用组件 ( 因为在 <code>index.html</code> 里面定义了<div id=app></div>所以就以这个组件作为主入口，方便 )<p><strong>第一步，引入</strong>。在<code>&lt;script>&lt;/script></code>标签内的第一行写<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> firstcomponent <span class=hljs-keyword>from</span> <span class=hljs-string>'./component/firstcomponent.vue'</span></code></pre><p><strong>第二步，注册</strong>。在<code>&lt;script>&lt;/script></code>标签内的 data 代码块后面加上 components: { firstcomponent }。<strong>记得中间加英文逗号!!!</strong><pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    data () {
        <span class=hljs-keyword>return</span> {
           <span class=hljs-attr>msg</span>: <span class=hljs-string>'Hello Vue!'</span>
        }
    },
    <span class=hljs-attr>components</span>: { firstcomponent }
}</code></pre><p><strong>第三步，使用</strong>。<p>在<code>&lt;template>&lt;/template></code>内加上<firstcomponent></firstcomponent><pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"app"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"./assets/logo.png"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>h1</span>></span>{{ msg }}<span class=hljs-tag>&lt;/<span class=hljs-name>h1</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>firstcomponent</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>firstcomponent</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span></code></pre><p>完成后的代码：<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-12-32-42.jpg alt=""><p>这时候看看浏览器上的 <code>http://localhost:8080/</code> 页面(之前打开过就会自动刷新)，如果你没看到效果是因为你没有对 <code>App.vue</code> 和 <code>firstcomponent.vue</code> 进行保存操作，保存后页面会自动刷新。 <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-06-12-35-51.png alt=""><h3 id=使用路由搭建单页应用>使用路由搭建单页应用</h3><p>之前已经通过命令安装了vue-router<blockquote><p>cnpm install vue-router --save</blockquote><p>在<code>webpack.config.js</code>加入别名<pre class=nust-code><code class="hljs javascript">resolve: {
    <span class=hljs-attr>alias</span>: {<span class=hljs-attr>vue</span>: <span class=hljs-string>'vue/dist/vue.js'</span>}
}</code></pre><p>为什么要加 alias 配置项？其作用可以在文档中有相应的描述: <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-09-22-41-49.jpg alt=""><p>修改完之后的<code>webpack.config.js</code>是这样子的:<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>'path'</span>)
<span class=hljs-keyword>var</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>)

<span class=hljs-built_in>module</span>.exports = {
  <span class=hljs-attr>entry</span>: <span class=hljs-string>'./src/main.js'</span>,
  <span class=hljs-attr>output</span>: {
    <span class=hljs-attr>path</span>: path.resolve(__dirname, <span class=hljs-string>'./dist'</span>),
    <span class=hljs-attr>publicPath</span>: <span class=hljs-string>'/dist/'</span>,
    <span class=hljs-attr>filename</span>: <span class=hljs-string>'build.js'</span>
  },
  <span class=hljs-attr>resolveLoader</span>: {
    <span class=hljs-attr>root</span>: path.join(__dirname, <span class=hljs-string>'node_modules'</span>),
  },
  <span class=hljs-attr>module</span>: {
    <span class=hljs-attr>loaders</span>: [{
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.vue$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'vue'</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.js$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'babel'</span>,
      <span class=hljs-attr>exclude</span>: <span class=hljs-regexp>/node_modules/</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.(png|jpg|gif|svg)$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'file'</span>,
      <span class=hljs-attr>query</span>: {
        <span class=hljs-attr>name</span>: <span class=hljs-string>'[name].[ext]?[hash]'</span>
      }
    }]
  },
  <span class=hljs-attr>resolve</span>: {
    <span class=hljs-attr>alias</span>: {
      <span class=hljs-attr>vue</span>: <span class=hljs-string>'vue/dist/vue.js'</span>
    }
  },
  <span class=hljs-attr>devServer</span>: {
    <span class=hljs-attr>historyApiFallback</span>: <span class=hljs-literal>true</span>,
    <span class=hljs-attr>noInfo</span>: <span class=hljs-literal>true</span>
  },
  <span class=hljs-attr>devtool</span>: <span class=hljs-string>'#eval-source-map'</span>
}

<span class=hljs-keyword>if</span> (process.env.NODE_ENV === <span class=hljs-string>'production'</span>) {
  <span class=hljs-built_in>module</span>.exports.devtool = <span class=hljs-string>'#source-map'</span>
    <span class=hljs-comment>// http://vue-loader.vuejs.org/en/workflow/production.html</span>
  <span class=hljs-built_in>module</span>.exports.plugins = (<span class=hljs-built_in>module</span>.exports.plugins || []).concat([
    <span class=hljs-keyword>new</span> webpack.DefinePlugin({
      <span class=hljs-string>'process.env'</span>: {
        <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-string>'"production"'</span>
      }
    }),
    <span class=hljs-keyword>new</span> webpack.optimize.UglifyJsPlugin({
      <span class=hljs-attr>compress</span>: {
        <span class=hljs-attr>warnings</span>: <span class=hljs-literal>false</span>
      }
    })
  ])
}</code></pre><p>再按之前的方法写一个组件 secondcomponent.vue<pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>template</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"secondcomponent"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>h1</span>></span>I am another page<span class=hljs-tag>&lt;/<span class=hljs-name>h1</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>a</span>></span> written by {{ author }} <span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span> 感谢 <span class=hljs-tag>&lt;<span class=hljs-name>a</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"https://github.com/showonne"</span>></span>showonne<span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span>大神的技术指导<span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>template</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> {
    data() {
        <span class=hljs-keyword>return</span> {
            <span class=hljs-attr>author</span>: <span class=hljs-string>"微信公众号 jinkey-love"</span>,
            <span class=hljs-attr>articles</span>: [],
        }
    }
}
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>style</span>></span><span class="undefined">
</span><span class=hljs-tag>&lt;/<span class=hljs-name>style</span>></span></code></pre><p>这时候修改 main.js，引入并注册 <code>vue-router</code><pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> VueRouter <span class=hljs-keyword>from</span> <span class=hljs-string>"vue-router"</span>;
Vue.use(VueRouter);</code></pre><p>并且配置路由规则和 app 启动配置项加上 router，旧版的 router.map 方法在 <code>vue-router 2.0</code> 已经不能用了。修改后的<code>main.js</code>如下:<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> Vue <span class=hljs-keyword>from</span> <span class=hljs-string>'vue'</span>
<span class=hljs-keyword>import</span> App <span class=hljs-keyword>from</span> <span class=hljs-string>'./App.vue'</span>
<span class=hljs-keyword>import</span> VueRouter <span class=hljs-keyword>from</span> <span class=hljs-string>"vue-router"</span>;
<span class=hljs-keyword>import</span> VueResource <span class=hljs-keyword>from</span> <span class=hljs-string>'vue-resource'</span>

<span class=hljs-comment>//开启debug模式</span>
Vue.config.debug = <span class=hljs-literal>true</span>;

Vue.use(VueRouter);
Vue.use(VueResource);

<span class=hljs-comment>// 定义组件, 也可以像教程之前教的方法从别的文件引入</span>
<span class=hljs-keyword>const</span> First = {
  <span class=hljs-attr>template</span>: <span class=hljs-string>'&lt;div>&lt;h2>我是第 1 个子页面&lt;/h2>&lt;/div>'</span>
}
<span class=hljs-keyword>import</span> secondcomponent <span class=hljs-keyword>from</span> <span class=hljs-string>'./component/secondcomponent.vue'</span>

<span class=hljs-comment>// 创建一个路由器实例</span>
<span class=hljs-comment>// 并且配置路由规则</span>
<span class=hljs-keyword>const</span> router = <span class=hljs-keyword>new</span> VueRouter({
  <span class=hljs-attr>mode</span>: <span class=hljs-string>'history'</span>,
  <span class=hljs-attr>base</span>: __dirname,
  <span class=hljs-attr>routes</span>: [{
    <span class=hljs-attr>path</span>: <span class=hljs-string>'/first'</span>,
    <span class=hljs-attr>component</span>: First
  }, {
    <span class=hljs-attr>path</span>: <span class=hljs-string>'/second'</span>,
    <span class=hljs-attr>component</span>: secondcomponent
  }]
})

<span class=hljs-comment>// 现在我们可以启动应用了！</span>
<span class=hljs-comment>// 路由器会创建一个 App 实例，并且挂载到选择符 #app 匹配的元素上。</span>
<span class=hljs-keyword>const</span> app = <span class=hljs-keyword>new</span> Vue({
  <span class=hljs-attr>router</span>: router,
  <span class=hljs-attr>render</span>: <span class=hljs-function><span class=hljs-params>h</span> =></span> h(App)
}).$mount(<span class=hljs-string>'#app'</span>)</code></pre><p>这样子改完再打开浏览器看看。 <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-09-23-10-33.png alt=""><p>点击那两个链接试试，会发现<code>&lt;router-view class="view">&lt;/router-view></code>的内容已经展示出来，同时注意<strong>浏览器地址已经变更</strong>。 <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-09-23-11-14.png alt=""><p>另外，也可以把 App.vue 的内容写在 main.js 也是可以的不过不建议这么做 <img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-09-23-49-24.jpg alt=""><p>如果你使用 vue1.0和0.7版本的 vue-router，请参照下面这个教程, 他整个系列都不错的，当然仅限于 vue1.0 :<blockquote><p><a href=http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/ >http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/</a></blockquote><h3 id=给页面加点动态数据>给页面加点动态数据</h3><p>这时候的页面都是静态的(数据在写程序的时候已经固定了不能修改)，而每个应用基本上都会请求外部数据以动态改变页面内容。对应有一个库叫 <code>vue-resource</code> 帮我们解决这个问题。<p>使用命令行安装<blockquote><p>cnpm install vue-resource --save</blockquote><p>在 main.js 引入并注册 <code>vue-resource</code>:<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> VueResource <span class=hljs-keyword>from</span> <span class=hljs-string>'vue-resource'</span>
Vue.use(VueResource);</code></pre><p>我们在 secondcomponent.vue 上来动态加载数据<p>添加一个列表:<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>ul</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>"article in articles"</span>></span>
        {{article.title}}
    <span class=hljs-tag>&lt;/<span class=hljs-name>li</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>></span></code></pre><p>在 data 里面加入数组 articles 并赋值为[] 然后在 data 后面加入加入钩子函数 <code>mounted</code>(详细请参照官方文档关于 vue 生命周期的解析)，<strong>data 和 mount 中间记得记得加逗号</strong><pre class=nust-code><code class="hljs javascript">mounted: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
    <span class=hljs-keyword>this</span>.$http.jsonp(<span class=hljs-string>'https://api.douban.com/v2/movie/top250?count=10'</span>, {}, {
        <span class=hljs-attr>headers</span>: {

        },
        <span class=hljs-attr>emulateJSON</span>: <span class=hljs-literal>true</span>
    }).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>response</span>) </span>{
        <span class=hljs-comment>// 这里是处理正确的回调</span>

        <span class=hljs-keyword>this</span>.articles = response.data.subjects
        <span class=hljs-comment>// this.articles = response.data["subjects"] 也可以</span>

    }, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>response</span>) </span>{
        <span class=hljs-comment>// 这里是处理错误的回调</span>
        <span class=hljs-built_in>console</span>.log(response)
    });
}</code></pre><p>这里使用的是豆瓣的公开 GET 接口，如果接口是跨域的 POST 请求，则需要在服务器端配置:<blockquote><p>Access-Control-Allow-Origin: *</blockquote><p>这时候运行看看。等一会接口返回数据，咦，数据加载出来了，棒棒哒 !<p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-09-23-32-49.png alt=""><p>更多 <code>vue-router</code> 的使用方法可以看<blockquote><p><strong>vue-router 0.7</strong> <a href=http://m.doc00.com/doc/1001004eg>http://m.doc00.com/doc/1001004eg</a> <strong>vue-router 2.0</strong> <a href=http://router.vuejs.org/zh-cn/index.html>http://router.vuejs.org/zh-cn/index.html</a></blockquote><h3 id=来拯救如此难看的界面>来拯救如此难看的界面</h3><p>组件、双向绑定、路由、数据请求等基本特性都能用了，写到这里一个单页应用基本上成型了。但是，这几面也太 TM 难看了吧。自己写 UI 框架太费劲？那就上网找一个吧。 本来想给大家介绍 Vux 的，因为他用的是微信的 WeUI 设计规范，对于开发微信小程序或者微信内的网页非常和谐，但由于写这篇文章的时候 Vux 还不支持 vue2.0，只能用别的框架了。 命令行安装 ElementUI (此处某公司的人应该发红包了...)<blockquote><p>cnpm install element-ui@next -S</blockquote><p>然后在 main.js 引入并注册<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>import</span> Element <span class=hljs-keyword>from</span> <span class=hljs-string>'element-ui'</span>
<span class=hljs-keyword>import</span> <span class=hljs-string>'element-ui/lib/theme-default/index.css'</span>
Vue.use(Element)</code></pre><p>保存，这时候程序报错<blockquote><p>Uncaught Error: Module parse failed: /Users/**/Desktop/vue2/node_modules/.1.0.0-rc.5@element-ui/lib/theme-default/index.css Unexpected character '@' (1:0) You may need an appropriate loader to handle this file type.</blockquote><p>官网文档又有坑了，安装教程也不跟我们说这一步，当我们都是高手了... 报错是由于我们引入了<code>index.css</code>这个 CSS 文件，但是 webpack 打包的时候无法识别并转换成 js，所以就需要配置才能读取 css 和字体文件，运行命令安装下面三个东西(如果之前安装过就不需要了)<blockquote><p>cnpm install style-loader --save-dev cnpm install css-loader --save-dev cnpm install file-loader --save-dev</blockquote><p>在 <code>webpack.config.js</code> 中的 loaders 数组加入以下配置，<strong>记得该加逗号的地方加逗号!</strong><pre class=nust-code><code class="hljs javascript">{
    <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.css$/</span>,
    <span class=hljs-attr>loader</span>: <span class=hljs-string>"style!css"</span>
},
{
    <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.(eot|woff|woff2|ttf)([\\\\\\\\?]?.*)$/</span>,
    <span class=hljs-attr>loader</span>: <span class=hljs-string>"file"</span>
}</code></pre><p>修改完的 <code>webpack.config.js</code> 如下<pre class=nust-code><code class="hljs javascript"><span class=hljs-keyword>var</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>'path'</span>)
<span class=hljs-keyword>var</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>)

<span class=hljs-built_in>module</span>.exports = {
  <span class=hljs-attr>entry</span>: <span class=hljs-string>'./src/main.js'</span>,
  <span class=hljs-attr>output</span>: {
    <span class=hljs-attr>path</span>: path.resolve(__dirname, <span class=hljs-string>'./dist'</span>),
    <span class=hljs-attr>publicPath</span>: <span class=hljs-string>'/dist/'</span>,
    <span class=hljs-attr>filename</span>: <span class=hljs-string>'build.js'</span>
  },
  <span class=hljs-attr>resolveLoader</span>: {
    <span class=hljs-attr>root</span>: path.join(__dirname, <span class=hljs-string>'node_modules'</span>),
  },
  <span class=hljs-attr>module</span>: {
    <span class=hljs-attr>loaders</span>: [{
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.vue$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'vue'</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.js$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'babel'</span>,
      <span class=hljs-attr>exclude</span>: <span class=hljs-regexp>/node_modules/</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.css$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>"style!css"</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.(eot|woff|woff2|ttf)([\\\\\\\\?]?.*)$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>"file"</span>
    }, {
      <span class=hljs-attr>test</span>: <span class=hljs-regexp>/\\\\\\\\.(png|jpg|gif|svg)$/</span>,
      <span class=hljs-attr>loader</span>: <span class=hljs-string>'file'</span>,
      <span class=hljs-attr>query</span>: {
        <span class=hljs-attr>name</span>: <span class=hljs-string>'[name].[ext]?[hash]'</span>
      }
    }]
  },
  <span class=hljs-attr>resolve</span>: {
    <span class=hljs-attr>alias</span>: {
      <span class=hljs-attr>vue</span>: <span class=hljs-string>'vue/dist/vue.js'</span>
    }
  },
  <span class=hljs-attr>devServer</span>: {
    <span class=hljs-attr>historyApiFallback</span>: <span class=hljs-literal>true</span>,
    <span class=hljs-attr>noInfo</span>: <span class=hljs-literal>true</span>
  },
  <span class=hljs-attr>devtool</span>: <span class=hljs-string>'#eval-source-map'</span>
}

<span class=hljs-keyword>if</span> (process.env.NODE_ENV === <span class=hljs-string>'production'</span>) {
  <span class=hljs-built_in>module</span>.exports.devtool = <span class=hljs-string>'#source-map'</span>
    <span class=hljs-comment>// http://vue-loader.vuejs.org/en/workflow/production.html</span>
  <span class=hljs-built_in>module</span>.exports.plugins = (<span class=hljs-built_in>module</span>.exports.plugins || []).concat([
    <span class=hljs-keyword>new</span> webpack.DefinePlugin({
      <span class=hljs-string>'process.env'</span>: {
        <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-string>'"production"'</span>
      }
    }),
    <span class=hljs-keyword>new</span> webpack.optimize.UglifyJsPlugin({
      <span class=hljs-attr>compress</span>: {
        <span class=hljs-attr>warnings</span>: <span class=hljs-literal>false</span>
      }
    })
  ])
}</code></pre><p>给豆瓣的电影列表套个衣服(样式) :<pre class=nust-code><code class="hljs html"><span class=hljs-tag>&lt;<span class=hljs-name>el-card</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"box-card"</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>slot</span>=<span class=hljs-string>"header"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"clearfix"</span>></span>
        <span class=hljs-tag>&lt;<span class=hljs-name>h1</span> <span class=hljs-attr>style</span>=<span class=hljs-string>"line-height: 36px; color: #20A0FF"</span>></span>豆瓣电影排行榜<span class=hljs-tag>&lt;/<span class=hljs-name>h2</span>></span>
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>"article in articles"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"text item"</span>></span>
        {{article.title}}
    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>el-card</span>></span></code></pre><p>打开浏览器,输入网址:<blockquote><p><a href=http://localhost:8080/second>http://localhost:8080/second</a></blockquote><p><img src=http://o8lot23ep.bkt.clouddn.com/_image/2016-10-10-00-51-43.png alt=""><p>￼ 列表比之前漂亮多了，你还可以参照 ElementUI 的文档使用更多组件样式<blockquote><p><a href=http://element.eleme.io/#/component/layout>http://element.eleme.io/#/component/layout</a></blockquote><h2 id=编译>编译</h2><blockquote><p>npm run build</blockquote><p>又报错了...orz<blockquote><p>ERROR in build.js from UglifyJs SyntaxError: Unexpected token punc «(», expected punc «:» [build.js:32001,6] 把node_modules/.bin/cross-env里的 require('../dist')(process.argv.slice(2));</blockquote><p>后来发现直接运行 webpack 命令就可以打包了<blockquote><p>webpack --color --progress</blockquote><p>接着把 index.html 和整个 dist 目录丢到服务器就可以了。]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>H5直播起航</title>
      <link>https://aotu.io/notes/2016-10-09/HTML5-SopCast</link>
      <guid>https://aotu.io/notes/2016-10-09/HTML5-SopCast</guid>
      <pubDate>2016-10-09T15:24:41.000Z</pubDate>
      <description>
      
        直播这么火，想直播写代码的冲动吗，那还等什么，一起开始做H5直播吧～～
      
      </description>
      
      <content:encoded><![CDATA[<h2 id=前言>前言</h2><p>前不久抽空对目前比较火的视频直播，做了下研究与探索，了解其整体实现流程，以及探讨移动端HTML5直播可行性方案。<p>发现目前 WEB 上主流的视频直播方案有 HLS 和 RTMP，移动 WEB 端目前以 HLS 为主（HLS存在延迟性问题，也可以借助 <a href=https://github.com/videojs/video.js>video.js</a> 采用RTMP），PC端则以 RTMP 为主实时性较好，接下来将围绕这两种视频流协议来展开H5直播主题分享。<h2 id=一-视频流协议hls与rtmp>一、视频流协议HLS与RTMP</h2><h3 id=1-http-live-streaming>1. HTTP Live Streaming</h3><p>HTTP Live Streaming（简称 HLS）是一个基于 HTTP 的视频流协议，由 Apple 公司实现，Mac OS 上的 QuickTime、Safari 以及 iOS 上的 Safari 都能很好的支持 HLS，高版本 Android 也增加了对 HLS 的支持。一些常见的客户端如：MPlayerX、VLC 也都支持 HLS 协议。<p>HLS 协议基于 HTTP，而一个提供 HLS 的服务器需要做两件事：<ul><li>编码：以 H.263 格式对图像进行编码，以 MP3 或者 HE-AAC 对声音进行编码，最终打包到 MPEG-2 TS（Transport Stream）容器之中；<li>分割：把编码好的 TS 文件等长切分成后缀为 ts 的小文件，并生成一个 .m3u8 的纯文本索引文件；</ul><p>浏览器使用的是 m3u8 文件。m3u8 跟音频列表格式 m3u 很像，可以简单的认为 m3u8 就是包含多个 ts 文件的播放列表。播放器按顺序逐个播放，全部放完再请求一下 m3u8 文件，获得包含最新 ts 文件的播放列表继续播，周而复始。整个直播过程就是依靠一个不断更新的 m3u8 和一堆小的 ts 文件组成，m3u8 必须动态更新，ts 可以走 CDN。一个典型的 m3u8 文件格式如下：<blockquote><p>#EXTM3U<p>#EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=200000 gear1/prog_index.m3u8<p>#EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=311111 gear2/prog_index.m3u8<p>#EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=484444 gear3/prog_index.m3u8<p>#EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=737777 gear4/prog_index.m3u8</blockquote><p>可以看到 HLS 协议本质还是一个个的 HTTP 请求 / 响应，所以适应性很好，不会受到防火墙影响。但它也有一个致命的弱点：延迟现象非常明显。如果每个 ts 按照 5 秒来切分，一个 m3u8 放 6 个 ts 索引，那么至少就会带来 30 秒的延迟。如果减少每个 ts 的长度，减少 m3u8 中的索引数，延时确实会减少，但会带来更频繁的缓冲，对服务端的请求压力也会成倍增加。所以只能根据实际情况找到一个折中的点。<p>对于支持 HLS 的浏览器来说，直接这样写就能播放了：<pre class=nust-code><code class="hljs routeros">&lt;video <span class=hljs-attribute>src</span>=<span class=hljs-string>"http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8"</span>
<span class=hljs-attribute>height</span>=<span class=hljs-string>"300"</span> <span class=hljs-attribute>width</span>=<span class=hljs-string>"400"</span>  <span class=hljs-attribute>preload</span>=<span class=hljs-string>"auto"</span> <span class=hljs-attribute>autoplay</span>=<span class=hljs-string>"autoplay"</span> <span class=hljs-attribute>loop</span>=<span class=hljs-string>"loop"</span> <span class=hljs-attribute>webkit-playsinline</span>=<span class=hljs-string>"true"</span>>&lt;/video></code></pre><p><code>注意</code>：HLS 在 PC 端仅支持safari浏览器，类似chrome浏览器使用<code>HTML5 video</code>标签无法播放 m3u8 格式，可直接采用网上一些比较成熟的方案，如：<a href=https://github.com/jackzhang1204/sewise-player>sewise-player</a>、<a href=https://github.com/johndyer/mediaelement>MediaElement</a>、<a href=https://github.com/videojs/videojs-contrib-hls>videojs-contrib-hls</a>、<a href=https://github.com/jwplayer/jwplayer>jwplayer</a>。<h3 id=2-real-time-messaging-protocol>2. Real Time Messaging Protocol</h3><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，但无法支持移动端 WEB 播放是它的硬伤。<p>虽然无法在iOS的H5页面播放，但是对于iOS原生应用是可以自己写解码去解析的, RTMP 延迟低、实时性较好。<p>浏览器端，<code>HTML5 video</code>标签无法播放 RTMP 协议的视频，可以通过 <a href=https://github.com/videojs/video.js>video.js</a> 来实现。<pre class=nust-code><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"http://vjs.zencdn.net/5.8.8/video-js.css"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"stylesheet"</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>video</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"example_video_1"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"video-js vjs-default-skin"</span> <span class=hljs-attr>controls</span> <span class=hljs-attr>preload</span>=<span class=hljs-string>"auto"</span> <span class=hljs-attr>width</span>=<span class=hljs-string>"640"</span> <span class=hljs-attr>height</span>=<span class=hljs-string>"264"</span> <span class=hljs-attr>loop</span>=<span class=hljs-string>"loop"</span> <span class=hljs-attr>webkit-playsinline</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>source</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"rtmp://10.14.221.17:1935/rtmplive/home"</span> <span class=hljs-attr>type</span>=<span class=hljs-string>'rtmp/flv'</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>video</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"http://vjs.zencdn.net/5.8.8/video.js"</span>></span><span class="undefined"></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=actionscript>
videojs.options.flash.swf = <span class=hljs-string>'video.swf'</span>;
videojs(<span class=hljs-string>'example_video_1'</span>).ready(<span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span> </span>{
  <span class=hljs-keyword>this</span>.play();
});
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><h3 id=3-视频流协议hls与rtmp对比>3. 视频流协议HLS与RTMP对比</h3><table><thead><tr><th style=text-align:center><th style=text-align:center>协议<th style=text-align:center>原理<th style=text-align:center>延时<th style=text-align:center>优点<th style=text-align:center>使用场景<tbody><tr><td style=text-align:center>HLS<td style=text-align:center>短链接Http<td style=text-align:center>集合一段时间数据生成ts切片文件更新m3u8文件<td style=text-align:center>10s - 30s<td style=text-align:center>跨平台<td style=text-align:center>移动端为主<tr><td style=text-align:center>RTMP<td style=text-align:center>长链接Tcp<td style=text-align:center>每个时刻的数据收到后立即发送<td style=text-align:center>2s<td style=text-align:center>延时低、实时性好<td style=text-align:center>PC+直播+实时性要求高＋互动性强</table><h2 id=二-直播形式>二、直播形式</h2><p><img src=//misc.aotu.io/pfan123/sopcast/1.png alt=直播形式><p>目前直播展示形式，通常以YY直播、映客直播这种页面居多，可以看到其结构可以分成三层：① 背景视频层 ② 关注、评论模块 ③ 点赞动画<p>而现行H5类似直播页面，实现技术难点不大，其可以通过实现方式分为：① 底部视频背景使用video视频标签实现播放 ② 关注、评论模块利用 WebScoket 来实时发送和接收新的消息通过DOM 和 CSS3 实现 ③ 点赞利用 CSS3 动画<p>了解完直播形式之后，接下来整体了解直播流程。<h2 id=三-直播整体流程>三、直播整体流程</h2><p>直播整体流程大致可分为：<ul><li><p>视频采集端：可以是电脑上的音视频输入设备、或手机端的摄像头、或麦克风，目前以移动端手机视频为主。<li><p>直播流视频服务端：一台Nginx服务器，采集视频录制端传输的视频流(H264/ACC编码)，由服务器端进行解析编码，推送RTMP/HLS格式视频流至视频播放端。<li><p>视频播放端：可以是电脑上的播放器（QuickTime Player、VLC），手机端的native播放器，还有就是 H5 的video标签等，目前还是以手机端的native播放器为主。</ul><p><img src=//misc.aotu.io/pfan123/sopcast/2.png alt=直播整体流程><h2 id=四-h5-录制视频>四、H5 录制视频</h2><p>对于H5视频录制，可以使用强大的 webRTC （Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在 PC 的 Chrome 上支持较好，移动端支持不太理想。<h3 id=1-使用-webrtc-录制视频基本流程>1. 使用 webRTC 录制视频基本流程</h3><p>① 调用 <code>window.navigator.webkitGetUserMedia()</code> 获取用户的PC摄像头视频数据。 ② 将获取到视频流数据转换成 <code>window.webkitRTCPeerConnection</code> (一种视频流数据格式)。 ③ 利用 <code>WebScoket</code> 将视频流数据传输到服务端。<p><code>注意</code>：虽然Google一直在推WebRTC，目前已有不少成型的产品出现，但是大部分移动端的浏览器还不支持 webRTC（最新iOS 10.0也不支持），所以真正的视频录制还是要靠客户端（iOS,Android）来实现,效果会好一些。 <img src=//misc.aotu.io/pfan123/sopcast/3.png alt=WebRTC支持度><h3 id=2-ios原生应用调用摄像头录制视频流程>2. iOS原生应用调用摄像头录制视频流程</h3><p>① 音视频的采集，利用AVCaptureSession和AVCaptureDevice可以采集到原始的音视频数据流。 ② 对视频进行H264编码，对音频进行AAC编码，在iOS中分别有已经封装好的编码库（<a href=https://github.com/kewlbear/x264-ios>x264编码</a>、<a href=https://github.com/fflydev/faac-ios-build>faac编码</a>、<a href=https://github.com/kewlbear/FFmpeg-iOS-build-script>ffmpeg编码</a>）来实现对音视频的编码。 ③ 对编码后的音、视频数据进行组装封包。 ④ 建立RTMP连接并上推到服务端。<p><img src=//misc.aotu.io/pfan123/sopcast/4.png alt=视频流程><h2 id=五-搭建nginx-rtmp直播流服务>五、搭建Nginx+Rtmp直播流服务</h2><h3 id=1-安装nginx-nginx-rtmp-module>1. 安装nginx、nginx-rtmp-module</h3><p>① 先clone nginx项目到本地：<pre class=nust-code><code class="hljs armasm"><span class=hljs-keyword>brew </span>tap homebrew/nginx</code></pre><p>② 执行安装<code>nginx-rtmp-module</code><pre class=nust-code><code class="hljs crystal">brew install nginx-full --<span class=hljs-keyword>with</span>-rtmp-<span class=hljs-class><span class=hljs-keyword>module</span></span></code></pre><h3 id=2-nginx-conf配置文件-配置rtmp-hls>2. nginx.conf配置文件，配置RTMP、HLS</h3><p>查找到nginx.conf配置文件（路径/usr/local/etc/nginx/nginx.conf），配置RTMP、HLS。<p>① 在http节点之前添加 rtmp 的配置内容：<pre class=nust-code><code class="hljs nginx"><span class=hljs-section>rtmp</span> {
  <span class=hljs-section>server</span> {
     <span class=hljs-comment>#监听的端口</span>
      <span class=hljs-attribute>listen</span> <span class=hljs-number>1935</span>;
      <span class=hljs-comment># RTMP 直播流配置</span>
      <span class=hljs-attribute>application</span> rtmplive {
          <span class=hljs-attribute>live</span> <span class=hljs-literal>on</span>;
          <span class=hljs-comment>#为 rtmp 引擎设置最大连接数。默认为 off</span>
          <span class=hljs-attribute>max_connections</span> <span class=hljs-number>1024</span>;
       }
      <span class=hljs-comment># HLS 直播流配置</span>
      <span class=hljs-attribute>application</span> hls{
          <span class=hljs-attribute>live</span> <span class=hljs-literal>on</span>;
          <span class=hljs-attribute>hls</span> <span class=hljs-literal>on</span>;
          <span class=hljs-attribute>hls_path</span> /usr/local/var/www/hls;
          <span class=hljs-attribute>hls_fragment</span> <span class=hljs-number>1s</span>;
      }
   }
}</code></pre><p>② 在http中添加 hls 的配置<pre class=nust-code><code class="hljs dts">    location /<span class=hljs-class>hls </span>{  
        <span class=hljs-meta># Serve HLS fragments  </span>
        <span class=hljs-class>types </span>{  
            application/vnd.apple.mpegurl m3u8;  
            video/mp2t ts;  
        }  
        root <span class=hljs-meta-keyword>/usr/</span>local<span class=hljs-meta-keyword>/var/</span>www;  
        <span class=hljs-meta>#add_header Cache-Controll no-cache;</span>
        expires <span class=hljs-number>-1</span>;
    }</code></pre><h3 id=3-重启nginx服务>3. 重启nginx服务</h3><p>重启nginx服务，浏览器中输入 <a href=http://localhost:8080>http://localhost:8080</a>，是否出现欢迎界面确定nginx重启成功。<pre class=nust-code><code class="hljs ebnf"><span class=hljs-attribute>    nginx -s reload</span></code></pre><h2 id=六-直播流转换格式-编码推流>六、直播流转换格式、编码推流</h2><p>当服务器端接收到采集视频录制端传输过来的视频流时，需要对其进行解析编码，推送RTMP/HLS格式视频流至视频播放端。通常使用的常见编码库方案，如<a href=https://github.com/kewlbear/x264-ios>x264编码</a>、<a href=https://github.com/fflydev/faac-ios-build>faac编码</a>、<a href=https://github.com/kewlbear/FFmpeg-iOS-build-script>ffmpeg编码</a>等。<p>鉴于 FFmpeg 工具集合了多种音频、视频格式编码，我们可以优先选用FFmpeg进行转换格式、编码推流。<p>1.安装 FFmpeg 工具<pre class=nust-code><code class="hljs mipsasm"><span class=hljs-keyword>brew </span><span class=hljs-keyword>install </span>ffmpeg</code></pre><p>2.推流MP4文件<p>视频文件地址：/Users/gao/Desktop/video/test.mp4 推流拉流地址：rtmp://localhost:1935/rtmplive/home，rtmp://localhost:1935/rtmplive/home<pre class=nust-code><code class="hljs stylus"><span class=hljs-comment>//RTMP 协议流</span>
ffmpeg -re -<span class=hljs-selector-tag>i</span> /Users/gao/Desktop/video/test<span class=hljs-selector-class>.mp4</span> -vcodec libx264 -acodec aac -f flv rtmp:<span class=hljs-comment>//10.14.221.17:1935/rtmplive/home</span>

<span class=hljs-comment>//HLS 协议流</span>
ffmpeg -re -<span class=hljs-selector-tag>i</span> /Users/gao/Desktop/video/test<span class=hljs-selector-class>.mp4</span> -vcodec libx264 -vprofile baseline -acodec aac -ar <span class=hljs-number>44100</span> -strict -<span class=hljs-number>2</span> -ac <span class=hljs-number>1</span> -f flv  -<span class=hljs-selector-tag>q</span> <span class=hljs-number>10</span> rtmp:<span class=hljs-comment>//10.14.221.17:1935/hls/test</span></code></pre><p><code>注意</code>： 当我们进行推流之后，可以安装<a href=http://www.pc6.com/mac/112121.html>VLC</a>、ffplay（支持rtmp协议的视频播放器）本地拉流进行演示<p>3.FFmpeg推流命令<p>① 视频文件进行直播<pre class=nust-code><code class="hljs stylus">ffmpeg -re -<span class=hljs-selector-tag>i</span> /Users/gao/Desktop/video/test<span class=hljs-selector-class>.mp4</span> -vcodec libx264 -vprofile baseline -acodec aac -ar <span class=hljs-number>44100</span> -strict -<span class=hljs-number>2</span> -ac <span class=hljs-number>1</span> -f flv  -<span class=hljs-selector-tag>q</span> <span class=hljs-number>10</span> rtmp:<span class=hljs-comment>//192.168.1.101:1935/hls/test</span>
ffmpeg -re -<span class=hljs-selector-tag>i</span> /Users/gao/Desktop/video/test<span class=hljs-selector-class>.mp4</span> -vcodec libx264 -vprofile baseline -acodec aac -ar <span class=hljs-number>44100</span> -strict -<span class=hljs-number>2</span> -ac <span class=hljs-number>1</span> -f flv  -<span class=hljs-selector-tag>q</span> <span class=hljs-number>10</span> rtmp:<span class=hljs-comment>//10.14.221.17:1935/hls/test</span></code></pre><p>② 推流摄像头＋桌面+麦克风录制进行直播<pre class=nust-code><code class="hljs stylus">ffmpeg -f avfoundation -framerate <span class=hljs-number>30</span> -<span class=hljs-selector-tag>i</span> <span class=hljs-string>"1:0"</span> \-f avfoundation -framerate <span class=hljs-number>30</span> -video_size <span class=hljs-number>640</span>x480 -<span class=hljs-selector-tag>i</span> <span class=hljs-string>"0"</span> \-c:v libx264 -preset ultrafast \-filter_complex <span class=hljs-string>'overlay=main_w-overlay_w-10:main_h-overlay_h-10'</span> -acodec libmp3lame -ar <span class=hljs-number>44100</span> -ac <span class=hljs-number>1</span>  -f flv rtmp:<span class=hljs-comment>//192.168.1.101:1935/hls/test</span></code></pre><p>更多命令，请参考： <a href=http://blog.csdn.net/leixiaohua1020/article/details/12029543>FFmpeg处理RTMP流媒体的命令大全</a> <a href=http://www.jianshu.com/p/d541b317f71c>FFmpeg常用推流命令</a><h2 id=七-h5-直播视频播放>七、H5 直播视频播放</h2><p>移动端iOS和 Android 都天然支持HLS协议，做好视频采集端、视频流推流服务之后，便可以直接在H5页面配置 video 标签播放直播视频。<pre class=nust-code><code class="hljs stylus">&lt;<span class=hljs-selector-tag>video</span> controls preload=<span class=hljs-string>"auto"</span>  autoplay=<span class=hljs-string>"autoplay"</span> loop=<span class=hljs-string>"loop"</span> webkit-playsinline>    
    &lt;source src=<span class=hljs-string>"http://10.14.221.8/hls/test.m3u8"</span> type=<span class=hljs-string>"application/vnd.apple.mpegurl"</span> />  
    &lt;<span class=hljs-selector-tag>p</span> class=<span class=hljs-string>"warning"</span>>Your browser does not support HTML5 <span class=hljs-selector-tag>video</span>.&lt;/p>  
&lt;/video></code></pre><p><code>ps</code>：① video标签添加<code>webkit-playsinline</code>属性（iOS支持）是保证视频在网页中内嵌播放。 ② 针对微信浏览器，video标签层级最高的问题，需要申请添加白名单，请参照 <a href="http://bbs.mb.qq.com/thread-1242581-1-1.html?ptlang=2052。">http://bbs.mb.qq.com/thread-1242581-1-1.html?ptlang=2052。</a><h2 id=八-总结>八、总结</h2><p>本文从视频采集上传，服务器处理视频推流，以及H5页面播放直播视频一整套流程,具体阐述了直播实现原理，实现过程中会遇到很多性能优化问题。<p>① H5 HLS 限制必须是H264+AAC编码。<p>② H5 HLS 播放卡顿问题，server 端可以做好分片策略，将 ts 文件放在 CDN 上，前端可尽量做到 DNS 缓存等。<p>③ H5 直播为了达到更好的实时互动，也可以采用RTMP协议，通过<code>video.js</code>实现播放。<p>参考资料：<ul><li><a href=https://www.zhihu.com/question/42162310>如何搭建一个完整的视频直播系统？</a><li><a href=http://www.haomou.net/2014/08/04/2014_Html5_canvas_video/ >WebRTC相关的canvas与video</a><li><a href=https://segmentfault.com/a/1190000000392586>使用 WebSockets 进行 HTML5 视频直播</a><li><a href=http://blog.ucloud.cn/archives/694>关于直播，所有的技术细节都在这里了（一）</a><li><a href=http://blog.ucloud.cn/archives/699>关于直播，所有的技术细节都在这里了（二）</a><li><a href=http://blog.ucloud.cn/archives/760>关于直播，所有的技术细节都在这里了（三）</a><li><a href=https://github.com/phoboslab/jsmpeg>JS解码项目jsmpeg</a></ul>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>凹凸实验室博客V1.0.0发布</title>
      <link>https://aotu.io/notes/2015-10-08/aotu-blog-v1</link>
      <guid>https://aotu.io/notes/2015-10-08/aotu-blog-v1</guid>
      <pubDate>2015-10-08T10:24:35.000Z</pubDate>
      <description>
      
        凹凸实验室博客是一个托管于Github的静态博客，基于HEXO搭建，主题的定做参考自future-imperfect的扁平简约，暂且命名为`o2`。
      
      </description>
      
      <content:encoded><![CDATA[<p>筹备了两周多，凹凸实验室博客 V1.0.0 正式发布啦，欢迎同学们体验并提供建议。 它是一个托管于Github的静态博客，基于HEXO搭建，主题的定做参考自<a href=http://html5up.net/future-imperfect>future-imperfect</a>的扁平简约，暂且命名为<code>o2</code>。主题单独开源于 <a href=https://github.com/o2team/hexo-theme-o2>hexo-theme-o2</a>，有兴趣的朋友可以自由下载使用。<blockquote><p>2016年12月更新：当前主题为全新设计，不再使用<code>hexo-theme-o2</code>，喜欢的童鞋可以直接fork <a href=https://github.com/o2team/o2team.github.io>o2team/o2team.github.io</a>的源码。</blockquote><h2 id=博客的一些特性>博客的一些特性</h2><ol><li><p>使用github头像<p>记得将你们在github的头像更新到最帅，将你github的用户名在文章内头部填好即可！<li><p><a href=https://npmjs.org/package/hexo-wordcount>hexo-wordcount</a> 显示博文字数<li><a href=http://ibruce.info/2015/04/04/busuanzi/ >不蒜子</a> 统计博文的pv<li>每日一句英文警句<li><a href=http://duoshuo.com>多说</a>评论</ol><h2 id=使用指引>使用指引</h2><ol><li><p>安装hexo<pre class=nust-code><code class="hljs stylus"> npm <span class=hljs-selector-tag>i</span> hexo-cli -g</code></pre><li><p>将o2team.github.io的源码拉到本地<pre class=nust-code><code class="hljs stylus"> git clone git@github<span class=hljs-selector-class>.com</span>:o2team/o2team<span class=hljs-selector-class>.github</span><span class=hljs-selector-class>.io</span><span class=hljs-selector-class>.git</span> o2team</code></pre><li><p>初始化子模块(submodules)<pre class=nust-code><code class="hljs jboss-cli"> <span class=hljs-keyword>cd</span> o2team
 git submodule init
 git submodule update

 <span class=hljs-comment># 切换至themes/o2目录，签出master分支</span>
 <span class=hljs-keyword>cd</span> <span class=hljs-string>../themes/o2</span>
 git checkout master</code></pre><li><p>安装nodejs包<pre class=nust-code><code class="hljs clean"> # 切换回根目录下
 cd ../../
 npm install</code></pre><li><p>运行<code>hexo s --watch</code><p>运行上述命令后，浏览器打开 <a href=http://localhost:4000>http://localhost:4000</a> 即可本地访问我们的网站</ol><h2 id=创建文章>创建文章</h2><p>有两种方法创建文章，可任选其一：<blockquote><p>注意：文件名不要出现中文!!!</blockquote><ol><li><p>使用<code>hexo new</code> 命令<pre class=nust-code><code class="hljs bash">$ hexo new <span class=hljs-string>"My New Post"</span></code></pre><li><p>拷贝现有的文章进行修改<p>hexo使用markdown来编辑文章，在source目录下，拷贝任意md文件进行创建新的文章。具体可参考下hexo的官方说明</ol><h2 id=文章规范>文章规范</h2><ol><li>使用markdown写博文<li><p>博文图片统一位置：<code>source/img/post/</code> 在博客内容中可以使用 <code>pimg</code> 自定义标签来引用图片。注意别覆盖了别人的图片!!! 其语法格式为： <code>{% raw %}{% pimg imageName [alt text] [JSONImageAttibutes] %}{% endraw %}</code> 例如： <code>{% raw %}{% pimg post-aotu.jpg "空格请用%20来区分" '{"title":"hello","class":"test_img"}' %}{% endraw %}</code> 需要注意的是：<code>pimg</code> 利用空格来划分字段属性，如果一个属性的值需要空格，请将空格用<code>%20</code>代替!!!<li><p>为了保证博客整体美观，每个文章需要一张配图(大小：840x340)<li><p>指明文章的副标题、作者信息、封面图片地址<pre class=nust-code><code class="hljs dts"><span class=hljs-symbol> subtitle:</span> <span class=hljs-string>"凹凸实验室博客是一个托管于Github的静态博客，基于HEXO搭建..."</span>
<span class=hljs-symbol> date:</span> <span class=hljs-number>2015</span><span class=hljs-number>-11</span><span class=hljs-number>-20</span> <span class=hljs-number>00</span>:<span class=hljs-number>24</span>:<span class=hljs-number>35</span>
<span class=hljs-symbol> cover:</span> <span class=hljs-string>"封面图片地址"</span>
<span class=hljs-symbol> tags:</span>
 - Hexo
<span class=hljs-symbol> author:</span>
<span class=hljs-symbol>     nick:</span> LV主唱大人
<span class=hljs-symbol>     github_name:</span> mamboer</code></pre><li><p>利用<code>&lt;!-- more --></code>设置文章的摘要<p>示例：<pre class=nust-code><code class="hljs django"><span class=xml> title: 文章标题
 ---
 这部分是文章摘要，这部分是文章摘要。在hexo模版里可通过 </span><span class=hljs-template-tag>{% <span class=hljs-name>raw</span> %}</span><span class=xml></span><span class=hljs-template-variable>{{ post.excerpt }}</span><span class=xml></span><span class=hljs-template-tag>{% <span class=hljs-name>endraw</span> %}</span><span class=xml> 来引用。
 <span class=hljs-comment>&lt;!-- more --></span> 
 这里是文章的剩余部分。在hexo模版里可通过</span><span class=hljs-template-tag>{% <span class=hljs-name>raw</span> %}</span><span class=xml></span><span class=hljs-template-variable>{{ post.more }}</span><span class=xml></span><span class=hljs-template-tag>{% <span class=hljs-name>endraw</span> %}</span><span class=xml> 来引用。</span></code></pre><p>实际使用请参考<a href="{{ raw_link('_post/2015-11-20-aotu-blog-v1.md'">本文</a> }})。</ol><h2 id=关于博客的发布>关于博客的发布</h2><p>为了便于统一维护，博客的发布由<code>LV</code>负责。同学们写好博文并在本地预览OK后直接提交Github即可。]]></content:encoded>
      
      
    </item>
    
  </channel>
</rss>